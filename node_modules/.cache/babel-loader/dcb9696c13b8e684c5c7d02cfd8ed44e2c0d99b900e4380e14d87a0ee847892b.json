{"ast":null,"code":"import { ResourceUnavailableRpcError, SwitchChainError, UserRejectedRequestError, getAddress, numberToHex, withRetry, withTimeout } from 'viem';\nimport { ChainNotConfiguredError } from '../errors/config.js';\nimport { ProviderNotFoundError } from '../errors/connector.js';\nimport { createConnector } from './createConnector.js';\ninjected.type = 'injected';\nexport function injected(parameters = {}) {\n  const {\n    shimDisconnect = true,\n    unstable_shimAsyncInject\n  } = parameters;\n  function getTarget() {\n    const target = parameters.target;\n    if (typeof target === 'function') {\n      const result = target();\n      if (result) return result;\n    }\n    if (typeof target === 'object') return target;\n    if (typeof target === 'string') return {\n      ...(targetMap[target] ?? {\n        id: target,\n        name: `${target[0].toUpperCase()}${target.slice(1)}`,\n        provider: `is${target[0].toUpperCase()}${target.slice(1)}`\n      })\n    };\n    return {\n      id: 'injected',\n      name: 'Injected',\n      provider(window) {\n        return window?.ethereum;\n      }\n    };\n  }\n  let accountsChanged;\n  let chainChanged;\n  let connect;\n  let disconnect;\n  return createConnector(config => ({\n    get icon() {\n      return getTarget().icon;\n    },\n    get id() {\n      return getTarget().id;\n    },\n    get name() {\n      return getTarget().name;\n    },\n    /** @deprecated */\n    get supportsSimulation() {\n      return true;\n    },\n    type: injected.type,\n    async setup() {\n      const provider = await this.getProvider();\n      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n      if (provider?.on && parameters.target) {\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          provider.on('connect', connect);\n        }\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n      }\n    },\n    async connect({\n      chainId,\n      isReconnecting\n    } = {}) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      let accounts = [];\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => []);else if (shimDisconnect) {\n        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n        try {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            params: [{\n              eth_accounts: {}\n            }]\n          });\n          accounts = permissions[0]?.caveats?.[0]?.value?.map(x => getAddress(x));\n          // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n          // switch to `'eth_accounts'` ordering if more than one account is connected\n          // https://github.com/wevm/wagmi/issues/4140\n          if (accounts.length > 0) {\n            const sortedAccounts = await this.getAccounts();\n            accounts = sortedAccounts;\n          }\n        } catch (err) {\n          const error = err;\n          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n          // Only bubble up error if user rejects request\n          if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n          // Or prompt is already open\n          if (error.code === ResourceUnavailableRpcError.code) throw error;\n        }\n      }\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts'\n          });\n          accounts = requestedAccounts.map(x => getAddress(x));\n        }\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain({\n            chainId\n          }).catch(error => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return {\n              id: currentChainId\n            };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n        // Remove disconnected shim if it exists\n        if (shimDisconnect) await config.storage?.removeItem(`${this.id}.disconnected`);\n        // Add connected shim if no target exists\n        if (!parameters.target) await config.storage?.setItem('injected.connected', true);\n        return {\n          accounts,\n          chainId: currentChainId\n        };\n      } catch (err) {\n        const error = err;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        if (error.code === ResourceUnavailableRpcError.code) throw new ResourceUnavailableRpcError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n      // Experimental support for MetaMask disconnect\n      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n      try {\n        // Adding timeout as not all wallets support this method and can hang\n        // https://github.com/wevm/wagmi/issues/4064\n        await withTimeout(() =>\n        // TODO: Remove explicit type for viem@3\n        provider.request({\n          // `'wallet_revokePermissions'` added in `viem@2.10.3`\n          method: 'wallet_revokePermissions',\n          params: [{\n            eth_accounts: {}\n          }]\n        }), {\n          timeout: 100\n        });\n      } catch {}\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) {\n        await config.storage?.setItem(`${this.id}.disconnected`, true);\n      }\n      if (!parameters.target) await config.storage?.removeItem('injected.connected');\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const hexChainId = await provider.request({\n        method: 'eth_chainId'\n      });\n      return Number(hexChainId);\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined;\n      let provider;\n      const target = getTarget();\n      if (typeof target.provider === 'function') provider = target.provider(window);else if (typeof target.provider === 'string') provider = findProvider(window, target.provider);else provider = target.provider;\n      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n      if (provider && !provider.removeListener) {\n        // Try using `off` handler if it exists, otherwise noop\n        if ('off' in provider && typeof provider.off === 'function') provider.removeListener = provider.off;else provider.removeListener = () => {};\n      }\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected = shimDisconnect && (\n        // If shim exists in storage, connector is disconnected\n        await config.storage?.getItem(`${this.id}.disconnected`));\n        if (isDisconnected) return false;\n        // Don't allow injected connector to connect if no target is set and it hasn't already connected\n        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n        // automatically whenever there is a targeted connector configured.\n        if (!parameters.target) {\n          const connected = await config.storage?.getItem('injected.connected');\n          if (!connected) return false;\n        }\n        const provider = await this.getProvider();\n        if (!provider) {\n          if (unstable_shimAsyncInject !== undefined && unstable_shimAsyncInject !== false) {\n            // If no provider is found, check for async injection\n            // https://github.com/wevm/references/issues/167\n            // https://github.com/MetaMask/detect-provider\n            const handleEthereum = async () => {\n              if (typeof window !== 'undefined') window.removeEventListener('ethereum#initialized', handleEthereum);\n              const provider = await this.getProvider();\n              return !!provider;\n            };\n            const timeout = typeof unstable_shimAsyncInject === 'number' ? unstable_shimAsyncInject : 1_000;\n            const res = await Promise.race([...(typeof window !== 'undefined' ? [new Promise(resolve => window.addEventListener('ethereum#initialized', () => resolve(handleEthereum()), {\n              once: true\n            }))] : []), new Promise(resolve => setTimeout(() => resolve(handleEthereum()), timeout))]);\n            if (res) return true;\n          }\n          throw new ProviderNotFoundError();\n        }\n        // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n        // immediately resolve JSON-RPC requests on page load.\n        const accounts = await withRetry(() => this.getAccounts());\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({\n      addEthereumChainParameter,\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      const promise = new Promise(resolve => {\n        const listener = data => {\n          if ('chainId' in data && data.chainId === chainId) {\n            config.emitter.off('change', listener);\n            resolve();\n          }\n        };\n        config.emitter.on('change', listener);\n      });\n      try {\n        await Promise.all([provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: numberToHex(chainId)\n          }]\n        })\n        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n        // this callback or an externally emitted `'chainChanged'` event.\n        // https://github.com/MetaMask/metamask-extension/issues/24247\n        .then(async () => {\n          const currentChainId = await this.getChainId();\n          if (currentChainId === chainId) config.emitter.emit('change', {\n            chainId\n          });\n        }), promise]);\n        return chain;\n      } catch (err) {\n        const error = err;\n        // Indicates chain is not added to provider\n        if (error.code === 4902 ||\n        // Unwrapping for MetaMask Mobile\n        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n        error?.data?.originalError?.code === 4902) {\n          try {\n            const {\n              default: blockExplorer,\n              ...blockExplorers\n            } = chain.blockExplorers ?? {};\n            let blockExplorerUrls;\n            if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;else if (blockExplorer) blockExplorerUrls = [blockExplorer.url, ...Object.values(blockExplorers).map(x => x.url)];\n            let rpcUrls;\n            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;else rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n              rpcUrls\n            };\n            await Promise.all([provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain]\n            }).then(async () => {\n              const currentChainId = await this.getChainId();\n              if (currentChainId === chainId) config.emitter.emit('change', {\n                chainId\n              });else throw new UserRejectedRequestError(new Error('User rejected switch after adding network.'));\n            }), promise]);\n            return chain;\n          } catch (error) {\n            throw new UserRejectedRequestError(error);\n          }\n        }\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect();\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString();\n        this.onConnect({\n          chainId\n        });\n        // Remove disconnected shim if it exists\n        if (shimDisconnect) await config.storage?.removeItem(`${this.id}.disconnected`);\n      }\n      // Regular change event\n      else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts();\n      if (accounts.length === 0) return;\n      const chainId = Number(connectInfo.chainId);\n      config.emitter.emit('connect', {\n        accounts,\n        chainId\n      });\n      // Manage EIP-1193 event listeners\n      const provider = await this.getProvider();\n      if (provider) {\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider();\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && error.code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return;\n      }\n      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect');\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          provider.on('connect', connect);\n        }\n      }\n    }\n  }));\n}\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension;\n      return findProvider(window, 'isCoinbaseWallet');\n    }\n  },\n  metaMask: {\n    id: 'metaMask',\n    name: 'MetaMask',\n    provider(window) {\n      return findProvider(window, provider => {\n        if (!provider.isMetaMask) return false;\n        // Brave tries to make itself look like MetaMask\n        // Could also try RPC `web3_clientVersion` if following is unreliable\n        if (provider.isBraveWallet && !provider._events && !provider._state) return false;\n        // Other wallets that try to look like MetaMask\n        const flags = ['isApexWallet', 'isAvalanche', 'isBitKeep', 'isBlockWallet', 'isKuCoinWallet', 'isMathWallet', 'isOkxWallet', 'isOKExWallet', 'isOneInchIOSWallet', 'isOneInchAndroidWallet', 'isOpera', 'isPhantom', 'isPortal', 'isRabby', 'isTokenPocket', 'isTokenary', 'isUniswapWallet', 'isZerion'];\n        for (const flag of flags) if (provider[flag]) return false;\n        return true;\n      });\n    }\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (window?.phantom?.ethereum) return window.phantom?.ethereum;\n      return findProvider(window, 'isPhantom');\n    }\n  }\n};\nfunction findProvider(window, select) {\n  function isProvider(provider) {\n    if (typeof select === 'function') return select(provider);\n    if (typeof select === 'string') return provider[select];\n    return true;\n  }\n  const ethereum = window.ethereum;\n  if (ethereum?.providers) return ethereum.providers.find(provider => isProvider(provider));\n  if (ethereum && isProvider(ethereum)) return ethereum;\n  return undefined;\n}","map":{"version":3,"names":["ResourceUnavailableRpcError","SwitchChainError","UserRejectedRequestError","getAddress","numberToHex","withRetry","withTimeout","ChainNotConfiguredError","ProviderNotFoundError","createConnector","injected","type","parameters","shimDisconnect","unstable_shimAsyncInject","getTarget","target","result","targetMap","id","name","toUpperCase","slice","provider","window","ethereum","accountsChanged","chainChanged","connect","disconnect","config","icon","supportsSimulation","setup","getProvider","on","onConnect","bind","onAccountsChanged","chainId","isReconnecting","accounts","getAccounts","catch","permissions","request","method","params","eth_accounts","caveats","value","map","x","length","sortedAccounts","err","error","code","requestedAccounts","removeListener","undefined","onChainChanged","onDisconnect","currentChainId","getChainId","chain","switchChain","storage","removeItem","setItem","timeout","hexChainId","Number","findProvider","off","isAuthorized","isDisconnected","getItem","connected","handleEthereum","removeEventListener","res","Promise","race","resolve","addEventListener","once","setTimeout","addEthereumChainParameter","chains","find","promise","listener","data","emitter","all","then","emit","originalError","default","blockExplorer","blockExplorers","blockExplorerUrls","url","Object","values","rpcUrls","http","addEthereumChain","chainName","iconUrls","nativeCurrency","Error","listenerCount","toString","connectInfo","coinbaseWallet","coinbaseWalletExtension","metaMask","isMetaMask","isBraveWallet","_events","_state","flags","flag","phantom","select","isProvider","providers"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/core/src/connectors/injected.ts"],"sourcesContent":["import {\n  type AddEthereumChainParameter,\n  type Address,\n  type EIP1193Provider,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nimport type { Connector } from '../createConfig.js'\nimport { ChainNotConfiguredError } from '../errors/config.js'\nimport { ProviderNotFoundError } from '../errors/connector.js'\nimport type { Compute } from '../types/utils.js'\nimport { createConnector } from './createConnector.js'\n\nexport type InjectedParameters = {\n  /**\n   * Some injected providers do not support programmatic disconnect.\n   * This flag simulates the disconnect behavior by keeping track of connection status in storage.\n   * @default true\n   */\n  shimDisconnect?: boolean | undefined\n  /**\n   * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target\n   */\n  target?: TargetId | Target | (() => Target | undefined) | undefined\n  unstable_shimAsyncInject?: boolean | number | undefined\n}\n\ninjected.type = 'injected' as const\nexport function injected(parameters: InjectedParameters = {}) {\n  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters\n\n  function getTarget(): Compute<Target & { id: string }> {\n    const target = parameters.target\n    if (typeof target === 'function') {\n      const result = target()\n      if (result) return result\n    }\n\n    if (typeof target === 'object') return target\n\n    if (typeof target === 'string')\n      return {\n        ...(targetMap[target as keyof typeof targetMap] ?? {\n          id: target,\n          name: `${target[0]!.toUpperCase()}${target.slice(1)}`,\n          provider: `is${target[0]!.toUpperCase()}${target.slice(1)}`,\n        }),\n      }\n\n    return {\n      id: 'injected',\n      name: 'Injected',\n      provider(window) {\n        return window?.ethereum\n      },\n    }\n  }\n\n  type Provider = WalletProvider | undefined\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n  type StorageItem = {\n    [_ in 'injected.connected' | `${string}.disconnected`]: true\n  }\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let connect: Connector['onConnect'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    get icon() {\n      return getTarget().icon\n    },\n    get id() {\n      return getTarget().id\n    },\n    get name() {\n      return getTarget().name\n    },\n    /** @deprecated */\n    get supportsSimulation() {\n      return true\n    },\n    type: injected.type,\n    async setup() {\n      const provider = await this.getProvider()\n      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n      if (provider?.on && parameters.target) {\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      let accounts: readonly Address[] = []\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])\n      else if (shimDisconnect) {\n        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n        try {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            params: [{ eth_accounts: {} }],\n          })\n          accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(\n            (x) => getAddress(x),\n          )\n          // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n          // switch to `'eth_accounts'` ordering if more than one account is connected\n          // https://github.com/wevm/wagmi/issues/4140\n          if (accounts.length > 0) {\n            const sortedAccounts = await this.getAccounts()\n            accounts = sortedAccounts\n          }\n        } catch (err) {\n          const error = err as RpcError\n          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n          // Only bubble up error if user rejects request\n          if (error.code === UserRejectedRequestError.code)\n            throw new UserRejectedRequestError(error)\n          // Or prompt is already open\n          if (error.code === ResourceUnavailableRpcError.code) throw error\n        }\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts',\n          })\n          accounts = requestedAccounts.map((x) => getAddress(x))\n        }\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n\n        // Add connected shim if no target exists\n        if (!parameters.target)\n          await config.storage?.setItem('injected.connected', true)\n\n        return { accounts, chainId: currentChainId }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n\n      // Experimental support for MetaMask disconnect\n      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n      try {\n        // Adding timeout as not all wallets support this method and can hang\n        // https://github.com/wevm/wagmi/issues/4064\n        await withTimeout(\n          () =>\n            // TODO: Remove explicit type for viem@3\n            provider.request<{\n              Method: 'wallet_revokePermissions'\n              Parameters: [permissions: { eth_accounts: Record<string, any> }]\n              ReturnType: null\n            }>({\n              // `'wallet_revokePermissions'` added in `viem@2.10.3`\n              method: 'wallet_revokePermissions',\n              params: [{ eth_accounts: {} }],\n            }),\n          { timeout: 100 },\n        )\n      } catch {}\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) {\n        await config.storage?.setItem(`${this.id}.disconnected`, true)\n      }\n\n      if (!parameters.target)\n        await config.storage?.removeItem('injected.connected')\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return Number(hexChainId)\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined\n\n      let provider: Provider\n      const target = getTarget()\n      if (typeof target.provider === 'function')\n        provider = target.provider(window as Window | undefined)\n      else if (typeof target.provider === 'string')\n        provider = findProvider(window, target.provider)\n      else provider = target.provider\n\n      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n      if (provider && !provider.removeListener) {\n        // Try using `off` handler if it exists, otherwise noop\n        if ('off' in provider && typeof provider.off === 'function')\n          provider.removeListener =\n            provider.off as typeof provider.removeListener\n        else provider.removeListener = () => {}\n      }\n\n      return provider\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem(`${this.id}.disconnected`))\n        if (isDisconnected) return false\n\n        // Don't allow injected connector to connect if no target is set and it hasn't already connected\n        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n        // automatically whenever there is a targeted connector configured.\n        if (!parameters.target) {\n          const connected = await config.storage?.getItem('injected.connected')\n          if (!connected) return false\n        }\n\n        const provider = await this.getProvider()\n        if (!provider) {\n          if (\n            unstable_shimAsyncInject !== undefined &&\n            unstable_shimAsyncInject !== false\n          ) {\n            // If no provider is found, check for async injection\n            // https://github.com/wevm/references/issues/167\n            // https://github.com/MetaMask/detect-provider\n            const handleEthereum = async () => {\n              if (typeof window !== 'undefined')\n                window.removeEventListener(\n                  'ethereum#initialized',\n                  handleEthereum,\n                )\n              const provider = await this.getProvider()\n              return !!provider\n            }\n            const timeout =\n              typeof unstable_shimAsyncInject === 'number'\n                ? unstable_shimAsyncInject\n                : 1_000\n            const res = await Promise.race([\n              ...(typeof window !== 'undefined'\n                ? [\n                    new Promise<boolean>((resolve) =>\n                      window.addEventListener(\n                        'ethereum#initialized',\n                        () => resolve(handleEthereum()),\n                        { once: true },\n                      ),\n                    ),\n                  ]\n                : []),\n              new Promise<boolean>((resolve) =>\n                setTimeout(() => resolve(handleEthereum()), timeout),\n              ),\n            ])\n            if (res) return true\n          }\n\n          throw new ProviderNotFoundError()\n        }\n\n        // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n        // immediately resolve JSON-RPC requests on page load.\n        const accounts = await withRetry(() => this.getAccounts())\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const promise = new Promise<void>((resolve) => {\n        const listener = ((data) => {\n          if ('chainId' in data && data.chainId === chainId) {\n            config.emitter.off('change', listener)\n            resolve()\n          }\n        }) satisfies Parameters<typeof config.emitter.on>[1]\n        config.emitter.on('change', listener)\n      })\n\n      try {\n        await Promise.all([\n          provider\n            .request({\n              method: 'wallet_switchEthereumChain',\n              params: [{ chainId: numberToHex(chainId) }],\n            })\n            // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n            // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n            // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n            // this callback or an externally emitted `'chainChanged'` event.\n            // https://github.com/MetaMask/metamask-extension/issues/24247\n            .then(async () => {\n              const currentChainId = await this.getChainId()\n              if (currentChainId === chainId)\n                config.emitter.emit('change', { chainId })\n            }),\n          promise,\n        ])\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            const { default: blockExplorer, ...blockExplorers } =\n              chain.blockExplorers ?? {}\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else if (blockExplorer)\n              blockExplorerUrls = [\n                blockExplorer.url,\n                ...Object.values(blockExplorers).map((x) => x.url),\n              ]\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await Promise.all([\n              provider\n                .request({\n                  method: 'wallet_addEthereumChain',\n                  params: [addEthereumChain],\n                })\n                .then(async () => {\n                  const currentChainId = await this.getChainId()\n                  if (currentChainId === chainId)\n                    config.emitter.emit('change', { chainId })\n                  else\n                    throw new UserRejectedRequestError(\n                      new Error('User rejected switch after adding network.'),\n                    )\n                }),\n              promise,\n            ])\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        throw new SwitchChainError(error)\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect()\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      // Manage EIP-1193 event listeners\n      const provider = await this.getProvider()\n      if (provider) {\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect')\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n      }\n    },\n  }))\n}\n\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension\n      return findProvider(window, 'isCoinbaseWallet')\n    },\n  },\n  metaMask: {\n    id: 'metaMask',\n    name: 'MetaMask',\n    provider(window) {\n      return findProvider(window, (provider) => {\n        if (!provider.isMetaMask) return false\n        // Brave tries to make itself look like MetaMask\n        // Could also try RPC `web3_clientVersion` if following is unreliable\n        if (provider.isBraveWallet && !provider._events && !provider._state)\n          return false\n        // Other wallets that try to look like MetaMask\n        const flags = [\n          'isApexWallet',\n          'isAvalanche',\n          'isBitKeep',\n          'isBlockWallet',\n          'isKuCoinWallet',\n          'isMathWallet',\n          'isOkxWallet',\n          'isOKExWallet',\n          'isOneInchIOSWallet',\n          'isOneInchAndroidWallet',\n          'isOpera',\n          'isPhantom',\n          'isPortal',\n          'isRabby',\n          'isTokenPocket',\n          'isTokenary',\n          'isUniswapWallet',\n          'isZerion',\n        ] satisfies WalletProviderFlags[]\n        for (const flag of flags) if (provider[flag]) return false\n        return true\n      })\n    },\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (window?.phantom?.ethereum) return window.phantom?.ethereum\n      return findProvider(window, 'isPhantom')\n    },\n  },\n} as const satisfies TargetMap\n\ntype TargetMap = { [_ in TargetId]?: Target | undefined }\n\ntype Target = {\n  icon?: string | undefined\n  id: string\n  name: string\n  provider:\n    | WalletProviderFlags\n    | WalletProvider\n    | ((window?: Window | undefined) => WalletProvider | undefined)\n}\n\n/** @deprecated */\ntype TargetId = Compute<WalletProviderFlags> extends `is${infer name}`\n  ? name extends `${infer char}${infer rest}`\n    ? `${Lowercase<char>}${rest}`\n    : never\n  : never\n\n/**\n * @deprecated As of 2024/10/16, we are no longer accepting new provider flags as EIP-6963 should be used instead.\n */\ntype WalletProviderFlags =\n  | 'isApexWallet'\n  | 'isAvalanche'\n  | 'isBackpack'\n  | 'isBifrost'\n  | 'isBitKeep'\n  | 'isBitski'\n  | 'isBlockWallet'\n  | 'isBraveWallet'\n  | 'isCoinbaseWallet'\n  | 'isDawn'\n  | 'isEnkrypt'\n  | 'isExodus'\n  | 'isFrame'\n  | 'isFrontier'\n  | 'isGamestop'\n  | 'isHyperPay'\n  | 'isImToken'\n  | 'isKuCoinWallet'\n  | 'isMathWallet'\n  | 'isMetaMask'\n  | 'isOkxWallet'\n  | 'isOKExWallet'\n  | 'isOneInchAndroidWallet'\n  | 'isOneInchIOSWallet'\n  | 'isOpera'\n  | 'isPhantom'\n  | 'isPortal'\n  | 'isRabby'\n  | 'isRainbow'\n  | 'isStatus'\n  | 'isTally'\n  | 'isTokenPocket'\n  | 'isTokenary'\n  | 'isTrust'\n  | 'isTrustWallet'\n  | 'isUniswapWallet'\n  | 'isXDEFI'\n  | 'isZerion'\n\ntype WalletProvider = Compute<\n  EIP1193Provider & {\n    [key in WalletProviderFlags]?: true | undefined\n  } & {\n    providers?: WalletProvider[] | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _events?: { connect?: (() => void) | undefined } | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _state?:\n      | {\n          accounts?: string[]\n          initialized?: boolean\n          isConnected?: boolean\n          isPermanentlyDisconnected?: boolean\n          isUnlocked?: boolean\n        }\n      | undefined\n  }\n>\n\ntype Window = {\n  coinbaseWalletExtension?: WalletProvider | undefined\n  ethereum?: WalletProvider | undefined\n  phantom?: { ethereum: WalletProvider } | undefined\n}\n\nfunction findProvider(\n  window: globalThis.Window | Window | undefined,\n  select?: WalletProviderFlags | ((provider: WalletProvider) => boolean),\n) {\n  function isProvider(provider: WalletProvider) {\n    if (typeof select === 'function') return select(provider)\n    if (typeof select === 'string') return provider[select]\n    return true\n  }\n\n  const ethereum = (window as Window).ethereum\n  if (ethereum?.providers)\n    return ethereum.providers.find((provider) => isProvider(provider))\n  if (ethereum && isProvider(ethereum)) return ethereum\n  return undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}