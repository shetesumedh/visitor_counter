{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyHash = verifyHash;\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst contracts_js_1 = require(\"../../constants/contracts.js\");\nconst contract_js_1 = require(\"../../errors/contract.js\");\nconst encodeDeployData_js_1 = require(\"../../utils/abi/encodeDeployData.js\");\nconst getAddress_js_1 = require(\"../../utils/address/getAddress.js\");\nconst isAddressEqual_js_1 = require(\"../../utils/address/isAddressEqual.js\");\nconst isHex_js_1 = require(\"../../utils/data/isHex.js\");\nconst toHex_js_1 = require(\"../../utils/encoding/toHex.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst index_js_1 = require(\"../../utils/index.js\");\nconst isErc6492Signature_js_1 = require(\"../../utils/signature/isErc6492Signature.js\");\nconst recoverAddress_js_1 = require(\"../../utils/signature/recoverAddress.js\");\nconst serializeErc6492Signature_js_1 = require(\"../../utils/signature/serializeErc6492Signature.js\");\nconst serializeSignature_js_1 = require(\"../../utils/signature/serializeSignature.js\");\nconst call_js_1 = require(\"./call.js\");\nasync function verifyHash(client, parameters) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address,\n    ...rest\n  } = parameters;\n  const signatureHex = (() => {\n    if ((0, isHex_js_1.isHex)(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return (0, serializeSignature_js_1.serializeSignature)(signature);\n    return (0, toHex_js_1.bytesToHex)(signature);\n  })();\n  const wrappedSignature = await (async () => {\n    if (!factory && !factoryData) return signatureHex;\n    if ((0, isErc6492Signature_js_1.isErc6492Signature)(signatureHex)) return signatureHex;\n    return (0, serializeErc6492Signature_js_1.serializeErc6492Signature)({\n      address: factory,\n      data: factoryData,\n      signature: signatureHex\n    });\n  })();\n  try {\n    const args = universalSignatureVerifierAddress ? {\n      to: universalSignatureVerifierAddress,\n      data: (0, index_js_1.encodeFunctionData)({\n        abi: abis_js_1.universalSignatureValidatorAbi,\n        functionName: 'isValidSig',\n        args: [address, hash, wrappedSignature]\n      }),\n      ...rest\n    } : {\n      data: (0, encodeDeployData_js_1.encodeDeployData)({\n        abi: abis_js_1.universalSignatureValidatorAbi,\n        args: [address, hash, wrappedSignature],\n        bytecode: contracts_js_1.universalSignatureValidatorByteCode\n      }),\n      ...rest\n    };\n    const {\n      data\n    } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')(args);\n    return (0, index_js_1.hexToBool)(data ?? '0x0');\n  } catch (error) {\n    try {\n      const verified = (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverAddress_js_1.recoverAddress)({\n        hash,\n        signature\n      }));\n      if (verified) return true;\n    } catch {}\n    if (error instanceof contract_js_1.CallExecutionError) {\n      return false;\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["exports","verifyHash","abis_js_1","require","contracts_js_1","contract_js_1","encodeDeployData_js_1","getAddress_js_1","isAddressEqual_js_1","isHex_js_1","toHex_js_1","getAction_js_1","index_js_1","isErc6492Signature_js_1","recoverAddress_js_1","serializeErc6492Signature_js_1","serializeSignature_js_1","call_js_1","client","parameters","address","factory","factoryData","hash","signature","universalSignatureVerifierAddress","chain","contracts","universalSignatureVerifier","rest","signatureHex","isHex","serializeSignature","bytesToHex","wrappedSignature","isErc6492Signature","serializeErc6492Signature","data","args","to","encodeFunctionData","abi","universalSignatureValidatorAbi","functionName","encodeDeployData","bytecode","universalSignatureValidatorByteCode","getAction","call","hexToBool","error","verified","isAddressEqual","getAddress","recoverAddress","CallExecutionError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js'\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport { getAddress } from '../../utils/address/getAddress.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type ToHexErrorType, bytesToHex } from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { encodeFunctionData, hexToBool } from '../../utils/index.js'\nimport { isErc6492Signature } from '../../utils/signature/isErc6492Signature.js'\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hex\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | CallErrorType\n  | IsHexErrorType\n  | ToHexErrorType\n  | InvalidHexBooleanError\n  | EncodeDeployDataErrorType\n  | ErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    universalSignatureVerifierAddress = client.chain?.contracts\n      ?.universalSignatureVerifier?.address,\n    ...rest\n  } = parameters\n\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signatureHex\n\n    // If the signature is already wrapped, return the signature.\n    if (isErc6492Signature(signatureHex)) return signatureHex\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return serializeErc6492Signature({\n      address: factory!,\n      data: factoryData!,\n      signature: signatureHex,\n    })\n  })()\n\n  try {\n    const args = universalSignatureVerifierAddress\n      ? ({\n          to: universalSignatureVerifierAddress,\n          data: encodeFunctionData({\n            abi: universalSignatureValidatorAbi,\n            functionName: 'isValidSig',\n            args: [address, hash, wrappedSignature],\n          }),\n          ...rest,\n        } as unknown as CallParameters)\n      : ({\n          data: encodeDeployData({\n            abi: universalSignatureValidatorAbi,\n            args: [address, hash, wrappedSignature],\n            bytecode: universalSignatureValidatorByteCode,\n          }),\n          ...rest,\n        } as unknown as CallParameters)\n\n    const { data } = await getAction(client, call, 'call')(args)\n\n    return hexToBool(data ?? '0x0')\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}