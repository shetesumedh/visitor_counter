{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keccak256 = keccak256;\nexports.ripemd160 = ripemd160;\nexports.sha256 = sha256;\nexports.validate = validate;\nconst ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nconst sha3_1 = require(\"@noble/hashes/sha3\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst Bytes = require(\"./Bytes.js\");\nconst Hex = require(\"./Hex.js\");\nfunction keccak256(value, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const bytes = (0, sha3_1.keccak_256)(Bytes.from(value));\n  if (as === 'Bytes') return bytes;\n  return Hex.fromBytes(bytes);\n}\nfunction ripemd160(value, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const bytes = (0, ripemd160_1.ripemd160)(Bytes.from(value));\n  if (as === 'Bytes') return bytes;\n  return Hex.fromBytes(bytes);\n}\nfunction sha256(value, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const bytes = (0, sha256_1.sha256)(Bytes.from(value));\n  if (as === 'Bytes') return bytes;\n  return Hex.fromBytes(bytes);\n}\nfunction validate(value) {\n  return Hex.validate(value) && Hex.size(value) === 32;\n}","map":{"version":3,"names":["exports","keccak256","ripemd160","sha256","validate","ripemd160_1","require","sha3_1","sha256_1","Bytes","Hex","value","options","as","bytes","keccak_256","from","fromBytes","size"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/Hash.ts"],"sourcesContent":["import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n"],"mappings":";;;;;AA4CAA,OAAA,CAAAC,SAAA,GAAAA,SAAA;AAgDAD,OAAA,CAAAE,SAAA,GAAAA,SAAA;AAgDAF,OAAA,CAAAG,MAAA,GAAAA,MAAA;AAgDAH,OAAA,CAAAI,QAAA,GAAAA,QAAA;AA5LA,MAAAC,WAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,KAAA,GAAAH,OAAA;AAEA,MAAAI,GAAA,GAAAJ,OAAA;AAuCA,SAAgBL,SAASA,CAMvBU,KAAoC,EACpCC,OAAA,GAAiC,EAAE;EAEnC,MAAM;IAAEC,EAAE,GAAG,OAAOF,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG;EAAO,CAAE,GAAGC,OAAO;EACpE,MAAME,KAAK,GAAG,IAAAP,MAAA,CAAAQ,UAAe,EAACN,KAAK,CAACO,IAAI,CAACL,KAAK,CAAC,CAAC;EAChD,IAAIE,EAAE,KAAK,OAAO,EAAE,OAAOC,KAAc;EACzC,OAAOJ,GAAG,CAACO,SAAS,CAACH,KAAK,CAAU;AACtC;AAmCA,SAAgBZ,SAASA,CAMvBS,KAAoC,EACpCC,OAAA,GAAiC,EAAE;EAEnC,MAAM;IAAEC,EAAE,GAAG,OAAOF,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG;EAAO,CAAE,GAAGC,OAAO;EACpE,MAAME,KAAK,GAAG,IAAAT,WAAA,CAAAH,SAAe,EAACO,KAAK,CAACO,IAAI,CAACL,KAAK,CAAC,CAAC;EAChD,IAAIE,EAAE,KAAK,OAAO,EAAE,OAAOC,KAAc;EACzC,OAAOJ,GAAG,CAACO,SAAS,CAACH,KAAK,CAAU;AACtC;AAmCA,SAAgBX,MAAMA,CAMpBQ,KAAoC,EACpCC,OAAA,GAA8B,EAAE;EAEhC,MAAM;IAAEC,EAAE,GAAG,OAAOF,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG;EAAO,CAAE,GAAGC,OAAO;EACpE,MAAME,KAAK,GAAG,IAAAN,QAAA,CAAAL,MAAY,EAACM,KAAK,CAACO,IAAI,CAACL,KAAK,CAAC,CAAC;EAC7C,IAAIE,EAAE,KAAK,OAAO,EAAE,OAAOC,KAAc;EACzC,OAAOJ,GAAG,CAACO,SAAS,CAACH,KAAK,CAAU;AACtC;AAmCA,SAAgBV,QAAQA,CAACO,KAAa;EACpC,OAAOD,GAAG,CAACN,QAAQ,CAACO,KAAK,CAAC,IAAID,GAAG,CAACQ,IAAI,CAACP,KAAK,CAAC,KAAK,EAAE;AACtD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}