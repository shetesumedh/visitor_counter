{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForTransactionReceipt = waitForTransactionReceipt;\nconst block_js_1 = require(\"../../errors/block.js\");\nconst transaction_js_1 = require(\"../../errors/transaction.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst observe_js_1 = require(\"../../utils/observe.js\");\nconst withResolvers_js_1 = require(\"../../utils/promise/withResolvers.js\");\nconst withRetry_js_1 = require(\"../../utils/promise/withRetry.js\");\nconst stringify_js_1 = require(\"../../utils/stringify.js\");\nconst getBlock_js_1 = require(\"./getBlock.js\");\nconst getTransaction_js_1 = require(\"./getTransaction.js\");\nconst getTransactionReceipt_js_1 = require(\"./getTransactionReceipt.js\");\nconst watchBlockNumber_js_1 = require(\"./watchBlockNumber.js\");\nasync function waitForTransactionReceipt(client, parameters) {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = ({\n      count\n    }) => ~~(1 << count) * 200,\n    timeout = 180_000\n  } = parameters;\n  const observerId = (0, stringify_js_1.stringify)(['waitForTransactionReceipt', client.uid, hash]);\n  const pollingInterval = (() => {\n    if (parameters.pollingInterval) return parameters.pollingInterval;\n    if (client.chain?.experimental_preconfirmationTime) return client.chain.experimental_preconfirmationTime;\n    return client.pollingInterval;\n  })();\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  let _unobserve;\n  let _unwatch;\n  const {\n    promise,\n    resolve,\n    reject\n  } = (0, withResolvers_js_1.withResolvers)();\n  const timer = timeout ? setTimeout(() => {\n    _unwatch();\n    _unobserve();\n    reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({\n      hash\n    }));\n  }, timeout) : undefined;\n  _unobserve = (0, observe_js_1.observe)(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, async emit => {\n    receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n      hash\n    }).catch(() => undefined);\n    if (receipt && confirmations <= 1) {\n      clearTimeout(timer);\n      emit.resolve(receipt);\n      _unobserve();\n      return;\n    }\n    _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          clearTimeout(timer);\n          _unwatch();\n          fn();\n          _unobserve();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          if (checkReplacement && !transaction) {\n            retrying = true;\n            await (0, withRetry_js_1.withRetry)(async () => {\n              transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          if (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              retrying = true;\n              const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: ({\n                  error\n                }) => error instanceof block_js_1.BlockNotFoundError\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(({\n                from,\n                nonce\n              }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n              if (!replacementTransaction) return;\n              receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                emit.onReplaced?.({\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}","map":{"version":3,"names":["exports","waitForTransactionReceipt","block_js_1","require","transaction_js_1","getAction_js_1","observe_js_1","withResolvers_js_1","withRetry_js_1","stringify_js_1","getBlock_js_1","getTransaction_js_1","getTransactionReceipt_js_1","watchBlockNumber_js_1","client","parameters","checkReplacement","confirmations","hash","onReplaced","retryCount","retryDelay","count","timeout","observerId","stringify","uid","pollingInterval","chain","experimental_preconfirmationTime","transaction","replacedTransaction","receipt","retrying","_unobserve","_unwatch","promise","resolve","reject","withResolvers","timer","setTimeout","WaitForTransactionReceiptTimeoutError","undefined","observe","emit","getAction","getTransactionReceipt","catch","clearTimeout","watchBlockNumber","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","blockNumber","withRetry","getTransaction","delay","err","TransactionNotFoundError","TransactionReceiptNotFoundError","block","getBlock","includeTransactions","shouldRetry","error","BlockNotFoundError","replacementTransaction","transactions","find","from","nonce","reason","to","value","input","transactionReceipt","err_"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/actions/public/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * Whether to check for transaction replacements.\n   * @default true\n   */\n  checkReplacement?: boolean | undefined\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   * @default 180_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | WaitForTransactionReceiptTimeoutErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000,\n  } = parameters\n\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  const pollingInterval = (() => {\n    if (parameters.pollingInterval) return parameters.pollingInterval\n    if (client.chain?.experimental_preconfirmationTime)\n      return client.chain.experimental_preconfirmationTime\n    return client.pollingInterval\n  })()\n\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain> | undefined\n  let retrying = false\n\n  // biome-ignore lint/style/useConst:\n  let _unobserve: () => void\n  let _unwatch: () => void\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForTransactionReceiptReturnType<chain>>()\n\n  const timer = timeout\n    ? setTimeout(() => {\n        _unwatch()\n        _unobserve()\n        reject(new WaitForTransactionReceiptTimeoutError({ hash }))\n      }, timeout)\n    : undefined\n\n  _unobserve = observe(\n    observerId,\n    { onReplaced, resolve, reject },\n    async (emit) => {\n      receipt = await getAction(\n        client,\n        getTransactionReceipt,\n        'getTransactionReceipt',\n      )({ hash }).catch(() => undefined)\n\n      if (receipt && confirmations <= 1) {\n        clearTimeout(timer)\n        emit.resolve(receipt)\n        _unobserve()\n        return\n      }\n\n      _unwatch = getAction(\n        client,\n        watchBlockNumber,\n        'watchBlockNumber',\n      )({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = (fn: () => void) => {\n            clearTimeout(timer)\n            _unwatch()\n            fn()\n            _unobserve()\n          }\n\n          let blockNumber = blockNumber_\n\n          if (retrying) return\n\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt!))\n              return\n            }\n\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (checkReplacement && !transaction) {\n              retrying = true\n              await withRetry(\n                async () => {\n                  transaction = (await getAction(\n                    client,\n                    getTransaction,\n                    'getTransaction',\n                  )({ hash })) as GetTransactionReturnType<chain>\n                  if (transaction.blockNumber)\n                    blockNumber = transaction.blockNumber\n                },\n                {\n                  delay: retryDelay,\n                  retryCount,\n                },\n              )\n              retrying = false\n            }\n\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(\n              client,\n              getTransactionReceipt,\n              'getTransactionReceipt',\n            )({ hash })\n\n            // Check if we have enough confirmations. If not, continue polling.\n            if (\n              confirmations > 1 &&\n              (!receipt.blockNumber ||\n                blockNumber - receipt.blockNumber + 1n < confirmations)\n            )\n              return\n\n            done(() => emit.resolve(receipt!))\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (\n              err instanceof TransactionNotFoundError ||\n              err instanceof TransactionReceiptNotFoundError\n            ) {\n              if (!transaction) {\n                retrying = false\n                return\n              }\n\n              try {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true\n                const block = await withRetry(\n                  () =>\n                    getAction(\n                      client,\n                      getBlock,\n                      'getBlock',\n                    )({\n                      blockNumber,\n                      includeTransactions: true,\n                    }),\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                    shouldRetry: ({ error }) =>\n                      error instanceof BlockNotFoundError,\n                  },\n                )\n                retrying = false\n\n                const replacementTransaction = (\n                  block.transactions as {} as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(\n                  client,\n                  getTransactionReceipt,\n                  'getTransactionReceipt',\n                )({\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value &&\n                  replacementTransaction.input === replacedTransaction.input\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction! as any,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt!,\n                  })\n                  emit.resolve(receipt!)\n                })\n              } catch (err_) {\n                done(() => emit.reject(err_))\n              }\n            } else {\n              done(() => emit.reject(err))\n            }\n          }\n        },\n      })\n    },\n  )\n\n  return promise\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}