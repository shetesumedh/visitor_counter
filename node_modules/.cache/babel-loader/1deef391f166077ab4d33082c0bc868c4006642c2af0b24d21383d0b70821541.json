{"ast":null,"code":"import { parseAccount } from '../../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../../errors/account.js';\nimport { getAction } from '../../../utils/getAction.js';\nimport { serializeStateOverride } from '../../../utils/stateOverride.js';\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js';\nimport { formatUserOperationGas } from '../../utils/formatters/userOperationGas.js';\nimport { formatUserOperationRequest } from '../../utils/formatters/userOperationRequest.js';\nimport { prepareUserOperation } from './prepareUserOperation.js';\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas(client, parameters) {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride\n  } = parameters;\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError();\n  const account = account_ ? parseAccount(account_) : undefined;\n  const rpcStateOverride = serializeStateOverride(stateOverride);\n  const request = account ? await getAction(client, prepareUserOperation, 'prepareUserOperation')({\n    ...parameters,\n    parameters: ['authorization', 'factory', 'nonce', 'paymaster', 'signature']\n  }) : parameters;\n  try {\n    const params = [formatUserOperationRequest(request), entryPointAddress ?? account?.entryPoint?.address];\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params]\n    });\n    return formatUserOperationGas(result);\n  } catch (error) {\n    const calls = parameters.calls;\n    throw getUserOperationError(error, {\n      ...request,\n      ...(calls ? {\n        calls\n      } : {})\n    });\n  }\n}","map":{"version":3,"names":["parseAccount","AccountNotFoundError","getAction","serializeStateOverride","getUserOperationError","formatUserOperationGas","formatUserOperationRequest","prepareUserOperation","estimateUserOperationGas","client","parameters","account","account_","entryPointAddress","stateOverride","sender","undefined","rpcStateOverride","request","params","entryPoint","address","result","method","error","calls"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/account-abstraction/actions/bundler/estimateUserOperationGas.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  MaybeRequired,\n  OneOf,\n  Prettify,\n} from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { serializeStateOverride } from '../../../utils/stateOverride.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  EstimateUserOperationGasReturnType as EstimateUserOperationGasReturnType_,\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from '../../utils/formatters/userOperationGas.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type EstimateUserOperationGasParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  > & {\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n\nexport type EstimateUserOperationGasReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<EstimateUserOperationGasReturnType_<_derivedVersion>>\n\nexport type EstimateUserOperationGasErrorType =\n  | ParseAccountErrorType\n  | PrepareUserOperationErrorType\n  | FormatUserOperationRequestErrorType\n  | FormatUserOperationGasErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: EstimateUserOperationGasParameters<\n    account,\n    accountOverride,\n    calls\n  >,\n): Promise<EstimateUserOperationGasReturnType<account, accountOverride>> {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride,\n  } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const rpcStateOverride = serializeStateOverride(stateOverride)\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )({\n        ...parameters,\n        parameters: [\n          'authorization',\n          'factory',\n          'nonce',\n          'paymaster',\n          'signature',\n        ],\n      } as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  try {\n    const params = [\n      formatUserOperationRequest(request as UserOperation),\n      (entryPointAddress ?? account?.entryPoint?.address)!,\n    ] as const\n\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params],\n    })\n    return formatUserOperationGas(result) as EstimateUserOperationGasReturnType<\n      account,\n      accountOverride\n    >\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n    })\n  }\n}\n"],"mappings":"AACA,SAEEA,YAAY,QACP,yCAAyC;AAGhD,SAASC,oBAAoB,QAAQ,4BAA4B;AAcjE,SAASC,SAAS,QAAQ,6BAA6B;AACvD,SAASC,sBAAsB,QAAQ,iCAAiC;AAgBxE,SAASC,qBAAqB,QAAQ,6CAA6C;AACnF,SAEEC,sBAAsB,QACjB,4CAA4C;AACnD,SAEEC,0BAA0B,QACrB,gDAAgD;AACvD,SAGEC,oBAAoB,QACf,2BAA2B;AAoElC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAO,eAAeC,wBAAwBA,CAK5CC,MAAqD,EACrDC,UAIC;EAED,MAAM;IACJC,OAAO,EAAEC,QAAQ,GAAGH,MAAM,CAACE,OAAO;IAClCE,iBAAiB;IACjBC;EAAa,CACd,GAAGJ,UAAU;EAEd,IAAI,CAACE,QAAQ,IAAI,CAACF,UAAU,CAACK,MAAM,EAAE,MAAM,IAAId,oBAAoB,EAAE;EACrE,MAAMU,OAAO,GAAGC,QAAQ,GAAGZ,YAAY,CAACY,QAAQ,CAAC,GAAGI,SAAS;EAE7D,MAAMC,gBAAgB,GAAGd,sBAAsB,CAACW,aAAa,CAAC;EAE9D,MAAMI,OAAO,GAAGP,OAAO,GACnB,MAAMT,SAAS,CACbO,MAAM,EACNF,oBAAoB,EACpB,sBAAsB,CACvB,CAAC;IACA,GAAGG,UAAU;IACbA,UAAU,EAAE,CACV,eAAe,EACf,SAAS,EACT,OAAO,EACP,WAAW,EACX,WAAW;GAE+B,CAAC,GAC/CA,UAAU;EAEd,IAAI;IACF,MAAMS,MAAM,GAAG,CACbb,0BAA0B,CAACY,OAAwB,CAAC,EACnDL,iBAAiB,IAAIF,OAAO,EAAES,UAAU,EAAEC,OAAO,CAC1C;IAEV,MAAMC,MAAM,GAAG,MAAMb,MAAM,CAACS,OAAO,CAAC;MAClCK,MAAM,EAAE,8BAA8B;MACtCJ,MAAM,EAAEF,gBAAgB,GAAG,CAAC,GAAGE,MAAM,EAAEF,gBAAgB,CAAC,GAAG,CAAC,GAAGE,MAAM;KACtE,CAAC;IACF,OAAOd,sBAAsB,CAACiB,MAAM,CAGnC;EACH,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd,MAAMC,KAAK,GAAIf,UAAkB,CAACe,KAAK;IACvC,MAAMrB,qBAAqB,CAACoB,KAAkB,EAAE;MAC9C,GAAIN,OAAyB;MAC7B,IAAIO,KAAK,GAAG;QAAEA;MAAK,CAAE,GAAG,EAAE;KAC3B,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}