{"ast":null,"code":"import { HDKey } from '@scure/bip32';\nimport * as Bytes from './Bytes.js';\nimport * as internal from './internal/hdKey.js';\n/**\n * Creates a HD Key from an extended private key.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromExtendedKey('...')\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param extendedKey - The extended private key.\n * @returns The HD Key.\n */\nexport function fromExtendedKey(extendedKey) {\n  const key = HDKey.fromExtendedKey(extendedKey);\n  return internal.fromScure(key);\n}\n/**\n * Creates a HD Key from a JSON object containing an extended private key (`xpriv`).\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromJson({ xpriv: '...' })\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param json - The JSON object containing an extended private key (`xpriv`).\n * @returns The HD Key.\n */\nexport function fromJson(json) {\n  return internal.fromScure(HDKey.fromJSON(json));\n}\n/**\n * Creates a HD Key from a master seed.\n *\n * @example\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const seed = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(seed)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`.\n *\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(mnemonic).derive(HdKey.path())\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param seed - The master seed to create the HD Key from.\n * @param options - Creation options.\n * @returns The HD Key.\n */\nexport function fromSeed(seed, options = {}) {\n  const {\n    versions\n  } = options;\n  const key = HDKey.fromMasterSeed(Bytes.from(seed), versions);\n  return internal.fromScure(key);\n}\n/**\n * Creates an Ethereum-based BIP-44 HD path.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const path = HdKey.path({ account: 1, index: 2 })\n * // @log: \"m/44'/60'/1'/0/2\"\n * ```\n *\n * @param options - Path options.\n * @returns The path.\n */\nexport function path(options = {}) {\n  const {\n    account = 0,\n    change = 0,\n    index = 0\n  } = options;\n  return `m/44'/60'/${account}'/${change}/${index}`;\n}","map":{"version":3,"names":["HDKey","Bytes","internal","fromExtendedKey","extendedKey","key","fromScure","fromJson","json","fromJSON","fromSeed","seed","options","versions","fromMasterSeed","from","path","account","change","index"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/HdKey.ts"],"sourcesContent":["import { HDKey, type Versions } from '@scure/bip32'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport type * as PublicKey from './PublicKey.js'\nimport * as internal from './internal/hdKey.js'\n\n/** Root type for a Hierarchical Deterministic (HD) Key. */\nexport type HdKey = {\n  derive: (path: string) => HdKey\n  depth: number\n  index: number\n  identifier: Hex.Hex\n  privateKey: Hex.Hex\n  privateExtendedKey: string\n  publicKey: PublicKey.PublicKey<false>\n  publicExtendedKey: string\n  versions: Versions\n}\n\n/**\n * Creates a HD Key from an extended private key.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromExtendedKey('...')\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param extendedKey - The extended private key.\n * @returns The HD Key.\n */\nexport function fromExtendedKey(extendedKey: string): HdKey {\n  const key = HDKey.fromExtendedKey(extendedKey)\n  return internal.fromScure(key)\n}\n\nexport declare namespace fromExtendedKey {\n  type ErrorType = internal.fromScure.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Creates a HD Key from a JSON object containing an extended private key (`xpriv`).\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromJson({ xpriv: '...' })\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param json - The JSON object containing an extended private key (`xpriv`).\n * @returns The HD Key.\n */\nexport function fromJson(json: { xpriv: string }): HdKey {\n  return internal.fromScure(HDKey.fromJSON(json))\n}\n\nexport declare namespace fromJson {\n  type ErrorType = internal.fromScure.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Creates a HD Key from a master seed.\n *\n * @example\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const seed = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(seed)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`.\n *\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(mnemonic).derive(HdKey.path())\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param seed - The master seed to create the HD Key from.\n * @param options - Creation options.\n * @returns The HD Key.\n */\nexport function fromSeed(\n  seed: Hex.Hex | Bytes.Bytes,\n  options: fromSeed.Options = {},\n): HdKey {\n  const { versions } = options\n  const key = HDKey.fromMasterSeed(Bytes.from(seed), versions)\n  return internal.fromScure(key)\n}\n\nexport declare namespace fromSeed {\n  type Options = {\n    /** The versions to use for the HD Key. */\n    versions?: Versions | undefined\n  }\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | internal.fromScure.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates an Ethereum-based BIP-44 HD path.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const path = HdKey.path({ account: 1, index: 2 })\n * // @log: \"m/44'/60'/1'/0/2\"\n * ```\n *\n * @param options - Path options.\n * @returns The path.\n */\nexport function path(options: path.Options = {}): string {\n  const { account = 0, change = 0, index = 0 } = options\n  return `m/44'/60'/${account}'/${change}/${index}`\n}\n\nexport declare namespace path {\n  type Options = {\n    /**\n     * The account.\n     * @default 0\n     */\n    account?: number | undefined\n    /**\n     * The change.\n     * @default 0\n     */\n    change?: number | undefined\n    /**\n     * The address index.\n     * @default 0\n     */\n    index?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAuB,cAAc;AACnD,OAAO,KAAKC,KAAK,MAAM,YAAY;AAInC,OAAO,KAAKC,QAAQ,MAAM,qBAAqB;AAe/C;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUC,eAAeA,CAACC,WAAmB;EACjD,MAAMC,GAAG,GAAGL,KAAK,CAACG,eAAe,CAACC,WAAW,CAAC;EAC9C,OAAOF,QAAQ,CAACI,SAAS,CAACD,GAAG,CAAC;AAChC;AAMA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUE,QAAQA,CAACC,IAAuB;EAC9C,OAAON,QAAQ,CAACI,SAAS,CAACN,KAAK,CAACS,QAAQ,CAACD,IAAI,CAAC,CAAC;AACjD;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAM,SAAUE,QAAQA,CACtBC,IAA2B,EAC3BC,OAAA,GAA4B,EAAE;EAE9B,MAAM;IAAEC;EAAQ,CAAE,GAAGD,OAAO;EAC5B,MAAMP,GAAG,GAAGL,KAAK,CAACc,cAAc,CAACb,KAAK,CAACc,IAAI,CAACJ,IAAI,CAAC,EAAEE,QAAQ,CAAC;EAC5D,OAAOX,QAAQ,CAACI,SAAS,CAACD,GAAG,CAAC;AAChC;AAcA;;;;;;;;;;;;;;AAcA,OAAM,SAAUW,IAAIA,CAACJ,OAAA,GAAwB,EAAE;EAC7C,MAAM;IAAEK,OAAO,GAAG,CAAC;IAAEC,MAAM,GAAG,CAAC;IAAEC,KAAK,GAAG;EAAC,CAAE,GAAGP,OAAO;EACtD,OAAO,aAAaK,OAAO,KAAKC,MAAM,IAAIC,KAAK,EAAE;AACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}