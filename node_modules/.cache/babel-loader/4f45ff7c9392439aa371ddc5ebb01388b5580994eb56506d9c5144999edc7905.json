{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContractAddress = getContractAddress;\nexports.getCreateAddress = getCreateAddress;\nexports.getCreate2Address = getCreate2Address;\nconst concat_js_1 = require(\"../data/concat.js\");\nconst isBytes_js_1 = require(\"../data/isBytes.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst slice_js_1 = require(\"../data/slice.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst toRlp_js_1 = require(\"../encoding/toRlp.js\");\nconst keccak256_js_1 = require(\"../hash/keccak256.js\");\nconst getAddress_js_1 = require(\"./getAddress.js\");\nfunction getContractAddress(opts) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts);\n  return getCreateAddress(opts);\n}\nfunction getCreateAddress(opts) {\n  const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));\n  let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);\n  if (nonce[0] === 0) nonce = new Uint8Array([]);\n  return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], 'bytes')).slice(26)}`);\n}\nfunction getCreate2Address(opts) {\n  const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));\n  const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {\n    size: 32\n  });\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in opts) {\n      if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash)) return opts.bytecodeHash;\n      return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);\n    }\n    return (0, keccak256_js_1.keccak256)(opts.bytecode, 'bytes');\n  })();\n  return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)('0xff'), from, salt, bytecodeHash])), 12));\n}","map":{"version":3,"names":["exports","getContractAddress","getCreateAddress","getCreate2Address","concat_js_1","require","isBytes_js_1","pad_js_1","slice_js_1","toBytes_js_1","toRlp_js_1","keccak256_js_1","getAddress_js_1","opts","opcode","from","toBytes","getAddress","nonce","Uint8Array","keccak256","toRlp","slice","salt","pad","isBytes","size","bytecodeHash","bytecode","concat"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/address/getContractAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type IsBytesErrorType, isBytes } from '../data/isBytes.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type GetAddressErrorType, getAddress } from './getAddress.js'\n\nexport type GetCreateAddressOptions = {\n  from: Address\n  nonce: bigint\n}\n\nexport type GetCreate2AddressOptions =\n  | {\n      bytecode: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n  | {\n      bytecodeHash: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n\nexport type GetContractAddressOptions =\n  | ({\n      opcode?: 'CREATE' | undefined\n    } & GetCreateAddressOptions)\n  | ({ opcode: 'CREATE2' } & GetCreate2AddressOptions)\n\nexport function getContractAddress(opts: GetContractAddressOptions) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts)\n  return getCreateAddress(opts)\n}\n\nexport type GetCreateAddressErrorType =\n  | Keccak256ErrorType\n  | GetAddressErrorType\n  | ToBytesErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nexport function getCreateAddress(opts: GetCreateAddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n\n  let nonce = toBytes(opts.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return getAddress(\n    `0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}` as Address,\n  )\n}\n\nexport type GetCreate2AddressErrorType =\n  | ConcatErrorType\n  | Keccak256ErrorType\n  | GetAddressErrorType\n  | IsBytesErrorType\n  | PadErrorType\n  | SliceErrorType\n  | ToBytesErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nexport function getCreate2Address(opts: GetCreate2AddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {\n    size: 32,\n  })\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in opts) {\n      if (isBytes(opts.bytecodeHash)) return opts.bytecodeHash\n      return toBytes(opts.bytecodeHash)\n    }\n    return keccak256(opts.bytecode, 'bytes')\n  })()\n\n  return getAddress(\n    slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12),\n  )\n}\n"],"mappings":";;;;;AAqCAA,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAYAD,OAAA,CAAAE,gBAAA,GAAAA,gBAAA;AAsBAF,OAAA,CAAAG,iBAAA,GAAAA,iBAAA;AApEA,MAAAC,WAAA,GAAAC,OAAA;AACA,MAAAC,YAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,YAAA,GAAAJ,OAAA;AACA,MAAAK,UAAA,GAAAL,OAAA;AACA,MAAAM,cAAA,GAAAN,OAAA;AAGA,MAAAO,eAAA,GAAAP,OAAA;AAyBA,SAAgBJ,kBAAkBA,CAACY,IAA+B;EAChE,IAAIA,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE,OAAOX,iBAAiB,CAACU,IAAI,CAAC;EAC7D,OAAOX,gBAAgB,CAACW,IAAI,CAAC;AAC/B;AASA,SAAgBX,gBAAgBA,CAACW,IAA6B;EAC5D,MAAME,IAAI,GAAG,IAAAN,YAAA,CAAAO,OAAO,EAAC,IAAAJ,eAAA,CAAAK,UAAU,EAACJ,IAAI,CAACE,IAAI,CAAC,CAAC;EAE3C,IAAIG,KAAK,GAAG,IAAAT,YAAA,CAAAO,OAAO,EAACH,IAAI,CAACK,KAAK,CAAC;EAC/B,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAEA,KAAK,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;EAE9C,OAAO,IAAAP,eAAA,CAAAK,UAAU,EACf,KAAK,IAAAN,cAAA,CAAAS,SAAS,EAAC,IAAAV,UAAA,CAAAW,KAAK,EAAC,CAACN,IAAI,EAAEG,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAACI,KAAK,CAAC,EAAE,CAAC,EAAa,CACrE;AACH;AAaA,SAAgBnB,iBAAiBA,CAACU,IAA8B;EAC9D,MAAME,IAAI,GAAG,IAAAN,YAAA,CAAAO,OAAO,EAAC,IAAAJ,eAAA,CAAAK,UAAU,EAACJ,IAAI,CAACE,IAAI,CAAC,CAAC;EAC3C,MAAMQ,IAAI,GAAG,IAAAhB,QAAA,CAAAiB,GAAG,EAAC,IAAAlB,YAAA,CAAAmB,OAAO,EAACZ,IAAI,CAACU,IAAI,CAAC,GAAGV,IAAI,CAACU,IAAI,GAAG,IAAAd,YAAA,CAAAO,OAAO,EAACH,IAAI,CAACU,IAAI,CAAC,EAAE;IACpEG,IAAI,EAAE;GACP,CAAC;EAEF,MAAMC,YAAY,GAAG,CAAC,MAAK;IACzB,IAAI,cAAc,IAAId,IAAI,EAAE;MAC1B,IAAI,IAAAP,YAAA,CAAAmB,OAAO,EAACZ,IAAI,CAACc,YAAY,CAAC,EAAE,OAAOd,IAAI,CAACc,YAAY;MACxD,OAAO,IAAAlB,YAAA,CAAAO,OAAO,EAACH,IAAI,CAACc,YAAY,CAAC;IACnC;IACA,OAAO,IAAAhB,cAAA,CAAAS,SAAS,EAACP,IAAI,CAACe,QAAQ,EAAE,OAAO,CAAC;EAC1C,CAAC,EAAC,CAAE;EAEJ,OAAO,IAAAhB,eAAA,CAAAK,UAAU,EACf,IAAAT,UAAA,CAAAc,KAAK,EAAC,IAAAX,cAAA,CAAAS,SAAS,EAAC,IAAAhB,WAAA,CAAAyB,MAAM,EAAC,CAAC,IAAApB,YAAA,CAAAO,OAAO,EAAC,MAAM,CAAC,EAAED,IAAI,EAAEQ,IAAI,EAAEI,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAC1E;AACH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}