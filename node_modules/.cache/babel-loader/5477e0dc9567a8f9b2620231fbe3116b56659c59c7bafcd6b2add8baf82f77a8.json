{"ast":null,"code":"import { readContracts } from '../actions/readContracts.js';\nimport { filterQueryOptions } from './utils.js';\nexport function infiniteReadContractsQueryOptions(config, options) {\n  return {\n    ...options.query,\n    async queryFn({\n      pageParam,\n      queryKey\n    }) {\n      const {\n        contracts\n      } = options;\n      const {\n        cacheKey: _,\n        scopeKey: _s,\n        ...parameters\n      } = queryKey[1];\n      return await readContracts(config, {\n        ...parameters,\n        contracts: contracts(pageParam)\n      });\n    },\n    queryKey: infiniteReadContractsQueryKey(options)\n  };\n}\nexport function infiniteReadContractsQueryKey(options) {\n  const {\n    contracts: _,\n    query: _q,\n    ...parameters\n  } = options;\n  return ['infiniteReadContracts', filterQueryOptions(parameters)];\n}","map":{"version":3,"names":["readContracts","filterQueryOptions","infiniteReadContractsQueryOptions","config","options","query","queryFn","pageParam","queryKey","contracts","cacheKey","_","scopeKey","_s","parameters","infiniteReadContractsQueryKey","_q"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/core/src/query/infiniteReadContracts.ts"],"sourcesContent":["import type { ContractFunctionParameters } from 'viem'\nimport {\n  type ReadContractsErrorType,\n  type ReadContractsParameters,\n  type ReadContractsReturnType,\n  readContracts,\n} from '../actions/readContracts.js'\nimport type { Config } from '../createConfig.js'\nimport type {\n  ChainIdParameter,\n  ScopeKeyParameter,\n} from '../types/properties.js'\nimport type { StrictOmit } from '../types/utils.js'\nimport type { InfiniteQueryOptions } from './types.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type InfiniteReadContractsOptions<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n  config extends Config,\n> = {\n  cacheKey: string\n  contracts(\n    pageParam: pageParam,\n  ): ReadContractsParameters<contracts, allowFailure, config>['contracts']\n} & StrictOmit<\n  ReadContractsParameters<contracts, allowFailure, config>,\n  'contracts'\n> &\n  ScopeKeyParameter\n\nexport function infiniteReadContractsQueryOptions<\n  config extends Config,\n  const contracts extends readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  pageParam = unknown,\n>(\n  config: config,\n  options: InfiniteReadContractsOptions<\n    contracts,\n    allowFailure,\n    pageParam,\n    config\n  > &\n    ChainIdParameter<config> &\n    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,\n) {\n  return {\n    ...options.query,\n    async queryFn({ pageParam, queryKey }) {\n      const { contracts } = options\n      const { cacheKey: _, scopeKey: _s, ...parameters } = queryKey[1]\n      return (await readContracts(config, {\n        ...parameters,\n        contracts: contracts(pageParam as any),\n      })) as ReadContractsReturnType<contracts, allowFailure>\n    },\n    queryKey: infiniteReadContractsQueryKey(options),\n  } as const satisfies InfiniteQueryOptions<\n    InfiniteReadContractsQueryFnData<contracts, allowFailure>,\n    ReadContractsErrorType,\n    InfiniteReadContractsData<contracts, allowFailure>,\n    InfiniteReadContractsData<contracts, allowFailure>,\n    InfiniteReadContractsQueryKey<contracts, allowFailure, pageParam, config>,\n    pageParam\n  >\n}\n\ntype RequiredPageParamsParameters<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n> = {\n  query: {\n    initialPageParam: pageParam\n    getNextPageParam(\n      lastPage: InfiniteReadContractsQueryFnData<contracts, allowFailure>,\n      allPages: InfiniteReadContractsQueryFnData<contracts, allowFailure>[],\n      lastPageParam: pageParam,\n      allPageParams: pageParam[],\n    ): pageParam | undefined | null\n  }\n}\n\nexport type InfiniteReadContractsQueryFnData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = ReadContractsReturnType<contracts, allowFailure>\n\nexport type InfiniteReadContractsData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = InfiniteReadContractsQueryFnData<contracts, allowFailure>\n\nexport function infiniteReadContractsQueryKey<\n  config extends Config,\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n>(\n  options: InfiniteReadContractsOptions<\n    contracts,\n    allowFailure,\n    pageParam,\n    config\n  > &\n    ChainIdParameter<config> &\n    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,\n) {\n  const { contracts: _, query: _q, ...parameters } = options\n  return ['infiniteReadContracts', filterQueryOptions(parameters)] as const\n}\n\nexport type InfiniteReadContractsQueryKey<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n  config extends Config,\n> = ReturnType<\n  typeof infiniteReadContractsQueryKey<\n    config,\n    contracts,\n    allowFailure,\n    pageParam\n  >\n>\n"],"mappings":"AACA,SAIEA,aAAa,QACR,6BAA6B;AAQpC,SAASC,kBAAkB,QAAQ,YAAY;AAkB/C,OAAM,SAAUC,iCAAiCA,CAM/CC,MAAc,EACdC,OAOkE;EAElE,OAAO;IACL,GAAGA,OAAO,CAACC,KAAK;IAChB,MAAMC,OAAOA,CAAC;MAAEC,SAAS;MAAEC;IAAQ,CAAE;MACnC,MAAM;QAAEC;MAAS,CAAE,GAAGL,OAAO;MAC7B,MAAM;QAAEM,QAAQ,EAAEC,CAAC;QAAEC,QAAQ,EAAEC,EAAE;QAAE,GAAGC;MAAU,CAAE,GAAGN,QAAQ,CAAC,CAAC,CAAC;MAChE,OAAQ,MAAMR,aAAa,CAACG,MAAM,EAAE;QAClC,GAAGW,UAAU;QACbL,SAAS,EAAEA,SAAS,CAACF,SAAgB;OACtC,CAAC;IACJ,CAAC;IACDC,QAAQ,EAAEO,6BAA6B,CAACX,OAAO;GAQhD;AACH;AA4BA,OAAM,SAAUW,6BAA6BA,CAM3CX,OAOkE;EAElE,MAAM;IAAEK,SAAS,EAAEE,CAAC;IAAEN,KAAK,EAAEW,EAAE;IAAE,GAAGF;EAAU,CAAE,GAAGV,OAAO;EAC1D,OAAO,CAAC,uBAAuB,EAAEH,kBAAkB,CAACa,UAAU,CAAC,CAAU;AAC3E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}