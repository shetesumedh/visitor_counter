{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toBytes = toBytes;\nexports.boolToBytes = boolToBytes;\nexports.hexToBytes = hexToBytes;\nexports.numberToBytes = numberToBytes;\nexports.stringToBytes = stringToBytes;\nconst base_js_1 = require(\"../../errors/base.js\");\nconst isHex_js_1 = require(\"../data/isHex.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nconst encoder = new TextEncoder();\nfunction toBytes(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);\n  if (typeof value === 'boolean') return boolToBytes(value, opts);\n  if ((0, isHex_js_1.isHex)(value)) return hexToBytes(value, opts);\n  return stringToBytes(value, opts);\n}\nfunction boolToBytes(value, opts = {}) {\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(bytes, {\n      size: opts.size\n    });\n  }\n  return bytes;\n}\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\nfunction hexToBytes(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    hex = (0, pad_js_1.pad)(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) hexString = `0${hexString}`;\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new base_js_1.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\nfunction numberToBytes(value, opts) {\n  const hex = (0, toHex_js_1.numberToHex)(value, opts);\n  return hexToBytes(hex);\n}\nfunction stringToBytes(value, opts = {}) {\n  const bytes = encoder.encode(value);\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(bytes, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return bytes;\n}","map":{"version":3,"names":["exports","toBytes","boolToBytes","hexToBytes","numberToBytes","stringToBytes","base_js_1","require","isHex_js_1","pad_js_1","fromHex_js_1","toHex_js_1","encoder","TextEncoder","value","opts","isHex","bytes","Uint8Array","Number","size","assertSize","pad","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","undefined","hex_","hex","dir","hexString","slice","length","index","j","nibbleLeft","charCodeAt","nibbleRight","BaseError","numberToHex","encode"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/encoding/toBytes.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}