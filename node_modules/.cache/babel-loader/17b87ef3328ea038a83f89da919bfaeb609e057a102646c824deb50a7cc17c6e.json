{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBytes = fromBytes;\nexports.bytesToBigInt = bytesToBigInt;\nexports.bytesToBool = bytesToBool;\nexports.bytesToNumber = bytesToNumber;\nexports.bytesToString = bytesToString;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nfunction fromBytes(bytes, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return bytesToNumber(bytes, opts);\n  if (to === 'bigint') return bytesToBigInt(bytes, opts);\n  if (to === 'boolean') return bytesToBool(bytes, opts);\n  if (to === 'string') return bytesToString(bytes, opts);\n  return (0, toHex_js_1.bytesToHex)(bytes, opts);\n}\nfunction bytesToBigInt(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') (0, fromHex_js_1.assertSize)(bytes, {\n    size: opts.size\n  });\n  const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);\n  return (0, fromHex_js_1.hexToBigInt)(hex, opts);\n}\nfunction bytesToBool(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    bytes = (0, trim_js_1.trim)(bytes);\n  }\n  if (bytes.length > 1 || bytes[0] > 1) throw new encoding_js_1.InvalidBytesBooleanError(bytes);\n  return Boolean(bytes[0]);\n}\nfunction bytesToNumber(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') (0, fromHex_js_1.assertSize)(bytes, {\n    size: opts.size\n  });\n  const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);\n  return (0, fromHex_js_1.hexToNumber)(hex, opts);\n}\nfunction bytesToString(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    bytes = (0, trim_js_1.trim)(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}","map":{"version":3,"names":["exports","fromBytes","bytesToBigInt","bytesToBool","bytesToNumber","bytesToString","encoding_js_1","require","trim_js_1","fromHex_js_1","toHex_js_1","bytes","toOrOpts","opts","to","bytesToHex","size","assertSize","hex","hexToBigInt","bytes_","trim","length","InvalidBytesBooleanError","Boolean","hexToNumber","dir","TextDecoder","decode"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/utils/encoding/fromBytes.ts"],"sourcesContent":["import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  assertSize,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | to\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromBytesReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'hex'\n    ? Hex\n    : to extends 'bigint'\n      ? bigint\n      : to extends 'number'\n        ? number\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<to>,\n): FromBytesReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<to>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<to>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}