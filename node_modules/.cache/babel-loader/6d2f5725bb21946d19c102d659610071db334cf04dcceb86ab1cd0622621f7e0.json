{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.equalBytes = equalBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.isHash = isHash;\nexports._validateObject = _validateObject;\nexports.memoized = memoized;\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nvar utils_js_2 = require(\"@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"abytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.abytes;\n  }\n});\nObject.defineProperty(exports, \"anumber\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.anumber;\n  }\n});\nObject.defineProperty(exports, \"bytesToHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"bytesToUtf8\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.bytesToUtf8;\n  }\n});\nObject.defineProperty(exports, \"concatBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.concatBytes;\n  }\n});\nObject.defineProperty(exports, \"hexToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.hexToBytes;\n  }\n});\nObject.defineProperty(exports, \"isBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.isBytes;\n  }\n});\nObject.defineProperty(exports, \"randomBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.randomBytes;\n  }\n});\nObject.defineProperty(exports, \"utf8ToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.utf8ToBytes;\n  }\n});\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nfunction abool(title, value) {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber((0, utils_js_1.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  (0, utils_js_1.abytes)(bytes);\n  return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = (0, utils_js_1.hexToBytes)(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if ((0, utils_js_1.isBytes)(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = n => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = len => new Uint8Array(len); // creates Uint8Array\n  const u8of = byte => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return (0, utils_js_1.concatBytes)(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || (0, utils_js_1.isBytes)(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  function checkField(fieldName, expectedType, isOpt) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n  throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n  const map = new WeakMap();\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}","map":{"version":3,"names":["exports","abool","numberToHexUnpadded","hexToNumber","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","numberToBytesLE","numberToVarBytesBE","ensureBytes","equalBytes","inRange","aInRange","bitLen","bitGet","bitSet","createHmacDrbg","validateObject","isHash","_validateObject","memoized","utils_js_1","require","utils_js_2","Object","defineProperty","enumerable","get","abytes","anumber","bytesToHex","bytesToUtf8","concatBytes","hexToBytes","isBytes","randomBytes","utf8ToBytes","_0n","BigInt","_1n","title","value","Error","num","hex","toString","length","bytes","Uint8Array","from","reverse","n","len","padStart","expectedLength","res","e","a","b","diff","i","isPosBig","min","max","pos","bitMask","hashLen","qByteLen","hmacFn","u8n","u8of","byte","of","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","undefined","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","array","Array","isArray","field","object","Fp","isValid","hash","outputLen","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","entries","fields","optFields","expectedType","isOpt","current","forEach","notImplemented","fn","map","WeakMap","arg","args","computed","set"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/node_modules/@noble/curves/src/utils.ts"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}