{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeTypedData = serializeTypedData;\nexports.validateTypedData = validateTypedData;\nexports.getTypesForEIP712Domain = getTypesForEIP712Domain;\nexports.domainSeparator = domainSeparator;\nconst abi_js_1 = require(\"../errors/abi.js\");\nconst address_js_1 = require(\"../errors/address.js\");\nconst typedData_js_1 = require(\"../errors/typedData.js\");\nconst isAddress_js_1 = require(\"./address/isAddress.js\");\nconst size_js_1 = require(\"./data/size.js\");\nconst toHex_js_1 = require(\"./encoding/toHex.js\");\nconst regex_js_1 = require(\"./regex.js\");\nconst hashTypedData_js_1 = require(\"./signature/hashTypedData.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction serializeTypedData(parameters) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types\n  } = parameters;\n  const normalizeData = (struct, data_) => {\n    const data = {\n      ...data_\n    };\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      if (type === 'address') data[name] = data[name].toLowerCase();\n    }\n    return data;\n  };\n  const domain = (() => {\n    if (!types.EIP712Domain) return {};\n    if (!domain_) return {};\n    return normalizeData(types.EIP712Domain, domain_);\n  })();\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined;\n    return normalizeData(types[primaryType], message_);\n  })();\n  return (0, stringify_js_1.stringify)({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n}\nfunction validateTypedData(parameters) {\n  const {\n    domain,\n    message,\n    primaryType,\n    types\n  } = parameters;\n  const validateData = (struct, data) => {\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      const value = data[name];\n      const integerMatch = type.match(regex_js_1.integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [_type, base, size_] = integerMatch;\n        (0, toHex_js_1.numberToHex)(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value)) throw new address_js_1.InvalidAddressError({\n        address: value\n      });\n      const bytesMatch = type.match(regex_js_1.bytesRegex);\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch;\n        if (size_ && (0, size_js_1.size)(value) !== Number.parseInt(size_)) throw new abi_js_1.BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size_),\n          givenSize: (0, size_js_1.size)(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) {\n        validateReference(type);\n        validateData(struct, value);\n      }\n    }\n  };\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new typedData_js_1.InvalidDomainError({\n      domain\n    });\n    validateData(types.EIP712Domain, domain);\n  }\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message);else throw new typedData_js_1.InvalidPrimaryTypeError({\n      primaryType,\n      types\n    });\n  }\n}\nfunction getTypesForEIP712Domain({\n  domain\n}) {\n  return [typeof domain?.name === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, domain?.version && {\n    name: 'version',\n    type: 'string'\n  }, (typeof domain?.chainId === 'number' || typeof domain?.chainId === 'bigint') && {\n    name: 'chainId',\n    type: 'uint256'\n  }, domain?.verifyingContract && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, domain?.salt && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\nfunction domainSeparator({\n  domain\n}) {\n  return (0, hashTypedData_js_1.hashDomain)({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({\n        domain\n      })\n    }\n  });\n}\nfunction validateReference(type) {\n  if (type === 'address' || type === 'bool' || type === 'string' || type.startsWith('bytes') || type.startsWith('uint') || type.startsWith('int')) throw new typedData_js_1.InvalidStructTypeError({\n    type\n  });\n}","map":{"version":3,"names":["exports","serializeTypedData","validateTypedData","getTypesForEIP712Domain","domainSeparator","abi_js_1","require","address_js_1","typedData_js_1","isAddress_js_1","size_js_1","toHex_js_1","regex_js_1","hashTypedData_js_1","stringify_js_1","parameters","domain","domain_","message","message_","primaryType","types","normalizeData","struct","data_","data","param","name","type","toLowerCase","EIP712Domain","undefined","stringify","validateData","value","integerMatch","match","integerRegex","_type","base","size_","numberToHex","signed","size","Number","parseInt","isAddress","InvalidAddressError","address","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","validateReference","InvalidDomainError","InvalidPrimaryTypeError","version","chainId","verifyingContract","salt","filter","Boolean","hashDomain","startsWith","InvalidStructTypeError"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/typedData.ts"],"sourcesContent":["import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}