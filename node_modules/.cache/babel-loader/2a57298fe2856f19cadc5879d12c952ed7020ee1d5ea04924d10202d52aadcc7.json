{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAbiItem = getAbiItem;\nexports.isArgOfType = isArgOfType;\nexports.getAmbiguousTypes = getAmbiguousTypes;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst isHex_js_1 = require(\"../../utils/data/isHex.js\");\nconst isAddress_js_1 = require(\"../address/isAddress.js\");\nconst toEventSelector_js_1 = require(\"../hash/toEventSelector.js\");\nconst toFunctionSelector_js_1 = require(\"../hash/toFunctionSelector.js\");\nfunction getAbiItem(parameters) {\n  const {\n    abi,\n    args = [],\n    name\n  } = parameters;\n  const isSelector = (0, isHex_js_1.isHex)(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function') return (0, toFunctionSelector_js_1.toFunctionSelector)(abiItem) === name;\n      if (abiItem.type === 'event') return (0, toEventSelector_js_1.toEventSelector)(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) return undefined;\n  if (abiItems.length === 1) return abiItems[0];\n  let matchedAbiItem = undefined;\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes) throw new abi_js_1.AbiItemAmbiguityError({\n          abiItem,\n          type: ambiguousTypes[0]\n        }, {\n          abiItem: matchedAbiItem,\n          type: ambiguousTypes[1]\n        });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  if (matchedAbiItem) return matchedAbiItem;\n  return abiItems[0];\n}\nfunction isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return (0, isAddress_js_1.isAddress)(arg, {\n        strict: false\n      });\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex];\n    const targetParameter = targetParameters[parameterIndex];\n    if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n    const types = [sourceParameter.type, targetParameter.type];\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true;\n      if (types.includes('address') && types.includes('string')) return (0, isAddress_js_1.isAddress)(args[parameterIndex], {\n        strict: false\n      });\n      if (types.includes('address') && types.includes('bytes')) return (0, isAddress_js_1.isAddress)(args[parameterIndex], {\n        strict: false\n      });\n      return false;\n    })();\n    if (ambiguous) return types;\n  }\n  return;\n}","map":{"version":3,"names":["exports","getAbiItem","isArgOfType","getAmbiguousTypes","abi_js_1","require","isHex_js_1","isAddress_js_1","toEventSelector_js_1","toFunctionSelector_js_1","parameters","abi","args","name","isSelector","isHex","strict","abiItems","filter","abiItem","type","toFunctionSelector","toEventSelector","length","undefined","matchedAbiItem","inputs","matched","every","arg","index","abiParameter","ambiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","isAddress","Object","values","components","component","test","Uint8Array","Array","isArray","x","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","ambiguous","includes"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/abi/getAbiItem.ts"],"sourcesContent":["import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}