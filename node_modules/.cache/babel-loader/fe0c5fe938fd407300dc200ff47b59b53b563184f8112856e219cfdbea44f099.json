{"ast":null,"code":"import * as Base64 from './Base64.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as P256 from './P256.js';\nimport * as internal from './internal/webauthn.js';\nexport const createChallenge = Uint8Array.from([105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233]);\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(options) {\n  const {\n    createFn = window.navigator.credentials.create.bind(window.navigator.credentials),\n    ...rest\n  } = options;\n  const creationOptions = getCredentialCreationOptions(rest);\n  try {\n    const credential = await createFn(creationOptions);\n    if (!credential) throw new CredentialCreationFailedError();\n    const response = credential.response;\n    const publicKey = await internal.parseCredentialPublicKey(response);\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential\n    };\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error\n    });\n  }\n}\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(options = {}) {\n  const {\n    flag = 5,\n    rpId = window.location.hostname,\n    signCount = 0\n  } = options;\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId));\n  const flag_bytes = Hex.fromNumber(flag, {\n    size: 1\n  });\n  const signCount_bytes = Hex.fromNumber(signCount, {\n    size: 4\n  });\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes);\n}\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options) {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin\n  } = options;\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, {\n      url: true,\n      pad: false\n    }),\n    origin,\n    crossOrigin,\n    ...extraClientData\n  });\n}\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(options) {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required'\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title\n    },\n    user,\n    extensions\n  } = options;\n  const name = user?.name ?? name_;\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds ? {\n        excludeCredentials: excludeCredentialIds?.map(id => ({\n          id: Base64.toBytes(id),\n          type: 'public-key'\n        }))\n      } : {}),\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: -7 // p256\n      }],\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), {\n          as: 'Bytes'\n        }),\n        name,\n        displayName: user?.displayName ?? name\n      },\n      extensions\n    }\n  };\n}\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(options) {\n  const {\n    credentialId,\n    challenge,\n    rpId = window.location.hostname,\n    userVerification = 'required'\n  } = options;\n  return {\n    publicKey: {\n      ...(credentialId ? {\n        allowCredentials: Array.isArray(credentialId) ? credentialId.map(id => ({\n          id: Base64.toBytes(id),\n          type: 'public-key'\n        })) : [{\n          id: Base64.toBytes(credentialId),\n          type: 'public-key'\n        }]\n      } : {}),\n      challenge: Bytes.fromHex(challenge),\n      rpId,\n      userVerification\n    }\n  };\n}\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(options) {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required'\n  } = options;\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount\n  });\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin\n  });\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON));\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n  const typeIndex = clientDataJSON.indexOf('\"type\"');\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required'\n  };\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash);\n  return {\n    metadata,\n    payload\n  };\n}\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options) {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options;\n  const requestOptions = getCredentialRequestOptions(rest);\n  try {\n    const credential = await getFn(requestOptions);\n    if (!credential) throw new CredentialRequestFailedError();\n    const response = credential.response;\n    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n    const typeIndex = clientDataJSON.indexOf('\"type\"');\n    const signature = internal.parseAsn1Signature(new Uint8Array(response.signature));\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(new Uint8Array(response.authenticatorData)),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired: requestOptions.publicKey.userVerification === 'required'\n      },\n      signature,\n      raw: credential\n    };\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error\n    });\n  }\n}\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options) {\n  const {\n    challenge,\n    hash = true,\n    metadata,\n    publicKey,\n    signature\n  } = options;\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired\n  } = metadata;\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData);\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false;\n  const flag = authenticatorDataBytes[32];\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false;\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false;\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false;\n  // Check that response is for an authentication assertion\n  const type = '\"type\":\"webauthn.get\"';\n  if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1)) return false;\n  // Check that hash is in the clientDataJSON.\n  const match = clientDataJSON.slice(Number(challengeIndex)).match(/^\"challenge\":\"(.*?)\"/);\n  if (!match) return false;\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = match;\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted)) !== challenge) return false;\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes'\n  });\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash);\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature\n  });\n}\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError {\n  constructor({\n    cause\n  } = {}) {\n    super('Failed to create credential.', {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'WebAuthnP256.CredentialCreationFailedError'\n    });\n  }\n}\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError {\n  constructor({\n    cause\n  } = {}) {\n    super('Failed to request credential.', {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'WebAuthnP256.CredentialRequestFailedError'\n    });\n  }\n}","map":{"version":3,"names":["Base64","Bytes","Errors","Hash","Hex","P256","internal","createChallenge","Uint8Array","from","createCredential","options","createFn","window","navigator","credentials","create","bind","rest","creationOptions","getCredentialCreationOptions","credential","CredentialCreationFailedError","response","publicKey","parseCredentialPublicKey","id","raw","error","cause","getAuthenticatorData","flag","rpId","location","hostname","signCount","rpIdHash","sha256","fromString","flag_bytes","fromNumber","size","signCount_bytes","concat","getClientDataJSON","challenge","crossOrigin","extraClientData","origin","JSON","stringify","type","fromHex","url","pad","attestation","authenticatorSelection","residentKey","requireResidentKey","userVerification","excludeCredentialIds","name","name_","rp","document","title","user","extensions","excludeCredentials","map","toBytes","pubKeyCredParams","alg","keccak256","as","displayName","getCredentialRequestOptions","credentialId","allowCredentials","Array","isArray","getSignPayload","authenticatorData","clientDataJSON","clientDataJSONHash","challengeIndex","indexOf","typeIndex","metadata","userVerificationRequired","payload","sign","getFn","get","requestOptions","CredentialRequestFailedError","String","fromCharCode","signature","parseAsn1Signature","fromBytes","verify","hash","authenticatorDataBytes","length","slice","Number","match","_","challenge_extracted","BaseError","constructor","Object","defineProperty"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/node_modules/ox/core/WebAuthnP256.ts"],"sourcesContent":["import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex: number\n  clientDataJSON: string\n  typeIndex: number\n  userVerificationRequired: boolean\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n  } = options\n\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n    extensions,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n      extensions,\n    },\n  } as internal.CredentialCreationOptions\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: Array.isArray(credentialId)\n              ? credentialId.map((id) => ({\n                  id: Base64.toBytes(id),\n                  type: 'public-key',\n                }))\n              : [\n                  {\n                    id: Base64.toBytes(credentialId),\n                    type: 'public-key',\n                  },\n                ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | string[] | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion\n  const type = '\"type\":\"webauthn.get\"'\n  if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n    return false\n\n  // Check that hash is in the clientDataJSON.\n  const match = clientDataJSON\n    .slice(Number(challengeIndex))\n    .match(/^\"challenge\":\"(.*?)\"/)\n  if (!match) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = match\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}