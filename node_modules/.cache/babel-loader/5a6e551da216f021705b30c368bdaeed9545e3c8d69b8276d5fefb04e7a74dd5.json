{"ast":null,"code":"import { ChainNotConfiguredError, ProviderNotFoundError, createConnector, extractRpcUrls } from '@wagmi/core';\nimport { ResourceUnavailableRpcError, SwitchChainError, UserRejectedRequestError, getAddress, hexToNumber, numberToHex, withRetry, withTimeout } from 'viem';\nmetaMask.type = 'metaMask';\nexport function metaMask(parameters = {}) {\n  let sdk;\n  let provider;\n  let providerPromise;\n  let accountsChanged;\n  let chainChanged;\n  let connect;\n  let displayUri;\n  let disconnect;\n  return createConnector(config => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    rdns: ['io.metamask', 'io.metamask.mobile'],\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider();\n      if (provider?.on) {\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          provider.on('connect', connect);\n        }\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n      }\n    },\n    async connect({\n      chainId,\n      isReconnecting\n    } = {}) {\n      const provider = await this.getProvider();\n      if (!displayUri) {\n        displayUri = this.onDisplayUri;\n        provider.on('display_uri', displayUri);\n      }\n      let accounts = [];\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => []);\n      try {\n        let signResponse;\n        let connectWithResponse;\n        if (!accounts?.length) {\n          if (parameters.connectAndSign || parameters.connectWith) {\n            if (parameters.connectAndSign) signResponse = await sdk.connectAndSign({\n              msg: parameters.connectAndSign\n            });else if (parameters.connectWith) connectWithResponse = await sdk.connectWith({\n              method: parameters.connectWith.method,\n              params: parameters.connectWith.params\n            });\n            accounts = await this.getAccounts();\n          } else {\n            const requestedAccounts = await sdk.connect();\n            accounts = requestedAccounts.map(x => getAddress(x));\n          }\n        }\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain({\n            chainId\n          }).catch(error => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return {\n              id: currentChainId\n            };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri);\n          displayUri = undefined;\n        }\n        if (signResponse) provider.emit('connectAndSign', {\n          accounts,\n          chainId: currentChainId,\n          signResponse\n        });else if (connectWithResponse) provider.emit('connectWith', {\n          accounts,\n          chainId: currentChainId,\n          connectWithResponse\n        });\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n        return {\n          accounts,\n          chainId: currentChainId\n        };\n      } catch (err) {\n        const error = err;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        if (error.code === ResourceUnavailableRpcError.code) throw new ResourceUnavailableRpcError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n      await sdk.terminate();\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const chainId = provider.getChainId() || (await provider?.request({\n        method: 'eth_chainId'\n      }));\n      return Number(chainId);\n    },\n    async getProvider() {\n      async function initProvider() {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const MetaMaskSDK = await (async () => {\n          const {\n            default: SDK\n          } = await import('@metamask/sdk');\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function') return SDK.default;\n          return SDK;\n        })();\n        const readonlyRPCMap = {};\n        for (const chain of config.chains) readonlyRPCMap[numberToHex(chain.id)] = extractRpcUrls({\n          chain,\n          transports: config.transports\n        })?.[0];\n        sdk = new MetaMaskSDK({\n          _source: 'wagmi',\n          forceDeleteProvider: false,\n          forceInjectProvider: false,\n          injectProvider: false,\n          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`\n          ...parameters,\n          readonlyRPCMap,\n          dappMetadata: {\n            ...parameters.dappMetadata,\n            // Test if name and url are set AND not empty\n            name: parameters.dappMetadata?.name ? parameters.dappMetadata?.name : 'wagmi',\n            url: parameters.dappMetadata?.url ? parameters.dappMetadata?.url : typeof window !== 'undefined' ? window.location.origin : 'https://wagmi.sh'\n          },\n          useDeeplink: parameters.useDeeplink ?? true\n        });\n        const result = await sdk.init();\n        // On initial load, sometimes `sdk.getProvider` does not return provider.\n        // https://github.com/wevm/wagmi/issues/4367\n        // Use result of `init` call if available.\n        const provider = (() => {\n          if (result?.activeProvider) return result.activeProvider;\n          return sdk.getProvider();\n        })();\n        if (!provider) throw new ProviderNotFoundError();\n        return provider;\n      }\n      if (!provider) {\n        if (!providerPromise) providerPromise = initProvider();\n        provider = await providerPromise;\n      }\n      return provider;\n    },\n    async isAuthorized() {\n      try {\n        // MetaMask mobile provider sometimes fails to immediately resolve\n        // JSON-RPC requests on page load\n        const timeout = 200;\n        const accounts = await withRetry(() => withTimeout(() => this.getAccounts(), {\n          timeout\n        }), {\n          delay: timeout + 1,\n          retryCount: 3\n        });\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({\n      addEthereumChainParameter,\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: numberToHex(chainId)\n          }]\n        });\n        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n        // this callback or an externally emitted `'chainChanged'` event.\n        // https://github.com/MetaMask/metamask-extension/issues/24247\n        await waitForChainIdToSync();\n        await sendAndWaitForChangeEvent(chainId);\n        return chain;\n      } catch (err) {\n        const error = err;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        // Indicates chain is not added to provider\n        if (error.code === 4902 ||\n        // Unwrapping for MetaMask Mobile\n        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n        error?.data?.originalError?.code === 4902) {\n          try {\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [{\n                blockExplorerUrls: (() => {\n                  const {\n                    default: blockExplorer,\n                    ...blockExplorers\n                  } = chain.blockExplorers ?? {};\n                  if (addEthereumChainParameter?.blockExplorerUrls) return addEthereumChainParameter.blockExplorerUrls;\n                  if (blockExplorer) return [blockExplorer.url, ...Object.values(blockExplorers).map(x => x.url)];\n                  return;\n                })(),\n                chainId: numberToHex(chainId),\n                chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                iconUrls: addEthereumChainParameter?.iconUrls,\n                nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n                rpcUrls: (() => {\n                  if (addEthereumChainParameter?.rpcUrls?.length) return addEthereumChainParameter.rpcUrls;\n                  return [chain.rpcUrls.default?.http[0] ?? ''];\n                })()\n              }]\n            });\n            await waitForChainIdToSync();\n            await sendAndWaitForChangeEvent(chainId);\n            return chain;\n          } catch (err) {\n            const error = err;\n            if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n            throw new SwitchChainError(error);\n          }\n        }\n        throw new SwitchChainError(error);\n      }\n      async function waitForChainIdToSync() {\n        // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.\n        // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.\n        await withRetry(async () => {\n          const value = hexToNumber(\n          // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks\n          await provider.request({\n            method: 'eth_chainId'\n          }));\n          // `value` doesn't match expected `chainId`, throw to trigger retry\n          if (value !== chainId) throw new Error('User rejected switch after adding network.');\n          return value;\n        }, {\n          delay: 50,\n          retryCount: 20 // android device encryption is slower\n        });\n      }\n      async function sendAndWaitForChangeEvent(chainId) {\n        await new Promise(resolve => {\n          const listener = data => {\n            if ('chainId' in data && data.chainId === chainId) {\n              config.emitter.off('change', listener);\n              resolve();\n            }\n          };\n          config.emitter.on('change', listener);\n          config.emitter.emit('change', {\n            chainId\n          });\n        });\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) {\n        // ... and using browser extension\n        if (sdk.isExtensionActive()) this.onDisconnect();\n        // FIXME(upstream): Mobile app sometimes emits invalid `accountsChanged` event with empty accounts array\n        else return;\n      }\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString();\n        this.onConnect({\n          chainId\n        });\n      }\n      // Regular change event\n      else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts();\n      if (accounts.length === 0) return;\n      const chainId = Number(connectInfo.chainId);\n      config.emitter.emit('connect', {\n        accounts,\n        chainId\n      });\n      const provider = await this.getProvider();\n      if (connect) {\n        provider.removeListener('connect', connect);\n        connect = undefined;\n      }\n      if (!accountsChanged) {\n        accountsChanged = this.onAccountsChanged.bind(this);\n        provider.on('accountsChanged', accountsChanged);\n      }\n      if (!chainChanged) {\n        chainChanged = this.onChainChanged.bind(this);\n        provider.on('chainChanged', chainChanged);\n      }\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this);\n        provider.on('disconnect', disconnect);\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider();\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && error.code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return;\n      }\n      config.emitter.emit('disconnect');\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    }\n  }));\n}","map":{"version":3,"names":["ChainNotConfiguredError","ProviderNotFoundError","createConnector","extractRpcUrls","ResourceUnavailableRpcError","SwitchChainError","UserRejectedRequestError","getAddress","hexToNumber","numberToHex","withRetry","withTimeout","metaMask","type","parameters","sdk","provider","providerPromise","accountsChanged","chainChanged","connect","displayUri","disconnect","config","id","name","rdns","setup","getProvider","on","onConnect","bind","onAccountsChanged","chainId","isReconnecting","onDisplayUri","accounts","getAccounts","catch","signResponse","connectWithResponse","length","connectAndSign","connectWith","msg","method","params","requestedAccounts","map","x","currentChainId","getChainId","chain","switchChain","error","code","removeListener","undefined","emit","onChainChanged","onDisconnect","err","terminate","request","Number","initProvider","MetaMaskSDK","default","SDK","readonlyRPCMap","chains","transports","_source","forceDeleteProvider","forceInjectProvider","injectProvider","dappMetadata","url","window","location","origin","useDeeplink","result","init","activeProvider","isAuthorized","timeout","delay","retryCount","addEthereumChainParameter","find","waitForChainIdToSync","sendAndWaitForChangeEvent","data","originalError","blockExplorerUrls","blockExplorer","blockExplorers","Object","values","chainName","iconUrls","nativeCurrency","rpcUrls","http","value","Error","Promise","resolve","listener","emitter","off","isExtensionActive","listenerCount","toString","connectInfo","uri"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/connectors/src/metaMask.ts"],"sourcesContent":["import type {\n  MetaMaskSDK,\n  MetaMaskSDKOptions,\n  RPC_URLS_MAP,\n  SDKProvider,\n} from '@metamask/sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  ProviderNotFoundError,\n  createConnector,\n  extractRpcUrls,\n} from '@wagmi/core'\nimport type {\n  Compute,\n  ExactPartial,\n  OneOf,\n  RemoveUndefined,\n  UnionCompute,\n} from '@wagmi/core/internal'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  type Hex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  hexToNumber,\n  numberToHex,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nexport type MetaMaskParameters = UnionCompute<\n  WagmiMetaMaskSDKOptions &\n    OneOf<\n      | {\n          /* Shortcut to connect and sign a message */\n          connectAndSign?: string | undefined\n        }\n      | {\n          // TODO: Strongly type `method` and `params`\n          /* Allow `connectWith` any rpc method */\n          connectWith?: { method: string; params: unknown[] } | undefined\n        }\n    >\n>\n\ntype WagmiMetaMaskSDKOptions = Compute<\n  ExactPartial<\n    Omit<\n      MetaMaskSDKOptions,\n      | '_source'\n      | 'forceDeleteProvider'\n      | 'forceInjectProvider'\n      | 'injectProvider'\n      | 'useDeeplink'\n      | 'readonlyRPCMap'\n    >\n  > & {\n    /** @deprecated */\n    forceDeleteProvider?: MetaMaskSDKOptions['forceDeleteProvider']\n    /** @deprecated */\n    forceInjectProvider?: MetaMaskSDKOptions['forceInjectProvider']\n    /** @deprecated */\n    injectProvider?: MetaMaskSDKOptions['injectProvider']\n    /** @deprecated */\n    useDeeplink?: MetaMaskSDKOptions['useDeeplink']\n  }\n>\n\nmetaMask.type = 'metaMask' as const\nexport function metaMask(parameters: MetaMaskParameters = {}) {\n  type Provider = SDKProvider\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n  }\n  type Listener = Parameters<Provider['on']>[1]\n\n  let sdk: MetaMaskSDK\n  let provider: Provider | undefined\n  let providerPromise: Promise<typeof provider>\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let connect: Connector['onConnect'] | undefined\n  let displayUri: ((uri: string) => void) | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    rdns: ['io.metamask', 'io.metamask.mobile'],\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider()\n      if (provider?.on) {\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect as Listener)\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged as Listener)\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider()\n      if (!displayUri) {\n        displayUri = this.onDisplayUri\n        provider.on('display_uri', displayUri as Listener)\n      }\n\n      let accounts: readonly Address[] = []\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])\n\n      try {\n        let signResponse: string | undefined\n        let connectWithResponse: unknown | undefined\n        if (!accounts?.length) {\n          if (parameters.connectAndSign || parameters.connectWith) {\n            if (parameters.connectAndSign)\n              signResponse = await sdk.connectAndSign({\n                msg: parameters.connectAndSign,\n              })\n            else if (parameters.connectWith)\n              connectWithResponse = await sdk.connectWith({\n                method: parameters.connectWith.method,\n                params: parameters.connectWith.params,\n              })\n\n            accounts = await this.getAccounts()\n          } else {\n            const requestedAccounts = (await sdk.connect()) as string[]\n            accounts = requestedAccounts.map((x) => getAddress(x))\n          }\n        }\n        // Switch to chain if provided\n        let currentChainId = (await this.getChainId()) as number\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri)\n          displayUri = undefined\n        }\n\n        if (signResponse)\n          provider.emit('connectAndSign', {\n            accounts,\n            chainId: currentChainId,\n            signResponse,\n          })\n        else if (connectWithResponse)\n          provider.emit('connectWith', {\n            accounts,\n            chainId: currentChainId,\n            connectWithResponse,\n          })\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged as Listener)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged as Listener)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect as Listener)\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect as Listener)\n      }\n\n      await sdk.terminate()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[]\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId =\n        provider.getChainId() ||\n        (await provider?.request({ method: 'eth_chainId' }))\n      return Number(chainId)\n    },\n    async getProvider() {\n      async function initProvider() {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const MetaMaskSDK = await (async () => {\n          const { default: SDK } = await import('@metamask/sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        const readonlyRPCMap: RPC_URLS_MAP = {}\n        for (const chain of config.chains)\n          readonlyRPCMap[numberToHex(chain.id)] = extractRpcUrls({\n            chain,\n            transports: config.transports,\n          })?.[0]\n\n        sdk = new MetaMaskSDK({\n          _source: 'wagmi',\n          forceDeleteProvider: false,\n          forceInjectProvider: false,\n          injectProvider: false,\n          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`\n          ...(parameters as RemoveUndefined<typeof parameters>),\n          readonlyRPCMap,\n          dappMetadata: {\n            ...parameters.dappMetadata,\n            // Test if name and url are set AND not empty\n            name: parameters.dappMetadata?.name\n              ? parameters.dappMetadata?.name\n              : 'wagmi',\n            url: parameters.dappMetadata?.url\n              ? parameters.dappMetadata?.url\n              : typeof window !== 'undefined'\n                ? window.location.origin\n                : 'https://wagmi.sh',\n          },\n          useDeeplink: parameters.useDeeplink ?? true,\n        })\n        const result = await sdk.init()\n        // On initial load, sometimes `sdk.getProvider` does not return provider.\n        // https://github.com/wevm/wagmi/issues/4367\n        // Use result of `init` call if available.\n        const provider = (() => {\n          if (result?.activeProvider) return result.activeProvider\n          return sdk.getProvider()\n        })()\n        if (!provider) throw new ProviderNotFoundError()\n        return provider\n      }\n\n      if (!provider) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider = await providerPromise\n      }\n      return provider!\n    },\n    async isAuthorized() {\n      try {\n        // MetaMask mobile provider sometimes fails to immediately resolve\n        // JSON-RPC requests on page load\n        const timeout = 200\n        const accounts = await withRetry(\n          () => withTimeout(() => this.getAccounts(), { timeout }),\n          {\n            delay: timeout + 1,\n            retryCount: 3,\n          },\n        )\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n\n        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n        // this callback or an externally emitted `'chainChanged'` event.\n        // https://github.com/MetaMask/metamask-extension/issues/24247\n        await waitForChainIdToSync()\n        await sendAndWaitForChangeEvent(chainId)\n\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [\n                {\n                  blockExplorerUrls: (() => {\n                    const { default: blockExplorer, ...blockExplorers } =\n                      chain.blockExplorers ?? {}\n                    if (addEthereumChainParameter?.blockExplorerUrls)\n                      return addEthereumChainParameter.blockExplorerUrls\n                    if (blockExplorer)\n                      return [\n                        blockExplorer.url,\n                        ...Object.values(blockExplorers).map((x) => x.url),\n                      ]\n                    return\n                  })(),\n                  chainId: numberToHex(chainId),\n                  chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                  iconUrls: addEthereumChainParameter?.iconUrls,\n                  nativeCurrency:\n                    addEthereumChainParameter?.nativeCurrency ??\n                    chain.nativeCurrency,\n                  rpcUrls: (() => {\n                    if (addEthereumChainParameter?.rpcUrls?.length)\n                      return addEthereumChainParameter.rpcUrls\n                    return [chain.rpcUrls.default?.http[0] ?? '']\n                  })(),\n                } satisfies AddEthereumChainParameter,\n              ],\n            })\n\n            await waitForChainIdToSync()\n            await sendAndWaitForChangeEvent(chainId)\n\n            return chain\n          } catch (err) {\n            const error = err as RpcError\n            if (error.code === UserRejectedRequestError.code)\n              throw new UserRejectedRequestError(error)\n            throw new SwitchChainError(error)\n          }\n        }\n\n        throw new SwitchChainError(error)\n      }\n\n      async function waitForChainIdToSync() {\n        // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.\n        // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.\n        await withRetry(\n          async () => {\n            const value = hexToNumber(\n              // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks\n              (await provider.request({ method: 'eth_chainId' })) as Hex,\n            )\n            // `value` doesn't match expected `chainId`, throw to trigger retry\n            if (value !== chainId)\n              throw new Error('User rejected switch after adding network.')\n            return value\n          },\n          {\n            delay: 50,\n            retryCount: 20, // android device encryption is slower\n          },\n        )\n      }\n\n      async function sendAndWaitForChangeEvent(chainId: number) {\n        await new Promise<void>((resolve) => {\n          const listener = ((data) => {\n            if ('chainId' in data && data.chainId === chainId) {\n              config.emitter.off('change', listener)\n              resolve()\n            }\n          }) satisfies Parameters<typeof config.emitter.on>[1]\n          config.emitter.on('change', listener)\n          config.emitter.emit('change', { chainId })\n        })\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) {\n        // ... and using browser extension\n        if (sdk.isExtensionActive()) this.onDisconnect()\n        // FIXME(upstream): Mobile app sometimes emits invalid `accountsChanged` event with empty accounts array\n        else return\n      }\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      const provider = await this.getProvider()\n      if (connect) {\n        provider.removeListener('connect', connect)\n        connect = undefined\n      }\n      if (!accountsChanged) {\n        accountsChanged = this.onAccountsChanged.bind(this)\n        provider.on('accountsChanged', accountsChanged as Listener)\n      }\n      if (!chainChanged) {\n        chainChanged = this.onChainChanged.bind(this)\n        provider.on('chainChanged', chainChanged as Listener)\n      }\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this)\n        provider.on('disconnect', disconnect as Listener)\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      config.emitter.emit('disconnect')\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect as Listener)\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}