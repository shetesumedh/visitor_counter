{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEnsResolver = getEnsResolver;\nconst getChainContractAddress_js_1 = require(\"../../utils/chain/getChainContractAddress.js\");\nconst toHex_js_1 = require(\"../../utils/encoding/toHex.js\");\nconst packetToBytes_js_1 = require(\"../../utils/ens/packetToBytes.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst readContract_js_1 = require(\"../public/readContract.js\");\nasync function getEnsResolver(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    name\n  } = parameters;\n  const {\n    chain\n  } = client;\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress) return parameters.universalResolverAddress;\n    if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    return (0, getChainContractAddress_js_1.getChainContractAddress)({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver'\n    });\n  })();\n  const tlds = chain?.ensTlds;\n  if (tlds && !tlds.some(tld => name.endsWith(tld))) throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`);\n  const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({\n    address: universalResolverAddress,\n    abi: [{\n      inputs: [{\n        type: 'bytes'\n      }],\n      name: 'findResolver',\n      outputs: [{\n        type: 'address'\n      }, {\n        type: 'bytes32'\n      }],\n      stateMutability: 'view',\n      type: 'function'\n    }],\n    functionName: 'findResolver',\n    args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],\n    blockNumber,\n    blockTag\n  });\n  return resolverAddress;\n}","map":{"version":3,"names":["exports","getEnsResolver","getChainContractAddress_js_1","require","toHex_js_1","packetToBytes_js_1","getAction_js_1","readContract_js_1","client","parameters","blockNumber","blockTag","name","chain","universalResolverAddress","Error","getChainContractAddress","contract","tlds","ensTlds","some","tld","endsWith","join","id","resolverAddress","getAction","readContract","address","abi","inputs","type","outputs","stateMutability","functionName","args","toHex","packetToBytes"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/actions/ens/getEnsResolver.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\nexport type GetEnsResolverErrorType =\n  | GetChainContractAddressErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsResolverParameters,\n): Promise<GetEnsResolverReturnType> {\n  const { blockNumber, blockTag, name } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n    throw new Error(\n      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`,\n    )\n\n  const [resolverAddress] = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [{ type: 'address' }, { type: 'bytes32' }],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n"],"mappings":";;;;;AAmEAA,OAAA,CAAAC,cAAA,GAAAA,cAAA;AA5DA,MAAAC,4BAAA,GAAAC,OAAA;AAIA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,kBAAA,GAAAF,OAAA;AAIA,MAAAG,cAAA,GAAAH,OAAA;AACA,MAAAI,iBAAA,GAAAJ,OAAA;AAkDO,eAAeF,cAAcA,CAClCO,MAAgC,EAChCC,UAAoC;EAEpC,MAAM;IAAEC,WAAW;IAAEC,QAAQ;IAAEC;EAAI,CAAE,GAAGH,UAAU;EAClD,MAAM;IAAEI;EAAK,CAAE,GAAGL,MAAM;EAExB,MAAMM,wBAAwB,GAAG,CAAC,MAAK;IACrC,IAAIL,UAAU,CAACK,wBAAwB,EACrC,OAAOL,UAAU,CAACK,wBAAwB;IAC5C,IAAI,CAACD,KAAK,EACR,MAAM,IAAIE,KAAK,CACb,oEAAoE,CACrE;IACH,OAAO,IAAAb,4BAAA,CAAAc,uBAAuB,EAAC;MAC7BN,WAAW;MACXG,KAAK;MACLI,QAAQ,EAAE;KACX,CAAC;EACJ,CAAC,EAAC,CAAE;EAEJ,MAAMC,IAAI,GAAGL,KAAK,EAAEM,OAAO;EAC3B,IAAID,IAAI,IAAI,CAACA,IAAI,CAACE,IAAI,CAAEC,GAAG,IAAKT,IAAI,CAACU,QAAQ,CAACD,GAAG,CAAC,CAAC,EACjD,MAAM,IAAIN,KAAK,CACb,GAAGH,IAAI,4BAA4BM,IAAI,EAAEK,IAAI,CAAC,IAAI,CAAC,gBAAgBV,KAAK,CAACD,IAAI,UAAUC,KAAK,CAACW,EAAE,IAAI,CACpG;EAEH,MAAM,CAACC,eAAe,CAAC,GAAG,MAAM,IAAAnB,cAAA,CAAAoB,SAAS,EACvClB,MAAM,EACND,iBAAA,CAAAoB,YAAY,EACZ,cAAc,CACf,CAAC;IACAC,OAAO,EAAEd,wBAAwB;IACjCe,GAAG,EAAE,CACH;MACEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAE,CAAC;MAC3BnB,IAAI,EAAE,cAAc;MACpBoB,OAAO,EAAE,CAAC;QAAED,IAAI,EAAE;MAAS,CAAE,EAAE;QAAEA,IAAI,EAAE;MAAS,CAAE,CAAC;MACnDE,eAAe,EAAE,MAAM;MACvBF,IAAI,EAAE;KACP,CACF;IACDG,YAAY,EAAE,cAAc;IAC5BC,IAAI,EAAE,CAAC,IAAA/B,UAAA,CAAAgC,KAAK,EAAC,IAAA/B,kBAAA,CAAAgC,aAAa,EAACzB,IAAI,CAAC,CAAC,CAAC;IAClCF,WAAW;IACXC;GACD,CAAC;EACF,OAAOc,eAAe;AACxB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}