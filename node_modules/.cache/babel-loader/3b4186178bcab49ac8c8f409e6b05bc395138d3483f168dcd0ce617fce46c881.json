{"ast":null,"code":"import { serializeSignature } from '../../../accounts/index.js';\nimport { encodePacked } from '../../../utils/abi/encodePacked.js';\nimport { isHex } from '../../../utils/data/isHex.js';\nimport { size } from '../../../utils/data/size.js';\nimport { bytesToHex, stringToHex } from '../../../utils/encoding/toHex.js';\nimport { encodeType, hashStruct } from '../../../utils/signature/hashTypedData.js';\nimport { getTypesForEIP712Domain } from '../../../utils/typedData.js';\n/**\n * Wraps a typed data signature for ERC-7739.\n *\n * @example\n * ```ts\n * const signature = wrapTypedDataSignature({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n *   signature: '0x...',\n * })\n * ```\n */\nexport function wrapTypedDataSignature(parameters) {\n  const {\n    domain,\n    message,\n    primaryType,\n    signature,\n    types\n  } = parameters;\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return serializeSignature(signature);\n    return bytesToHex(signature);\n  })();\n  // Compute dependencies for wrapped signature.\n  const hashedDomain = hashStruct({\n    data: domain ?? {},\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({\n        domain\n      })\n    },\n    primaryType: 'EIP712Domain'\n  });\n  const hashedContents = hashStruct({\n    data: message,\n    types: types,\n    primaryType\n  });\n  const encodedType = encodeType({\n    primaryType,\n    types: types\n  });\n  // Construct wrapped signature.\n  return encodePacked(['bytes', 'bytes32', 'bytes32', 'bytes', 'uint16'], [signatureHex, hashedDomain, hashedContents, stringToHex(encodedType), size(stringToHex(encodedType))]);\n}","map":{"version":3,"names":["serializeSignature","encodePacked","isHex","size","bytesToHex","stringToHex","encodeType","hashStruct","getTypesForEIP712Domain","wrapTypedDataSignature","parameters","domain","message","primaryType","signature","types","signatureHex","hashedDomain","data","EIP712Domain","hashedContents","encodedType"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/experimental/erc7739/utils/wrapTypedDataSignature.ts"],"sourcesContent":["import type { TypedData } from 'abitype'\nimport { serializeSignature } from '../../../accounts/index.js'\nimport type { ByteArray, Hex, Signature } from '../../../types/misc.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport { encodePacked } from '../../../utils/abi/encodePacked.js'\nimport { type IsHexErrorType, isHex } from '../../../utils/data/isHex.js'\nimport { size } from '../../../utils/data/size.js'\nimport { bytesToHex, stringToHex } from '../../../utils/encoding/toHex.js'\nimport {\n  encodeType,\n  hashStruct,\n} from '../../../utils/signature/hashTypedData.js'\nimport { getTypesForEIP712Domain } from '../../../utils/typedData.js'\n\nexport type WrapTypedDataSignatureParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = TypedDataDefinition<typedData, primaryType, primaryTypes> & {\n  signature: Hex | ByteArray | Signature\n}\n\nexport type WrapTypedDataSignatureReturnType = Hex\n\nexport type WrapTypedDataSignatureErrorType = IsHexErrorType\n\n/**\n * Wraps a typed data signature for ERC-7739.\n *\n * @example\n * ```ts\n * const signature = wrapTypedDataSignature({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n *   signature: '0x...',\n * })\n * ```\n */\nexport function wrapTypedDataSignature(\n  parameters: WrapTypedDataSignatureParameters,\n): WrapTypedDataSignatureReturnType {\n  const { domain, message, primaryType, signature, types } = parameters\n\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  // Compute dependencies for wrapped signature.\n  const hashedDomain = hashStruct({\n    data: domain ?? {},\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n    primaryType: 'EIP712Domain',\n  })\n  const hashedContents = hashStruct({\n    data: message,\n    types: types as any,\n    primaryType,\n  })\n  const encodedType = encodeType({\n    primaryType,\n    types: types as any,\n  })\n\n  // Construct wrapped signature.\n  return encodePacked(\n    ['bytes', 'bytes32', 'bytes32', 'bytes', 'uint16'],\n    [\n      signatureHex,\n      hashedDomain,\n      hashedContents,\n      stringToHex(encodedType),\n      size(stringToHex(encodedType)),\n    ],\n  )\n}\n"],"mappings":"AACA,SAASA,kBAAkB,QAAQ,4BAA4B;AAG/D,SAASC,YAAY,QAAQ,oCAAoC;AACjE,SAA8BC,KAAK,QAAQ,8BAA8B;AACzE,SAASC,IAAI,QAAQ,6BAA6B;AAClD,SAASC,UAAU,EAAEC,WAAW,QAAQ,kCAAkC;AAC1E,SACEC,UAAU,EACVC,UAAU,QACL,2CAA2C;AAClD,SAASC,uBAAuB,QAAQ,6BAA6B;AAerE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,OAAM,SAAUC,sBAAsBA,CACpCC,UAA4C;EAE5C,MAAM;IAAEC,MAAM;IAAEC,OAAO;IAAEC,WAAW;IAAEC,SAAS;IAAEC;EAAK,CAAE,GAAGL,UAAU;EAErE,MAAMM,YAAY,GAAG,CAAC,MAAK;IACzB,IAAId,KAAK,CAACY,SAAS,CAAC,EAAE,OAAOA,SAAS;IACtC,IAAI,OAAOA,SAAS,KAAK,QAAQ,IAAI,GAAG,IAAIA,SAAS,IAAI,GAAG,IAAIA,SAAS,EACvE,OAAOd,kBAAkB,CAACc,SAAS,CAAC;IACtC,OAAOV,UAAU,CAACU,SAAS,CAAC;EAC9B,CAAC,EAAC,CAAE;EAEJ;EACA,MAAMG,YAAY,GAAGV,UAAU,CAAC;IAC9BW,IAAI,EAAEP,MAAM,IAAI,EAAE;IAClBI,KAAK,EAAE;MACLI,YAAY,EAAEX,uBAAuB,CAAC;QAAEG;MAAM,CAAE;KACjD;IACDE,WAAW,EAAE;GACd,CAAC;EACF,MAAMO,cAAc,GAAGb,UAAU,CAAC;IAChCW,IAAI,EAAEN,OAAO;IACbG,KAAK,EAAEA,KAAY;IACnBF;GACD,CAAC;EACF,MAAMQ,WAAW,GAAGf,UAAU,CAAC;IAC7BO,WAAW;IACXE,KAAK,EAAEA;GACR,CAAC;EAEF;EACA,OAAOd,YAAY,CACjB,CAAC,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,CAAC,EAClD,CACEe,YAAY,EACZC,YAAY,EACZG,cAAc,EACdf,WAAW,CAACgB,WAAW,CAAC,EACxBlB,IAAI,CAACE,WAAW,CAACgB,WAAW,CAAC,CAAC,CAC/B,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}