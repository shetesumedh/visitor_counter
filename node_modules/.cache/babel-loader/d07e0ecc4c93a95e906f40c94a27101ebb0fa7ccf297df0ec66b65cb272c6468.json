{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeAbiParameters = encodeAbiParameters;\nexports.getArrayComponents = getArrayComponents;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst address_js_1 = require(\"../../errors/address.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst isAddress_js_1 = require(\"../address/isAddress.js\");\nconst concat_js_1 = require(\"../data/concat.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst slice_js_1 = require(\"../data/slice.js\");\nconst toHex_js_1 = require(\"../encoding/toHex.js\");\nconst regex_js_1 = require(\"../regex.js\");\nfunction encodeAbiParameters(params, values) {\n  if (params.length !== values.length) throw new abi_js_1.AbiEncodingLengthMismatchError({\n    expectedLength: params.length,\n    givenLength: values.length\n  });\n  const preparedParams = prepareParams({\n    params: params,\n    values: values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) return '0x';\n  return data;\n}\nfunction prepareParams({\n  params,\n  values\n}) {\n  const preparedParams = [];\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({\n      param: params[i],\n      value: values[i]\n    }));\n  }\n  return preparedParams;\n}\nfunction prepareParam({\n  param,\n  value\n}) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      length,\n      param: {\n        ...param,\n        type\n      }\n    });\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value, {\n      param: param\n    });\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int');\n    const [,, size = '256'] = regex_js_1.integerRegex.exec(param.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      param\n    });\n  }\n  if (param.type === 'string') {\n    return encodeString(value);\n  }\n  throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters'\n  });\n}\nfunction encodeParams(preparedParams) {\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) staticSize += 32;else staticSize += (0, size_js_1.size)(encoded);\n  }\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParams.push(encoded);\n      dynamicSize += (0, size_js_1.size)(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n  if (!(0, isAddress_js_1.isAddress)(value)) throw new address_js_1.InvalidAddressError({\n    address: value\n  });\n  return {\n    dynamic: false,\n    encoded: (0, pad_js_1.padHex)(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, {\n  length,\n  param\n}) {\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new abi_js_1.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new abi_js_1.AbiEncodingArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${param.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({\n      param,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length = (0, toHex_js_1.numberToHex)(preparedParams.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length, data]) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: (0, concat_js_1.concat)(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction encodeBytes(value, {\n  param\n}) {\n  const [, paramSize] = param.type.split('bytes');\n  const bytesSize = (0, size_js_1.size)(value);\n  if (!paramSize) {\n    let value_ = value;\n    if (bytesSize % 32 !== 0) value_ = (0, pad_js_1.padHex)(value_, {\n      dir: 'right',\n      size: Math.ceil((value.length - 2) / 2 / 32) * 32\n    });\n    return {\n      dynamic: true,\n      encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, {\n        size: 32\n      })), value_])\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) throw new abi_js_1.AbiEncodingBytesSizeMismatchError({\n    expectedSize: Number.parseInt(paramSize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: (0, pad_js_1.padHex)(value, {\n      dir: 'right'\n    })\n  };\n}\nfunction encodeBool(value) {\n  if (typeof value !== 'boolean') throw new base_js_1.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value))\n  };\n}\nfunction encodeNumber(value, {\n  signed,\n  size = 256\n}) {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new encoding_js_1.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: (0, toHex_js_1.numberToHex)(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = (0, toHex_js_1.stringToHex)(value);\n  const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {\n      dir: 'right'\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), {\n      size: 32\n    })), ...parts])\n  };\n}\nfunction encodeTuple(value, {\n  param\n}) {\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}","map":{"version":3,"names":["exports","encodeAbiParameters","getArrayComponents","abi_js_1","require","address_js_1","base_js_1","encoding_js_1","isAddress_js_1","concat_js_1","pad_js_1","size_js_1","slice_js_1","toHex_js_1","regex_js_1","params","values","length","AbiEncodingLengthMismatchError","expectedLength","givenLength","preparedParams","prepareParams","data","encodeParams","i","push","prepareParam","param","value","arrayComponents","type","encodeArray","encodeTuple","encodeAddress","encodeBool","startsWith","signed","size","integerRegex","exec","encodeNumber","Number","encodeBytes","encodeString","InvalidAbiEncodingTypeError","docsPath","staticSize","dynamic","encoded","staticParams","dynamicParams","dynamicSize","numberToHex","concat","isAddress","InvalidAddressError","address","padHex","toLowerCase","Array","isArray","InvalidArrayError","AbiEncodingArrayLengthMismatchError","dynamicChild","preparedParam","map","paramSize","split","bytesSize","value_","dir","Math","ceil","parseInt","AbiEncodingBytesSizeMismatchError","expectedSize","BaseError","boolToHex","max","BigInt","min","IntegerOutOfRangeError","toString","hexValue","stringToHex","partsLength","parts","slice","components","param_","index","name","matches","match","undefined"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/abi/encodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}