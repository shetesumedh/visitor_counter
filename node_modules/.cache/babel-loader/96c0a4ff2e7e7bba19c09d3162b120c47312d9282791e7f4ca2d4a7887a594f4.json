{"ast":null,"code":"import { createStore as createMipd } from 'mipd';\nimport { createClient } from 'viem';\nimport { persist, subscribeWithSelector } from 'zustand/middleware';\nimport { createStore } from 'zustand/vanilla';\nimport { injected } from './connectors/injected.js';\nimport { createEmitter } from './createEmitter.js';\nimport { createStorage, getDefaultStorage } from './createStorage.js';\nimport { ChainNotConfiguredError } from './errors/config.js';\nimport { uid } from './utils/uid.js';\nimport { version } from './version.js';\nexport function createConfig(parameters) {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: getDefaultStorage()\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters;\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  const mipd = typeof window !== 'undefined' && multiInjectedProviderDiscovery ? createMipd() : undefined;\n  const chains = createStore(() => rest.chains);\n  const connectors = createStore(() => {\n    const collection = [];\n    const rdnsSet = new Set();\n    for (const connectorFns of rest.connectors ?? []) {\n      const connector = setup(connectorFns);\n      collection.push(connector);\n      if (!ssr && connector.rdns) {\n        const rdnsValues = typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns;\n        for (const rdns of rdnsValues) {\n          rdnsSet.add(rdns);\n        }\n      }\n    }\n    if (!ssr && mipd) {\n      const providers = mipd.getProviders();\n      for (const provider of providers) {\n        if (rdnsSet.has(provider.info.rdns)) continue;\n        collection.push(setup(providerDetailToConnector(provider)));\n      }\n    }\n    return collection;\n  });\n  function setup(connectorFn) {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter(uid());\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports\n      }),\n      emitter,\n      uid: emitter.uid\n    };\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect);\n    connector.setup?.();\n    return connector;\n  }\n  function providerDetailToConnector(providerDetail) {\n    const {\n      info\n    } = providerDetail;\n    const provider = providerDetail.provider;\n    return injected({\n      target: {\n        ...info,\n        id: info.rdns,\n        provider\n      }\n    });\n  }\n  const clients = new Map();\n  function getClient(config = {}) {\n    const chainId = config.chainId ?? store.getState().chainId;\n    const chain = chains.getState().find(x => x.id === chainId);\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError();\n    {\n      const client = clients.get(store.getState().chainId);\n      if (client && !chain) return client;\n      if (!chain) throw new ChainNotConfiguredError();\n    }\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId);\n      if (client) return client;\n    }\n    let client;\n    if (rest.client) client = rest.client({\n      chain\n    });else {\n      const chainId = chain.id;\n      const chainIds = chains.getState().map(x => x.id);\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties = {};\n      const entries = Object.entries(rest);\n      for (const [key, value] of entries) {\n        if (key === 'chains' || key === 'client' || key === 'connectors' || key === 'transports') continue;\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId];else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some(x => x in value);\n            if (hasChainSpecificValue) continue;\n            properties[key] = value;\n          }\n        } else properties[key] = value;\n      }\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? {\n          multicall: true\n        },\n        transport: parameters => rest.transports[chainId]({\n          ...parameters,\n          connectors\n        })\n      });\n    }\n    clients.set(chainId, client);\n    return client;\n  }\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function getInitialState() {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map(),\n      current: null,\n      status: 'disconnected'\n    };\n  }\n  let currentVersion;\n  const prefix = '0.0.0-canary-';\n  if (version.startsWith(prefix)) currentVersion = Number.parseInt(version.replace(prefix, ''));\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0');\n  const store = createStore(subscribeWithSelector(\n  // only use persist middleware if storage exists\n  storage ? persist(getInitialState, {\n    migrate(persistedState, version) {\n      if (version === currentVersion) return persistedState;\n      const initialState = getInitialState();\n      const chainId = validatePersistedChainId(persistedState, initialState.chainId);\n      return {\n        ...initialState,\n        chainId\n      };\n    },\n    name: 'store',\n    partialize(state) {\n      // Only persist \"critical\" store properties to preserve storage size.\n      return {\n        connections: {\n          __type: 'Map',\n          value: Array.from(state.connections.entries()).map(([key, connection]) => {\n            const {\n              id,\n              name,\n              type,\n              uid\n            } = connection.connector;\n            const connector = {\n              id,\n              name,\n              type,\n              uid\n            };\n            return [key, {\n              ...connection,\n              connector\n            }];\n          })\n        },\n        chainId: state.chainId,\n        current: state.current\n      };\n    },\n    merge(persistedState, currentState) {\n      // `status` should not be persisted as it messes with reconnection\n      if (typeof persistedState === 'object' && persistedState && 'status' in persistedState) delete persistedState.status;\n      // Make sure persisted `chainId` is valid\n      const chainId = validatePersistedChainId(persistedState, currentState.chainId);\n      return {\n        ...currentState,\n        ...persistedState,\n        chainId\n      };\n    },\n    skipHydration: ssr,\n    storage: storage,\n    version: currentVersion\n  }) : getInitialState));\n  store.setState(getInitialState());\n  function validatePersistedChainId(persistedState, defaultChainId) {\n    return persistedState && typeof persistedState === 'object' && 'chainId' in persistedState && typeof persistedState.chainId === 'number' && chains.getState().some(x => x.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;\n  }\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Update default chain when connector chain changes\n  if (syncConnectedChain) store.subscribe(({\n    connections,\n    current\n  }) => current ? connections.get(current)?.chainId : undefined, chainId => {\n    // If chain is not configured, then don't switch over to it.\n    const isChainConfigured = chains.getState().some(x => x.id === chainId);\n    if (!isChainConfigured) return;\n    return store.setState(x => ({\n      ...x,\n      chainId: chainId ?? x.chainId\n    }));\n  });\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe(providerDetails => {\n    const connectorIdSet = new Set();\n    const connectorRdnsSet = new Set();\n    for (const connector of connectors.getState()) {\n      connectorIdSet.add(connector.id);\n      if (connector.rdns) {\n        const rdnsValues = typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns;\n        for (const rdns of rdnsValues) {\n          connectorRdnsSet.add(rdns);\n        }\n      }\n    }\n    const newConnectors = [];\n    for (const providerDetail of providerDetails) {\n      if (connectorRdnsSet.has(providerDetail.info.rdns)) continue;\n      const connector = setup(providerDetailToConnector(providerDetail));\n      if (connectorIdSet.has(connector.id)) continue;\n      newConnectors.push(connector);\n    }\n    if (storage && !store.persist.hasHydrated()) return;\n    connectors.setState(x => [...x, ...newConnectors], true);\n  });\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function change(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (!connection) return x;\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts ?? connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector\n        })\n      };\n    });\n  }\n  function connect(data) {\n    // Disable handling if reconnecting/connecting\n    if (store.getState().status === 'connecting' || store.getState().status === 'reconnecting') return;\n    store.setState(x => {\n      const connector = connectors.getState().find(x => x.uid === data.uid);\n      if (!connector) return x;\n      if (connector.emitter.listenerCount('connect')) connector.emitter.off('connect', change);\n      if (!connector.emitter.listenerCount('change')) connector.emitter.on('change', change);\n      if (!connector.emitter.listenerCount('disconnect')) connector.emitter.on('disconnect', disconnect);\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts,\n          chainId: data.chainId,\n          connector: connector\n        }),\n        current: data.uid,\n        status: 'connected'\n      };\n    });\n  }\n  function disconnect(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (connection) {\n        const connector = connection.connector;\n        if (connector.emitter.listenerCount('change')) connection.connector.emitter.off('change', change);\n        if (connector.emitter.listenerCount('disconnect')) connection.connector.emitter.off('disconnect', disconnect);\n        if (!connector.emitter.listenerCount('connect')) connection.connector.emitter.on('connect', connect);\n      }\n      x.connections.delete(data.uid);\n      if (x.connections.size === 0) return {\n        ...x,\n        connections: new Map(),\n        current: null,\n        status: 'disconnected'\n      };\n      const nextConnection = x.connections.values().next().value;\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid\n      };\n    });\n  }\n  return {\n    get chains() {\n      return chains.getState();\n    },\n    get connectors() {\n      return connectors.getState();\n    },\n    storage,\n    getClient,\n    get state() {\n      return store.getState();\n    },\n    setState(value) {\n      let newState;\n      if (typeof value === 'function') newState = value(store.getState());else newState = value;\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState();\n      if (typeof newState !== 'object') newState = initialState;\n      const isCorrupt = Object.keys(initialState).some(x => !(x in newState));\n      if (isCorrupt) newState = initialState;\n      store.setState(newState, true);\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(selector, listener, options ? {\n        ...options,\n        fireImmediately: options.emitImmediately\n        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n      } : undefined);\n    },\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports,\n      chains: {\n        setState(value) {\n          const nextChains = typeof value === 'function' ? value(chains.getState()) : value;\n          if (nextChains.length === 0) return;\n          return chains.setState(nextChains, true);\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener);\n        }\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup: setup,\n        setState(value) {\n          return connectors.setState(typeof value === 'function' ? value(connectors.getState()) : value, true);\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener);\n        }\n      },\n      events: {\n        change,\n        connect,\n        disconnect\n      }\n    }\n  };\n}","map":{"version":3,"names":["createStore","createMipd","createClient","persist","subscribeWithSelector","injected","createEmitter","createStorage","getDefaultStorage","ChainNotConfiguredError","uid","version","createConfig","parameters","multiInjectedProviderDiscovery","storage","syncConnectedChain","ssr","rest","mipd","window","undefined","chains","connectors","collection","rdnsSet","Set","connectorFns","connector","setup","push","rdns","rdnsValues","add","providers","getProviders","provider","has","info","providerDetailToConnector","connectorFn","emitter","getState","transports","on","connect","providerDetail","target","id","clients","Map","getClient","config","chainId","store","chain","find","x","client","get","chainIds","map","properties","entries","Object","key","value","hasChainSpecificValue","some","batch","multicall","transport","set","getInitialState","connections","current","status","currentVersion","prefix","startsWith","Number","parseInt","replace","split","migrate","persistedState","initialState","validatePersistedChainId","name","partialize","state","__type","Array","from","connection","type","merge","currentState","skipHydration","setState","defaultChainId","subscribe","isChainConfigured","providerDetails","connectorIdSet","connectorRdnsSet","newConnectors","hasHydrated","change","data","accounts","listenerCount","off","disconnect","delete","size","nextConnection","values","next","newState","isCorrupt","keys","selector","listener","options","fireImmediately","emitImmediately","_internal","Boolean","nextChains","length","events"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/core/src/createConfig.ts"],"sourcesContent":["import {\n  type EIP6963ProviderDetail,\n  type Store as MipdStore,\n  createStore as createMipd,\n} from 'mipd'\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  type EIP1193RequestFn,\n  createClient,\n  type ClientConfig as viem_ClientConfig,\n  type Transport as viem_Transport,\n} from 'viem'\nimport { persist, subscribeWithSelector } from 'zustand/middleware'\nimport { type Mutate, type StoreApi, createStore } from 'zustand/vanilla'\n\nimport type {\n  ConnectorEventMap,\n  CreateConnectorFn,\n} from './connectors/createConnector.js'\nimport { injected } from './connectors/injected.js'\nimport { type Emitter, type EventData, createEmitter } from './createEmitter.js'\nimport {\n  type Storage,\n  createStorage,\n  getDefaultStorage,\n} from './createStorage.js'\nimport { ChainNotConfiguredError } from './errors/config.js'\nimport type {\n  Compute,\n  ExactPartial,\n  LooseOmit,\n  OneOf,\n  RemoveUndefined,\n} from './types/utils.js'\nimport { uid } from './utils/uid.js'\nimport { version } from './version.js'\n\nexport function createConfig<\n  const chains extends readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport>,\n  const connectorFns extends readonly CreateConnectorFn[],\n>(\n  parameters: CreateConfigParameters<chains, transports, connectorFns>,\n): Config<chains, transports, connectorFns> {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: getDefaultStorage(),\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  const mipd =\n    typeof window !== 'undefined' && multiInjectedProviderDiscovery\n      ? createMipd()\n      : undefined\n\n  const chains = createStore(() => rest.chains)\n  const connectors = createStore(() => {\n    const collection = []\n    const rdnsSet = new Set<string>()\n    for (const connectorFns of rest.connectors ?? []) {\n      const connector = setup(connectorFns)\n      collection.push(connector)\n      if (!ssr && connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          rdnsSet.add(rdns)\n        }\n      }\n    }\n    if (!ssr && mipd) {\n      const providers = mipd.getProviders()\n      for (const provider of providers) {\n        if (rdnsSet.has(provider.info.rdns)) continue\n        collection.push(setup(providerDetailToConnector(provider)))\n      }\n    }\n    return collection\n  })\n  function setup(connectorFn: CreateConnectorFn): Connector {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter<ConnectorEventMap>(uid())\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports,\n      }),\n      emitter,\n      uid: emitter.uid,\n    }\n\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect)\n    connector.setup?.()\n\n    return connector\n  }\n  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n    const { info } = providerDetail\n    const provider = providerDetail.provider as any\n    return injected({ target: { ...info, id: info.rdns, provider } })\n  }\n\n  const clients = new Map<number, Client<Transport, chains[number]>>()\n  function getClient<chainId extends chains[number]['id']>(\n    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},\n  ): Client<Transport, Extract<chains[number], { id: chainId }>> {\n    const chainId = config.chainId ?? store.getState().chainId\n    const chain = chains.getState().find((x) => x.id === chainId)\n\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError()\n\n    // If the target chain is not configured, use the client of the current chain.\n    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>\n    {\n      const client = clients.get(store.getState().chainId)\n      if (client && !chain) return client as Return\n      if (!chain) throw new ChainNotConfiguredError()\n    }\n\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId)\n      if (client) return client as Return\n    }\n\n    let client: Client<Transport, chains[number]>\n    if (rest.client) client = rest.client({ chain })\n    else {\n      const chainId = chain.id as chains[number]['id']\n      const chainIds = chains.getState().map((x) => x.id)\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties: Partial<viem_ClientConfig> = {}\n      const entries = Object.entries(rest) as [keyof typeof rest, any][]\n\n      for (const [key, value] of entries) {\n        if (\n          key === 'chains' ||\n          key === 'client' ||\n          key === 'connectors' ||\n          key === 'transports'\n        )\n          continue\n\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId]\n          else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some((x) => x in value)\n            if (hasChainSpecificValue) continue\n            properties[key] = value\n          }\n        } else properties[key] = value\n      }\n\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? { multicall: true },\n        transport: (parameters) =>\n          rest.transports[chainId]({ ...parameters, connectors }),\n      })\n    }\n\n    clients.set(chainId, client)\n    return client as Return\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function getInitialState(): State {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map<string, Connection>(),\n      current: null,\n      status: 'disconnected',\n    }\n  }\n\n  let currentVersion: number\n  const prefix = '0.0.0-canary-'\n  if (version.startsWith(prefix))\n    currentVersion = Number.parseInt(version.replace(prefix, ''))\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0')\n\n  const store = createStore(\n    subscribeWithSelector(\n      // only use persist middleware if storage exists\n      storage\n        ? persist(getInitialState, {\n            migrate(persistedState, version) {\n              if (version === currentVersion) return persistedState as State\n\n              const initialState = getInitialState()\n              const chainId = validatePersistedChainId(\n                persistedState,\n                initialState.chainId,\n              )\n              return { ...initialState, chainId }\n            },\n            name: 'store',\n            partialize(state) {\n              // Only persist \"critical\" store properties to preserve storage size.\n              return {\n                connections: {\n                  __type: 'Map',\n                  value: Array.from(state.connections.entries()).map(\n                    ([key, connection]) => {\n                      const { id, name, type, uid } = connection.connector\n                      const connector = { id, name, type, uid }\n                      return [key, { ...connection, connector }]\n                    },\n                  ),\n                } as unknown as PartializedState['connections'],\n                chainId: state.chainId,\n                current: state.current,\n              } satisfies PartializedState\n            },\n            merge(persistedState, currentState) {\n              // `status` should not be persisted as it messes with reconnection\n              if (\n                typeof persistedState === 'object' &&\n                persistedState &&\n                'status' in persistedState\n              )\n                delete persistedState.status\n              // Make sure persisted `chainId` is valid\n              const chainId = validatePersistedChainId(\n                persistedState,\n                currentState.chainId,\n              )\n              return {\n                ...currentState,\n                ...(persistedState as object),\n                chainId,\n              }\n            },\n            skipHydration: ssr,\n            storage: storage as Storage<Record<string, unknown>>,\n            version: currentVersion,\n          })\n        : getInitialState,\n    ),\n  )\n  store.setState(getInitialState())\n\n  function validatePersistedChainId(\n    persistedState: unknown,\n    defaultChainId: number,\n  ) {\n    return persistedState &&\n      typeof persistedState === 'object' &&\n      'chainId' in persistedState &&\n      typeof persistedState.chainId === 'number' &&\n      chains.getState().some((x) => x.id === persistedState.chainId)\n      ? persistedState.chainId\n      : defaultChainId\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Update default chain when connector chain changes\n  if (syncConnectedChain)\n    store.subscribe(\n      ({ connections, current }) =>\n        current ? connections.get(current)?.chainId : undefined,\n      (chainId) => {\n        // If chain is not configured, then don't switch over to it.\n        const isChainConfigured = chains\n          .getState()\n          .some((x) => x.id === chainId)\n        if (!isChainConfigured) return\n\n        return store.setState((x) => ({\n          ...x,\n          chainId: chainId ?? x.chainId,\n        }))\n      },\n    )\n\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe((providerDetails) => {\n    const connectorIdSet = new Set<string>()\n    const connectorRdnsSet = new Set<string>()\n    for (const connector of connectors.getState()) {\n      connectorIdSet.add(connector.id)\n      if (connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          connectorRdnsSet.add(rdns)\n        }\n      }\n    }\n\n    const newConnectors: Connector[] = []\n    for (const providerDetail of providerDetails) {\n      if (connectorRdnsSet.has(providerDetail.info.rdns)) continue\n      const connector = setup(providerDetailToConnector(providerDetail))\n      if (connectorIdSet.has(connector.id)) continue\n      newConnectors.push(connector)\n    }\n\n    if (storage && !store.persist.hasHydrated()) return\n    connectors.setState((x) => [...x, ...newConnectors], true)\n  })\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function change(data: EventData<ConnectorEventMap, 'change'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (!connection) return x\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts:\n            (data.accounts as readonly [Address, ...Address[]]) ??\n            connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector,\n        }),\n      }\n    })\n  }\n  function connect(data: EventData<ConnectorEventMap, 'connect'>) {\n    // Disable handling if reconnecting/connecting\n    if (\n      store.getState().status === 'connecting' ||\n      store.getState().status === 'reconnecting'\n    )\n      return\n\n    store.setState((x) => {\n      const connector = connectors.getState().find((x) => x.uid === data.uid)\n      if (!connector) return x\n\n      if (connector.emitter.listenerCount('connect'))\n        connector.emitter.off('connect', change)\n      if (!connector.emitter.listenerCount('change'))\n        connector.emitter.on('change', change)\n      if (!connector.emitter.listenerCount('disconnect'))\n        connector.emitter.on('disconnect', disconnect)\n\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts as readonly [Address, ...Address[]],\n          chainId: data.chainId,\n          connector: connector,\n        }),\n        current: data.uid,\n        status: 'connected',\n      }\n    })\n  }\n  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (connection) {\n        const connector = connection.connector\n        if (connector.emitter.listenerCount('change'))\n          connection.connector.emitter.off('change', change)\n        if (connector.emitter.listenerCount('disconnect'))\n          connection.connector.emitter.off('disconnect', disconnect)\n        if (!connector.emitter.listenerCount('connect'))\n          connection.connector.emitter.on('connect', connect)\n      }\n\n      x.connections.delete(data.uid)\n\n      if (x.connections.size === 0)\n        return {\n          ...x,\n          connections: new Map(),\n          current: null,\n          status: 'disconnected',\n        }\n\n      const nextConnection = x.connections.values().next().value as Connection\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid,\n      }\n    })\n  }\n\n  return {\n    get chains() {\n      return chains.getState() as chains\n    },\n    get connectors() {\n      return connectors.getState() as Connector<connectorFns[number]>[]\n    },\n    storage,\n\n    getClient,\n    get state() {\n      return store.getState() as unknown as State<chains>\n    },\n    setState(value) {\n      let newState: State\n      if (typeof value === 'function') newState = value(store.getState() as any)\n      else newState = value\n\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState()\n      if (typeof newState !== 'object') newState = initialState\n      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))\n      if (isCorrupt) newState = initialState\n\n      store.setState(newState, true)\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(\n        selector as unknown as (state: State) => any,\n        listener,\n        options\n          ? ({\n              ...options,\n              fireImmediately: options.emitImmediately,\n              // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n            } as RemoveUndefined<typeof options>)\n          : undefined,\n      )\n    },\n\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports as transports,\n      chains: {\n        setState(value) {\n          const nextChains = (\n            typeof value === 'function' ? value(chains.getState()) : value\n          ) as chains\n          if (nextChains.length === 0) return\n          return chains.setState(nextChains, true)\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener)\n        },\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup: setup as <connectorFn extends CreateConnectorFn>(\n          connectorFn: connectorFn,\n        ) => Connector<connectorFn>,\n        setState(value) {\n          return connectors.setState(\n            typeof value === 'function' ? value(connectors.getState()) : value,\n            true,\n          )\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener)\n        },\n      },\n      events: { change, connect, disconnect },\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type CreateConfigParameters<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = Compute<\n  {\n    chains: chains\n    connectors?: connectorFns | undefined\n    multiInjectedProviderDiscovery?: boolean | undefined\n    storage?: Storage | null | undefined\n    ssr?: boolean | undefined\n    syncConnectedChain?: boolean | undefined\n  } & OneOf<\n    | ({ transports: transports } & {\n        [key in keyof ClientConfig]?:\n          | ClientConfig[key]\n          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }\n          | undefined\n      })\n    | {\n        client(parameters: { chain: chains[number] }): Client<\n          transports[chains[number]['id']],\n          chains[number]\n        >\n      }\n  >\n>\n\nexport type Config<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = {\n  readonly chains: chains\n  readonly connectors: readonly Connector<connectorFns[number]>[]\n  readonly storage: Storage | null\n\n  readonly state: State<chains>\n  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(\n    value: State<tchains> | ((state: State<tchains>) => State<tchains>),\n  ): void\n  subscribe<state>(\n    selector: (state: State<chains>) => state,\n    listener: (state: state, previousState: state) => void,\n    options?:\n      | {\n          emitImmediately?: boolean | undefined\n          equalityFn?: ((a: state, b: state) => boolean) | undefined\n        }\n      | undefined,\n  ): () => void\n\n  getClient<chainId extends chains[number]['id']>(parameters?: {\n    chainId?: chainId | chains[number]['id'] | undefined\n  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>\n\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @internal\n   */\n  _internal: Internal<chains, transports>\n}\n\ntype Internal<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly mipd: MipdStore | undefined\n  readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>\n  readonly ssr: boolean\n  readonly syncConnectedChain: boolean\n  readonly transports: transports\n\n  chains: {\n    setState(\n      value:\n        | readonly [Chain, ...Chain[]]\n        | ((\n            state: readonly [Chain, ...Chain[]],\n          ) => readonly [Chain, ...Chain[]]),\n    ): void\n    subscribe(\n      listener: (\n        state: readonly [Chain, ...Chain[]],\n        prevState: readonly [Chain, ...Chain[]],\n      ) => void,\n    ): () => void\n  }\n  connectors: {\n    providerDetailToConnector(\n      providerDetail: EIP6963ProviderDetail,\n    ): CreateConnectorFn\n    setup<connectorFn extends CreateConnectorFn>(\n      connectorFn: connectorFn,\n    ): Connector<connectorFn>\n    setState(value: Connector[] | ((state: Connector[]) => Connector[])): void\n    subscribe(\n      listener: (state: Connector[], prevState: Connector[]) => void,\n    ): () => void\n  }\n  events: {\n    change(data: EventData<ConnectorEventMap, 'change'>): void\n    connect(data: EventData<ConnectorEventMap, 'connect'>): void\n    disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void\n  }\n}\n\nexport type State<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n> = {\n  chainId: chains[number]['id']\n  connections: Map<string, Connection>\n  current: string | null\n  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'\n}\n\nexport type PartializedState = Compute<\n  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>\n>\n\nexport type Connection = {\n  accounts: readonly [Address, ...Address[]]\n  chainId: number\n  connector: Connector\n}\n\nexport type Connector<\n  createConnectorFn extends CreateConnectorFn = CreateConnectorFn,\n> = ReturnType<createConnectorFn> & {\n  emitter: Emitter<ConnectorEventMap>\n  uid: string\n}\n\nexport type Transport<\n  type extends string = string,\n  rpcAttributes = Record<string, any>,\n  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = (\n  params: Parameters<\n    viem_Transport<type, rpcAttributes, eip1193RequestFn>\n  >[0] & {\n    connectors?: StoreApi<Connector[]> | undefined\n  },\n) => ReturnType<viem_Transport<type, rpcAttributes, eip1193RequestFn>>\n\ntype ClientConfig = LooseOmit<\n  viem_ClientConfig,\n  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'\n>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}