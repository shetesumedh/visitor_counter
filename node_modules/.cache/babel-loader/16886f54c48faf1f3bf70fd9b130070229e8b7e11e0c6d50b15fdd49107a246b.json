{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanupCache = exports.listenersCache = void 0;\nexports.observe = observe;\nexports.listenersCache = new Map();\nexports.cleanupCache = new Map();\nlet callbackCount = 0;\nfunction observe(observerId, callbacks, fn) {\n  const callbackId = ++callbackCount;\n  const getListeners = () => exports.listenersCache.get(observerId) || [];\n  const unsubscribe = () => {\n    const listeners = getListeners();\n    exports.listenersCache.set(observerId, listeners.filter(cb => cb.id !== callbackId));\n  };\n  const unwatch = () => {\n    const listeners = getListeners();\n    if (!listeners.some(cb => cb.id === callbackId)) return;\n    const cleanup = exports.cleanupCache.get(observerId);\n    if (listeners.length === 1 && cleanup) {\n      const p = cleanup();\n      if (p instanceof Promise) p.catch(() => {});\n    }\n    unsubscribe();\n  };\n  const listeners = getListeners();\n  exports.listenersCache.set(observerId, [...listeners, {\n    id: callbackId,\n    fns: callbacks\n  }]);\n  if (listeners && listeners.length > 0) return unwatch;\n  const emit = {};\n  for (const key in callbacks) {\n    emit[key] = (...args) => {\n      const listeners = getListeners();\n      if (listeners.length === 0) return;\n      for (const listener of listeners) listener.fns[key]?.(...args);\n    };\n  }\n  const cleanup = fn(emit);\n  if (typeof cleanup === 'function') exports.cleanupCache.set(observerId, cleanup);\n  return unwatch;\n}","map":{"version":3,"names":["exports","observe","listenersCache","Map","cleanupCache","callbackCount","observerId","callbacks","fn","callbackId","getListeners","get","unsubscribe","listeners","set","filter","cb","id","unwatch","some","cleanup","length","p","Promise","catch","fns","emit","key","args","listener"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/observe.ts"],"sourcesContent":["import type { ErrorType } from '../errors/utils.js'\nimport type { MaybePromise } from '../types/utils.js'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport type ObserveErrorType = ErrorType\n\n/** @internal */\nexport const listenersCache = /*#__PURE__*/ new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/ new Map<\n  string,\n  () => void | Promise<void>\n>()\n\ntype EmitFunction<callbacks extends Callbacks> = (\n  emit: callbacks,\n) => MaybePromise<void | (() => void) | (() => Promise<void>)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<callbacks extends Callbacks>(\n  observerId: string,\n  callbacks: callbacks,\n  fn: EmitFunction<callbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const listeners = getListeners()\n    if (!listeners.some((cb: any) => cb.id === callbackId)) return\n    const cleanup = cleanupCache.get(observerId)\n    if (listeners.length === 1 && cleanup) {\n      const p = cleanup()\n      if (p instanceof Promise) p.catch(() => {})\n    }\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  const emit: callbacks = {} as callbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<callbacks[keyof callbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      for (const listener of listeners) listener.fns[key]?.(...args)\n    }) as callbacks[Extract<keyof callbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n"],"mappings":";;;;;;AA8BAA,OAAA,CAAAC,OAAA,GAAAA,OAAA;AArBaD,OAAA,CAAAE,cAAc,GAAiB,IAAIC,GAAG,EAGhD;AAEUH,OAAA,CAAAI,YAAY,GAAiB,IAAID,GAAG,EAG9C;AAMH,IAAIE,aAAa,GAAG,CAAC;AAOrB,SAAgBJ,OAAOA,CACrBK,UAAkB,EAClBC,SAAoB,EACpBC,EAA2B;EAE3B,MAAMC,UAAU,GAAG,EAAEJ,aAAa;EAElC,MAAMK,YAAY,GAAGA,CAAA,KAAMV,OAAA,CAAAE,cAAc,CAACS,GAAG,CAACL,UAAU,CAAC,IAAI,EAAE;EAE/D,MAAMM,WAAW,GAAGA,CAAA,KAAK;IACvB,MAAMC,SAAS,GAAGH,YAAY,EAAE;IAChCV,OAAA,CAAAE,cAAc,CAACY,GAAG,CAChBR,UAAU,EACVO,SAAS,CAACE,MAAM,CAAEC,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,CACpD;EACH,CAAC;EAED,MAAMS,OAAO,GAAGA,CAAA,KAAK;IACnB,MAAML,SAAS,GAAGH,YAAY,EAAE;IAChC,IAAI,CAACG,SAAS,CAACM,IAAI,CAAEH,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,EAAE;IACxD,MAAMW,OAAO,GAAGpB,OAAA,CAAAI,YAAY,CAACO,GAAG,CAACL,UAAU,CAAC;IAC5C,IAAIO,SAAS,CAACQ,MAAM,KAAK,CAAC,IAAID,OAAO,EAAE;MACrC,MAAME,CAAC,GAAGF,OAAO,EAAE;MACnB,IAAIE,CAAC,YAAYC,OAAO,EAAED,CAAC,CAACE,KAAK,CAAC,MAAK,CAAE,CAAC,CAAC;IAC7C;IACAZ,WAAW,EAAE;EACf,CAAC;EAED,MAAMC,SAAS,GAAGH,YAAY,EAAE;EAChCV,OAAA,CAAAE,cAAc,CAACY,GAAG,CAACR,UAAU,EAAE,CAC7B,GAAGO,SAAS,EACZ;IAAEI,EAAE,EAAER,UAAU;IAAEgB,GAAG,EAAElB;EAAS,CAAE,CACnC,CAAC;EAEF,IAAIM,SAAS,IAAIA,SAAS,CAACQ,MAAM,GAAG,CAAC,EAAE,OAAOH,OAAO;EAErD,MAAMQ,IAAI,GAAc,EAAe;EACvC,KAAK,MAAMC,GAAG,IAAIpB,SAAS,EAAE;IAC3BmB,IAAI,CAACC,GAAG,CAAC,GAAI,CACX,GAAGC,IAAyD,KAC1D;MACF,MAAMf,SAAS,GAAGH,YAAY,EAAE;MAChC,IAAIG,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MAC5B,KAAK,MAAMQ,QAAQ,IAAIhB,SAAS,EAAEgB,QAAQ,CAACJ,GAAG,CAACE,GAAG,CAAC,GAAG,GAAGC,IAAI,CAAC;IAChE,CAAiD;EACnD;EAEA,MAAMR,OAAO,GAAGZ,EAAE,CAACkB,IAAI,CAAC;EACxB,IAAI,OAAON,OAAO,KAAK,UAAU,EAAEpB,OAAA,CAAAI,YAAY,CAACU,GAAG,CAACR,UAAU,EAAEc,OAAO,CAAC;EAExE,OAAOF,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}