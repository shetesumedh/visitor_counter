{"ast":null,"code":"import * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Authorization from './Authorization.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js';\nexport const serializedType = '0x04';\nexport const type = 'eip7702';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    authorizationList\n  } = envelope;\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const {\n        address,\n        chainId\n      } = authorization;\n      if (address) Address.assert(address, {\n        strict: false\n      });\n      if (Number(chainId) < 0) throw new TransactionEnvelope.InvalidChainIdError({\n        chainId\n      });\n    }\n  }\n  TransactionEnvelopeEip1559.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s] = transactionArray;\n  if (!(transactionArray.length === 10 || transactionArray.length === 13)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      authorizationList,\n      ...(transactionArray.length > 9 ? {\n        yParity,\n        r,\n        s\n      } : {})\n    },\n    serialized,\n    type\n  });\n  let transaction = {\n    chainId: Number(chainId),\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce) && nonce !== '0x') transaction.nonce = BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = BigInt(maxFeePerGas);\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = AccessList.fromTupleList(accessList);\n  if (authorizationList !== '0x') transaction.authorizationList = Authorization.fromTupleList(authorizationList);\n  const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n  if (signature) transaction = {\n    ...transaction,\n    ...signature\n  };\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip7702'\n  };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize({\n    ...envelope,\n    ...(presign ? {\n      r: undefined,\n      s: undefined,\n      yParity: undefined\n    } : {})\n  }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n    input\n  } = envelope;\n  assert(envelope);\n  const accessTupleList = AccessList.toTupleList(accessList);\n  const authorizationTupleList = Authorization.toTupleList(authorizationList);\n  const signature = Signature.extract(options.signature || envelope);\n  const serialized = [Hex.fromNumber(chainId), nonce ? Hex.fromNumber(nonce) : '0x', maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x', maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x', gas ? Hex.fromNumber(gas) : '0x', to ?? '0x', value ? Hex.fromNumber(value) : '0x', data ?? input ?? '0x', accessTupleList, authorizationTupleList, ...(signature ? Signature.toTuple(signature) : [])];\n  return Hex.concat(serializedType, Rlp.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch {\n    return false;\n  }\n}","map":{"version":3,"names":["AccessList","Address","Authorization","Hash","Hex","Rlp","Signature","TransactionEnvelope","TransactionEnvelopeEip1559","serializedType","type","assert","envelope","authorizationList","authorization","address","chainId","strict","Number","InvalidChainIdError","deserialize","serialized","transactionArray","toHex","slice","nonce","maxPriorityFeePerGas","maxFeePerGas","gas","to","value","data","accessList","yParity","r","s","length","InvalidSerializedError","attributes","transaction","validate","BigInt","fromTupleList","signature","fromTuple","undefined","from","options","envelope_","getSignPayload","hash","presign","keccak256","serialize","input","accessTupleList","toTupleList","authorizationTupleList","extract","fromNumber","toTuple","concat","fromHex"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/TransactionEnvelopeEip7702.ts"],"sourcesContent":["import type { Assign } from './internal/types.js'\n\nimport type { PartialBy, UnionPartialBy } from './internal/types.js'\n\nimport * as AccessList from './AccessList.js'\nimport * as Address from './Address.js'\nimport * as Authorization from './Authorization.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TransactionEnvelope.js'\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js'\nimport type { Compute } from './internal/types.js'\n\nexport type TransactionEnvelopeEip7702<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** EIP-7702 Authorization List. */\n    authorizationList: Authorization.ListSigned<bigintType, numberType>\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TransactionEnvelopeEip7702<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x4'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport type Signed = TransactionEnvelopeEip7702<true>\n\nexport const serializedType = '0x04' as const\nexport type SerializedType = typeof serializedType\n\nexport const type = 'eip7702' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(\n  envelope: PartialBy<TransactionEnvelopeEip7702, 'type'>,\n) {\n  const { authorizationList } = envelope\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { address, chainId } = authorization\n      if (address) Address.assert(address, { strict: false })\n      if (Number(chainId) < 0)\n        throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n    }\n  }\n  TransactionEnvelopeEip1559.assert(\n    envelope as {} as TransactionEnvelopeEip1559.TransactionEnvelopeEip1559,\n  )\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): Compute<TransactionEnvelopeEip7702> {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    authorizationList,\n    yParity,\n    r,\n    s,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  if (!(transactionArray.length === 10 || transactionArray.length === 13))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        authorizationList,\n        ...(transactionArray.length > 9\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId),\n    type,\n  } as TransactionEnvelopeEip7702\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce) && nonce !== '0x') transaction.nonce = BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (accessList!.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as never)\n  if (authorizationList !== '0x')\n    transaction.authorizationList = Authorization.fromTupleList(\n      authorizationList as never,\n    )\n\n  const signature =\n    r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TransactionEnvelopeEip7702\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nexport function from<\n  const envelope extends\n    | UnionPartialBy<TransactionEnvelopeEip7702, 'type'>\n    | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope:\n    | envelope\n    | UnionPartialBy<TransactionEnvelopeEip7702, 'type'>\n    | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TransactionEnvelopeEip7702\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip7702',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends\n      | UnionPartialBy<TransactionEnvelopeEip7702, 'type'>\n      | Hex.Hex = TransactionEnvelopeEip7702 | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TransactionEnvelopeEip7702\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip7702'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TransactionEnvelopeEip7702,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TransactionEnvelopeEip7702<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TransactionEnvelopeEip7702, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n    input,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n  const authorizationTupleList = Authorization.toTupleList(authorizationList)\n\n  const signature = Signature.extract(options.signature || envelope)\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n    accessTupleList,\n    authorizationTupleList,\n    ...(signature ? Signature.toTuple(signature) : []),\n  ]\n\n  return Hex.concat(serializedType, Rlp.fromHex(serialized)) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(\n  envelope: PartialBy<TransactionEnvelopeEip7702, 'type'>,\n) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}