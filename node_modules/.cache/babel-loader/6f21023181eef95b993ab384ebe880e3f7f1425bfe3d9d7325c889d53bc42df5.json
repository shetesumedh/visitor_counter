{"ast":null,"code":"import { reconnect } from './actions/reconnect.js';\nexport function hydrate(config, parameters) {\n  const {\n    initialState,\n    reconnectOnMount\n  } = parameters;\n  if (initialState && !config._internal.store.persist.hasHydrated()) config.setState({\n    ...initialState,\n    chainId: config.chains.some(x => x.id === initialState.chainId) ? initialState.chainId : config.chains[0].id,\n    connections: reconnectOnMount ? initialState.connections : new Map(),\n    status: reconnectOnMount ? 'reconnecting' : 'disconnected'\n  });\n  return {\n    async onMount() {\n      if (config._internal.ssr) {\n        await config._internal.store.persist.rehydrate();\n        if (config._internal.mipd) {\n          config._internal.connectors.setState(connectors => {\n            const rdnsSet = new Set();\n            for (const connector of connectors ?? []) {\n              if (connector.rdns) {\n                const rdnsValues = Array.isArray(connector.rdns) ? connector.rdns : [connector.rdns];\n                for (const rdns of rdnsValues) {\n                  rdnsSet.add(rdns);\n                }\n              }\n            }\n            const mipdConnectors = [];\n            const providers = config._internal.mipd?.getProviders() ?? [];\n            for (const provider of providers) {\n              if (rdnsSet.has(provider.info.rdns)) continue;\n              const connectorFn = config._internal.connectors.providerDetailToConnector(provider);\n              const connector = config._internal.connectors.setup(connectorFn);\n              mipdConnectors.push(connector);\n            }\n            return [...connectors, ...mipdConnectors];\n          });\n        }\n      }\n      if (reconnectOnMount) reconnect(config);else if (config.storage)\n        // Reset connections that may have been hydrated from storage.\n        config.setState(x => ({\n          ...x,\n          connections: new Map()\n        }));\n    }\n  };\n}","map":{"version":3,"names":["reconnect","hydrate","config","parameters","initialState","reconnectOnMount","_internal","store","persist","hasHydrated","setState","chainId","chains","some","x","id","connections","Map","status","onMount","ssr","rehydrate","mipd","connectors","rdnsSet","Set","connector","rdns","rdnsValues","Array","isArray","add","mipdConnectors","providers","getProviders","provider","has","info","connectorFn","providerDetailToConnector","setup","push","storage"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/core/src/hydrate.ts"],"sourcesContent":["import { reconnect } from './actions/reconnect.js'\nimport type { Config, State } from './createConfig.js'\n\ntype HydrateParameters = {\n  initialState?: State | undefined\n  reconnectOnMount?: boolean | undefined\n}\n\nexport function hydrate(config: Config, parameters: HydrateParameters) {\n  const { initialState, reconnectOnMount } = parameters\n\n  if (initialState && !config._internal.store.persist.hasHydrated())\n    config.setState({\n      ...initialState,\n      chainId: config.chains.some((x) => x.id === initialState.chainId)\n        ? initialState.chainId\n        : config.chains[0].id,\n      connections: reconnectOnMount ? initialState.connections : new Map(),\n      status: reconnectOnMount ? 'reconnecting' : 'disconnected',\n    })\n\n  return {\n    async onMount() {\n      if (config._internal.ssr) {\n        await config._internal.store.persist.rehydrate()\n        if (config._internal.mipd) {\n          config._internal.connectors.setState((connectors) => {\n            const rdnsSet = new Set<string>()\n            for (const connector of connectors ?? []) {\n              if (connector.rdns) {\n                const rdnsValues = Array.isArray(connector.rdns)\n                  ? connector.rdns\n                  : [connector.rdns]\n                for (const rdns of rdnsValues) {\n                  rdnsSet.add(rdns)\n                }\n              }\n            }\n            const mipdConnectors = []\n            const providers = config._internal.mipd?.getProviders() ?? []\n            for (const provider of providers) {\n              if (rdnsSet.has(provider.info.rdns)) continue\n              const connectorFn =\n                config._internal.connectors.providerDetailToConnector(provider)\n              const connector = config._internal.connectors.setup(connectorFn)\n              mipdConnectors.push(connector)\n            }\n            return [...connectors, ...mipdConnectors]\n          })\n        }\n      }\n\n      if (reconnectOnMount) reconnect(config)\n      else if (config.storage)\n        // Reset connections that may have been hydrated from storage.\n        config.setState((x) => ({\n          ...x,\n          connections: new Map(),\n        }))\n    },\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,wBAAwB;AAQlD,OAAM,SAAUC,OAAOA,CAACC,MAAc,EAAEC,UAA6B;EACnE,MAAM;IAAEC,YAAY;IAAEC;EAAgB,CAAE,GAAGF,UAAU;EAErD,IAAIC,YAAY,IAAI,CAACF,MAAM,CAACI,SAAS,CAACC,KAAK,CAACC,OAAO,CAACC,WAAW,EAAE,EAC/DP,MAAM,CAACQ,QAAQ,CAAC;IACd,GAAGN,YAAY;IACfO,OAAO,EAAET,MAAM,CAACU,MAAM,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACC,EAAE,KAAKX,YAAY,CAACO,OAAO,CAAC,GAC7DP,YAAY,CAACO,OAAO,GACpBT,MAAM,CAACU,MAAM,CAAC,CAAC,CAAC,CAACG,EAAE;IACvBC,WAAW,EAAEX,gBAAgB,GAAGD,YAAY,CAACY,WAAW,GAAG,IAAIC,GAAG,EAAE;IACpEC,MAAM,EAAEb,gBAAgB,GAAG,cAAc,GAAG;GAC7C,CAAC;EAEJ,OAAO;IACL,MAAMc,OAAOA,CAAA;MACX,IAAIjB,MAAM,CAACI,SAAS,CAACc,GAAG,EAAE;QACxB,MAAMlB,MAAM,CAACI,SAAS,CAACC,KAAK,CAACC,OAAO,CAACa,SAAS,EAAE;QAChD,IAAInB,MAAM,CAACI,SAAS,CAACgB,IAAI,EAAE;UACzBpB,MAAM,CAACI,SAAS,CAACiB,UAAU,CAACb,QAAQ,CAAEa,UAAU,IAAI;YAClD,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAU;YACjC,KAAK,MAAMC,SAAS,IAAIH,UAAU,IAAI,EAAE,EAAE;cACxC,IAAIG,SAAS,CAACC,IAAI,EAAE;gBAClB,MAAMC,UAAU,GAAGC,KAAK,CAACC,OAAO,CAACJ,SAAS,CAACC,IAAI,CAAC,GAC5CD,SAAS,CAACC,IAAI,GACd,CAACD,SAAS,CAACC,IAAI,CAAC;gBACpB,KAAK,MAAMA,IAAI,IAAIC,UAAU,EAAE;kBAC7BJ,OAAO,CAACO,GAAG,CAACJ,IAAI,CAAC;gBACnB;cACF;YACF;YACA,MAAMK,cAAc,GAAG,EAAE;YACzB,MAAMC,SAAS,GAAG/B,MAAM,CAACI,SAAS,CAACgB,IAAI,EAAEY,YAAY,EAAE,IAAI,EAAE;YAC7D,KAAK,MAAMC,QAAQ,IAAIF,SAAS,EAAE;cAChC,IAAIT,OAAO,CAACY,GAAG,CAACD,QAAQ,CAACE,IAAI,CAACV,IAAI,CAAC,EAAE;cACrC,MAAMW,WAAW,GACfpC,MAAM,CAACI,SAAS,CAACiB,UAAU,CAACgB,yBAAyB,CAACJ,QAAQ,CAAC;cACjE,MAAMT,SAAS,GAAGxB,MAAM,CAACI,SAAS,CAACiB,UAAU,CAACiB,KAAK,CAACF,WAAW,CAAC;cAChEN,cAAc,CAACS,IAAI,CAACf,SAAS,CAAC;YAChC;YACA,OAAO,CAAC,GAAGH,UAAU,EAAE,GAAGS,cAAc,CAAC;UAC3C,CAAC,CAAC;QACJ;MACF;MAEA,IAAI3B,gBAAgB,EAAEL,SAAS,CAACE,MAAM,CAAC,MAClC,IAAIA,MAAM,CAACwC,OAAO;QACrB;QACAxC,MAAM,CAACQ,QAAQ,CAAEI,CAAC,KAAM;UACtB,GAAGA,CAAC;UACJE,WAAW,EAAE,IAAIC,GAAG;SACrB,CAAC,CAAC;IACP;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}