{"ast":null,"code":"/**\n * Utilities & types for working with [Application Binary Interfaces (ABIs)](https://docs.soliditylang.org/en/latest/abi-spec.html)\n *\n * :::note\n *\n * If you are looking for ABI parameter **encoding** & **decoding** functions, see {@link ox#AbiParameters.(encode:function)} & {@link ox#AbiParameters.(decode:function)}.\n *\n * :::\n *\n * @example\n * ### Instantiating JSON ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a JSON ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating Human Readable ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a human-readable ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([\n *   'function approve(address spender, uint256 amount) returns (bool)',\n * ])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABIs\n *\n * An {@link ox#Abi.Abi} can be formatted into a human-readable ABI by using {@link ox#Abi.(format:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n * //---cut---\n * const formatted = Abi.format(abi)\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @category ABI\n */\nimport * as _Abi from './core/Abi.js';\nexport { _Abi as Abi };\n/**\n * Utilities & types for working with [Constructors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiConstructor` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiConstructor` can be instantiated from a JSON ABI by using {@link ox#AbiConstructor.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiConstructor` can be instantiated from a human-readable ABI by using {@link ox#AbiConstructor.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address owner)')\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Deploy Data\n *\n * Constructor arguments can be ABI-encoded using {@link ox#AbiConstructor.(encode:function)} (with bytecode) into deploy data. This data can then be passed to a transaction to deploy a contract.\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category ABI\n */\nimport * as _AbiConstructor from './core/AbiConstructor.js';\nexport { _AbiConstructor as AbiConstructor };\n/**\n * Utilities & types for working with [Errors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiError` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiError` can be instantiated from a JSON ABI by using {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiError` can be instantiated from a human-readable ABI by using {@link ox#AbiError.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error BadSignatureV(uint8 v)')\n *\n * error\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Decoding Error Data\n *\n * Error data can be ABI-decoded using the {@link ox#AbiError.(decode:function)} function.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, 'InvalidSignature')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001') // [!code focus]\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @category ABI\n */\nimport * as _AbiError from './core/AbiError.js';\nexport { _AbiError as AbiError };\n/**\n * Utilities & types for working with [Events](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiEvent` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiEvent` can be instantiated from a JSON ABI by using {@link ox#AbiEvent.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiEvent.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiEvent` can be instantiated from a human-readable ABI by using {@link ox#AbiEvent.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)' // [!code hl]\n * )\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Event Topics\n *\n * Encode an `AbiEvent` into topics using {@link ox#AbiEvent.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code hl]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code hl]\n * })\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### Decoding Event Topics and Data\n *\n * Event topics and data can be decoded using {@link ox#AbiEvent.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(transfer, log)\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @category ABI\n */\nimport * as _AbiEvent from './core/AbiEvent.js';\nexport { _AbiEvent as AbiEvent };\n/**\n * Utilities & types for working with [Functions](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiFunction` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiFunction` can be instantiated from a JSON ABI by using {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'bar') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiFunction` can be instantiated from a human-readable ABI by using {@link ox#AbiFunction.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const bar = AbiFunction.from('function bar(string a) returns (uint256 x)')\n *\n * bar\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Function Data\n *\n * A Function and its arguments can be ABI-encoded into data using the {@link ox#AbiFunction.(encodeData:function)} function. The output of this function can then be passed to `eth_sendTransaction` or `eth_call` as the `data` parameter.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### Decoding a Function's Result\n *\n * A Function's result can be ABI-decoded using the {@link ox#AbiFunction.(decodeResult:function)} function.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n * //    ↑ Example data that could be returned from a contract call via `eth_call`.\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data) // [!code focus]\n * // @log: 42n\n * ```\n *\n * @category ABI\n */\nimport * as _AbiFunction from './core/AbiFunction.js';\nexport { _AbiFunction as AbiFunction };\n/**\n * Utilities & types for working with [ABI Items](https://docs.soliditylang.org/en/latest/abi-spec.html#json)\n *\n * The `AbiItem` type is a super-type of:\n * - [`AbiConstructor`](/api/AbiConstructor)\n * - [`AbiFunction`](/api/AbiFunction)\n * - [`AbiEvent`](/api/AbiEvent)\n * - [`AbiError`](/api/AbiError)\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiItem` can be instantiated from a JSON ABI by using {@link ox#AbiItem.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABI Items\n *\n * An `AbiItem` can be formatted into a human-readable ABI Item by using {@link ox#AbiItem.(format:function)}:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * const formatted = AbiItem.format(abiItem)\n * // @log: 'function approve(address spender, uint256 amount) returns (bool)'\n * ```\n *\n * @category ABI\n */\nimport * as _AbiItem from './core/AbiItem.js';\nexport { _AbiItem as AbiItem };\n/**\n * Utilities & types for encoding, decoding, and working with [ABI Parameters](https://docs.soliditylang.org/en/latest/abi-spec.html#types)\n *\n * @example\n * ### Encoding ABI Parameters\n *\n * ABI Parameters can be ABI-encoded as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec) using {@link ox#AbiParameters.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from('string, uint, bool'),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::tip\n *\n * The example above uses {@link ox#AbiParameters.(from:function)} to specify human-readable ABI Parameters.\n *\n * However, you can also pass JSON-ABI Parameters:\n *\n * ```ts\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [{ type: 'string' }, { type: 'uint' }, { type: 'bool' }],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Decoding ABI Parameters\n *\n * ABI-encoded data can be decoded using {@link ox#AbiParameters.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from('string, uint, bool'),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON-ABI Parameters\n *\n * JSON-ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABI Parameters\n *\n * Human Readable ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category ABI\n */\nimport * as _AbiParameters from './core/AbiParameters.js';\nexport { _AbiParameters as AbiParameters };\n/**\n * Utilities & types for working with Access Lists as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4140e528360fea53c34a766d86a000c6c039100e/src/schemas/transaction.yaml#L73)\n *\n * @category Execution Spec\n */\nimport * as _AccessList from './core/AccessList.js';\nexport { _AccessList as AccessList };\n/**\n * Utilities & types for working with Account Proofs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/state.yaml)\n *\n * @category Execution Spec\n */\nimport * as _AccountProof from './core/AccountProof.js';\nexport { _AccountProof as AccountProof };\n/**\n * Utility functions for working with Ethereum addresses.\n *\n * @example\n * ### Instantiating Addresses\n *\n * An {@link ox#Address.Address} can be instantiated from a hex string using {@link ox#Address.(from:function)}:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const address = Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ### Validating Addresses\n *\n * The {@link ox#Address.(validate:function)} function will return `true` if the address is valid, and `false` otherwise:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const valid = Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * The {@link ox#Address.(assert:function)} function will throw an error if the address is invalid:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @example\n * ### Addresses from ECDSA Public Keys\n *\n * An {@link ox#Address.Address} can be computed from an ECDSA public key using {@link ox#Address.(fromPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Address, Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n *\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @category Addresses\n */\nimport * as _Address from './core/Address.js';\nexport { _Address as Address };\n/**\n * Utilities & types for working with AES-GCM encryption. Internally uses the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API).\n *\n * @example\n * ### Encrypting Data\n *\n * Data can be encrypted using {@link ox#AesGcm.(encrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @example\n * ### Decrypting Data\n *\n * Data can be decrypted using {@link ox#AesGcm.(decrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const encrypted = await AesGcm.encrypt(Hex.fromString('i am a secret message'), key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @category Crypto\n */\nimport * as _AesGcm from './core/AesGcm.js';\nexport { _AesGcm as AesGcm };\n/**\n * Utility functions for working with [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization lists & tuples.\n *\n * @example\n * ### Instantiating Authorizations\n *\n * An Authorization can be instantiated using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Computing Sign Payload\n *\n * A signing payload can be computed using {@link ox#Authorization.(getSignPayload:function)}. The result can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures to Authorizations\n *\n * A signature can be attached to an Authorization using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [authorization_signed],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @category Authorization (EIP-7702)\n */\nimport * as _Authorization from './core/Authorization.js';\nexport { _Authorization as Authorization };\n/**\n * Utility functions for working with [Base58](https://digitalbazaar.github.io/base58-spec/) values.\n *\n * @example\n * ### Encoding to Base58\n *\n * Values can be encoded to Base58 with:\n *\n * - {@link ox#Base58.(fromString:function)}, or\n *\n * - {@link ox#Base58.(fromBytes:function)}, or\n *\n * - {@link ox#Base58.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.fromString('Hello World!')\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_bytes = Base58.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_hex = Base58.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @example\n * ### Decoding Base58\n *\n * Values can be decoded from Base58 with:\n *\n * - {@link ox#Base58.(toString:function)}, or\n *\n * - {@link ox#Base58.(toBytes:function)}, or\n *\n * - {@link ox#Base58.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.toString('2NEpo7TZRRrLZSi2U')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base58.toBytes('2NEpo7TZRRrLZSi2U')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base58.toHex('2NEpo7TZRRrLZSi2U')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\nimport * as _Base from './core/Base58.js';\nexport { _Base as Base58 };\n/**\n * Utility functions for working with [RFC-4648](https://datatracker.ietf.org/doc/html/rfc4648) Base64.\n *\n * @example\n * ### Encoding to Base64\n *\n * Values can be encoded to Base64 with:\n *\n * - {@link ox#Base64.(fromString:function)}, or\n *\n * - {@link ox#Base64.(fromBytes:function)}, or\n *\n * - {@link ox#Base64.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.fromString('Hello World!')\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_bytes = Base64.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_hex = Base64.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: 'SGVsbG8gV29ybGQh=='\n * ```\n *\n * ### Decoding Base64\n *\n * Values can be decoded from Base64 with:\n *\n * - {@link ox#Base64.(toString:function)}, or\n *\n * - {@link ox#Base64.(toBytes:function)}, or\n *\n * - {@link ox#Base64.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.toString('SGVsbG8gV29ybGQh==')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base64.toBytes('SGVsbG8gV29ybGQh==')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base64.toHex('SGVsbG8gV29ybGQh==')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\nimport * as _Base2 from './core/Base64.js';\nexport { _Base2 as Base64 };\n/**\n * Utility functions for working with [EIP-7864](https://eips.ethereum.org/EIPS/eip-7864) Binary State Trees.\n *\n * @category Binary State Tree (EIP-7864)\n */\nimport * as _BinaryStateTree from './core/BinaryStateTree.js';\nexport { _BinaryStateTree as BinaryStateTree };\n/**\n * Utility functions for working with [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\nimport * as _Blobs from './core/Blobs.js';\nexport { _Blobs as Blobs };\n/**\n * Utilities & types for working with Blocks as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Blocks can be converted from RPC format to internal format using {@link ox#Block.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Block } from 'ox'\n *\n * const block = await window.ethereum!\n *   .request({\n *     method: 'eth_getBlockByNumber',\n *     params: ['latest', false],\n *   })\n *   .then(Block.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nimport * as _Block from './core/Block.js';\nexport { _Block as Block };\n/**\n * Utilities & types for working with **Block Overrides**.\n *\n * @category Execution Spec\n */\nimport * as _BlockOverrides from './core/BlockOverrides.js';\nexport { _BlockOverrides as BlockOverrides };\n/**\n * Utility functions for working with Bloom Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @category Execution Spec\n */\nimport * as _Bloom from './core/Bloom.js';\nexport { _Bloom as Bloom };\n/**\n * Utility functions for [BLS12-381](https://hackmd.io/\\@benjaminion/bls12-381) cryptography.\n *\n * :::info\n *\n * The `Bls` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Bls.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Bls.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * // @log: { x: 3251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Bls.(sign:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Bls.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @example\n * ### Aggregating Public Keys & Signatures\n *\n * Public keys and signatures can be aggregated using {@link ox#Bls.(aggregate:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKeys = [\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n * ]\n * const publicKey = Bls.aggregate(publicKeys)\n *\n * const signatures = [\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n * ]\n * const signature = Bls.aggregate(signatures)\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @category Crypto\n */\nimport * as _Bls from './core/Bls.js';\nexport { _Bls as Bls };\n/**\n * Utility functions for working with BLS12-381 points.\n *\n * :::info\n *\n * The `BlsPoint` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Public Keys or Signatures to Hex\n *\n * BLS points can be converted to hex using {@link ox#BlsPoint.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * // @log: '0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66'\n *\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n * const signatureHex = BlsPoint.toHex(signature)\n * // @log: '0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c'\n * ```\n *\n * @example\n * ### Hex to Public Keys or Signatures\n *\n * BLS points can be converted from hex using {@link ox#BlsPoint.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = BlsPoint.fromHex('0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66', 'G1')\n * // @log: { x: 172...514n, y: 175...235n, z: 1n }\n *\n * const signature = BlsPoint.fromHex('0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c', 'G2')\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @category Crypto\n */\nimport * as _BlsPoint from './core/BlsPoint.js';\nexport { _BlsPoint as BlsPoint };\n/**\n * A set of Ethereum-related utility functions for working with [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instances.\n *\n * @example\n * ### Instantiating Bytes\n *\n * Values can be instantiated as {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(fromArray:function)}\n *\n * - {@link ox#Bytes.(fromBoolean:function)}\n *\n * - {@link ox#Bytes.(fromHex:function)}\n *\n * - {@link ox#Bytes.(fromNumber:function)}\n *\n * - {@link ox#Bytes.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_array = Bytes.from([1, 2, 3, 4, 5])\n * // @log: Uint8Array [1, 2, 3, 4, 5]\n *\n * const value_boolean = Bytes.fromBoolean(true)\n * // @log: Uint8Array [1]\n *\n * const value_hex = Bytes.fromHex('0x1234567890abcdef')\n * // @log: Uint8Array [18, 52, 86, 120, 144, 175, 207, 15]\n *\n * const value_number = Bytes.fromNumber(1234567890)\n * // @log: Uint8Array [4, 160, 216]\n *\n * const value_string = Bytes.fromString('Hello World!')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n * ```\n *\n * @example\n * ### Converting from Bytes\n *\n * Values can be converted from {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(toBigInt:function)}\n *\n * - {@link ox#Bytes.(toBoolean:function)}\n *\n * - {@link ox#Bytes.(toHex:function)}\n *\n * - {@link ox#Bytes.(toNumber:function)}\n *\n * - {@link ox#Bytes.(toString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_bigint = Bytes.toBigInt(Bytes.from([4, 160, 216]))\n * // @log: 1234567890n\n *\n * const value_boolean = Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n *\n * const value_hex = Bytes.toHex(Bytes.from([222, 173, 190, 239]))\n * // @log: '0xdeadbeef'\n *\n * const value_number = Bytes.toNumber(Bytes.from([4, 160, 216]))\n * // @log: 1234567890\n *\n * const value_string = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Bytes\n *\n * Values can be concatenated using {@link ox#Bytes.(concat:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const a = Bytes.from([1, 2, 3])\n * const b = Bytes.from([4, 5, 6])\n * const c = Bytes.concat(a, b)\n * // @log: Uint8Array [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @example\n * ### Slicing Bytes\n *\n * Values can be sliced using {@link ox#Bytes.(slice:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.slice(Bytes.from([1, 2, 3, 4, 5, 6]), 2, 4)\n * // @log: Uint8Array [3, 4]\n * ```\n *\n * @example\n * ### Padding Bytes\n *\n * Values can be padded with zeroes using {@link ox#Bytes.(padLeft:function)} or {@link ox#Bytes.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_1 = Bytes.padLeft(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [0, 0, 1, 2, 3]\n *\n * const value_2 = Bytes.padRight(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [1, 2, 3, 0, 0]\n * ```\n *\n * @example\n * ### Trimming Bytes\n *\n * Zeroes in values can be trimmed using {@link ox#Bytes.(trimLeft:function)} or {@link ox#Bytes.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.trimLeft(Bytes.from([0, 0, 1, 2, 3]))\n * // @log: Uint8Array [1, 2, 3]\n * ```\n *\n * @category Data\n */\nimport * as _Bytes from './core/Bytes.js';\nexport { _Bytes as Bytes };\nimport * as _Caches from './core/Caches.js';\nexport { _Caches as Caches };\n/**\n * Utility functions for computing Contract Addresses.\n *\n * @example\n * ### Computing Contract Addresses (CREATE)\n *\n * A Contract Address that was instantiated using the `CREATE` opcode can be computed using {@link ox#ContractAddress.(fromCreate:function)}:\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### Computing Contract Addresses (CREATE2)\n *\n * A Contract Address that was instantiated using the `CREATE2` opcode can be computed using {@link ox#ContractAddress.(fromCreate2:function)}:\n *\n * ```ts twoslash\n * import { Bytes, ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: Bytes.from('0x6394198df16000526103ff60206004601c335afa6040516060f3'),\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @category Addresses\n */\nimport * as _ContractAddress from './core/ContractAddress.js';\nexport { _ContractAddress as ContractAddress };\n/**\n * Utility functions for working with ENS names.\n *\n * @example\n * ### Normalizing ENS Names\n *\n * ENS names can be normalized using {@link ox#Ens.(normalize:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.normalize('w𝝣vm.eth')\n * // @log: 'wξvm.eth'\n * ```\n *\n * @example\n * ### Namehashing ENS Names\n *\n * ENS names can be namehashed using {@link ox#Ens.(namehash:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.namehash('alice.eth')\n * // @log: '0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec'\n * ```\n *\n * @category ENS\n */\nimport * as _Ens from './core/Ens.js';\nexport { _Ens as Ens };\nimport * as _Errors from './core/Errors.js';\nexport { _Errors as Errors };\n/**\n * Utilities & types for working with Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/filter.yaml)\n *\n * @category Execution Spec\n */\nimport * as _Filter from './core/Filter.js';\nexport { _Filter as Filter };\n/**\n * Utility functions for hashing (keccak256, sha256, etc).\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * const value = Hash.keccak256('0xdeadbeef')\n * // '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @category Crypto\n */\nimport * as _Hash from './core/Hash.js';\nexport { _Hash as Hash };\n/**\n * Utility functions for generating and working with [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::info\n *\n * The `HdKey` module is a friendly wrapper over [`@scure/bip32`](https://github.com/paulmillr/scure-bip32), an **audited** implementation of [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::\n *\n *\n * @category Crypto\n */\nimport * as _HdKey from './core/HdKey.js';\nexport { _HdKey as HdKey };\n/**\n * A set of Ethereum-related utility functions for working with hexadecimal string values (e.g. `\"0xdeadbeef\"`).\n *\n * @example\n * ### Instantiating Hex\n *\n * Values can be instantiated as {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(fromBoolean:function)}\n *\n * - {@link ox#Hex.(fromBytes:function)}\n *\n * - {@link ox#Hex.(fromNumber:function)}\n *\n * - {@link ox#Hex.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * const value_boolean = Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * const value_bytes = Hex.fromBytes(Bytes.from([1, 2, 3]))\n * // @log: '0x010203'\n *\n * const value_number = Hex.fromNumber(1234567890)\n * // @log: '0x499602d2'\n *\n * const value_string = Hex.fromString('Hello World!')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @example\n * ### Converting from Hex\n *\n * Values can be converted from {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(toBoolean:function)}\n *\n * - {@link ox#Hex.(toBytes:function)}\n *\n * - {@link ox#Hex.(toNumber:function)}\n *\n * - {@link ox#Hex.(toString:function)}\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value_boolean = Hex.toBoolean('0x1')\n * // @log: true\n *\n * const value_bytes = Hex.toBytes('0x010203')\n * // @log: Uint8Array [1, 2, 3]\n *\n * const value_number = Hex.toNumber('0x499602d2')\n * // @log: 1234567890\n *\n * const value_string = Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Hex\n *\n * Hex values can be concatenated using {@link ox#Hex.(concat:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const a = Hex.fromString('0x1234567890abcdef')\n * const b = Hex.fromString('0xdeadbeef')\n * const c = Hex.concat(a, b)\n * // @log: '0x1234567890abcdefdeadbeef'\n * ```\n *\n * @example\n * ### Slicing Hex\n *\n * Hex values can be sliced using {@link ox#Hex.(slice:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.slice('0x1234567890abcdefdeadbeef', 2, 8)\n * // @log: '0x34567890'\n * ```\n *\n * @example\n * ### Padding Hex\n *\n * Hex values can be padded with zeroes using {@link ox#Hex.(padLeft:function)} or {@link ox#Hex.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.padLeft('0x1234567890abcdef', 16)\n * // @log: '0x00000000000000001234567890abcdef'\n * ```\n *\n * @example\n * ### Trimming Hex\n *\n * Hex values can be trimmed of zeroes using {@link ox#Hex.(trimLeft:function)} or {@link ox#Hex.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.trimLeft('0x00000000000000001234567890abcdef')\n * // @log: '0x1234567890abcdef'\n * ```\n *\n * @category Data\n */\nimport * as _Hex from './core/Hex.js';\nexport { _Hex as Hex };\n/**\n * @category Execution Spec\n */\nimport * as _Fee from './core/Fee.js';\nexport { _Fee as Fee };\n/**\n * Utility functions for working with JSON (with support for `bigint`).\n *\n * @example\n * ### Stringifying JSON\n *\n * JSON values can be stringified (with `bigint` support) using {@link ox#Json.(stringify:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}'\n * ```\n *\n * @example\n * ### Parsing JSON\n *\n * JSON values can be parsed (with `bigint` support) using {@link ox#Json.(parse:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const value = Json.parse('{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}')\n * // @log: { foo: 'bar', baz: 69420694206942069420694206942069420694206942069420n }\n * ```\n *\n * @category JSON\n */\nimport * as _Json from './core/Json.js';\nexport { _Json as Json };\n/**\n * Utility functions for working with KZG Commitments.\n *\n * Mainly for [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\nimport * as _Kzg from './core/Kzg.js';\nexport { _Kzg as Kzg };\n/**\n * Utilities & types for working with Logs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * :::tip\n *\n * Utilities for Log encoding & decoding can be found on the {@link ox#AbiEvent} module.\n *\n * :::\n *\n * @example\n * ### Converting from RPC Format\n *\n * Logs can be converted from their RPC format using {@link ox#Log.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nimport * as _Log from './core/Log.js';\nexport { _Log as Log };\n/**\n * Utility functions for generating and working with [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) mnemonics.\n *\n * :::info\n *\n * The `Mnemonic` module is a friendly wrapper over [`@scure/bip39`](https://github.com/paulmillr/scure-bip39), an **audited** implementation of [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n *\n * :::\n *\n * @example\n * ### Generating a Random Mnemonic\n *\n * Random mnemonics can be generated using {@link ox#Mnemonic.(random:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @example\n * ### Converting to Private Key\n *\n * Mnemonics can be converted to a private key using {@link ox#Mnemonic.(toPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const privateKey = Mnemonic.toPrivateKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Converting to HD Key\n *\n * Mnemonics can be converted to a HD Key using {@link ox#Mnemonic.(toHdKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const hdKey = Mnemonic.toHdKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * ```\n *\n * @example\n * ### Converting to Seed\n *\n * Mnemonics can be converted to a master seed using {@link ox#Mnemonic.(toSeed:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @category Crypto\n */\nimport * as _Mnemonic from './core/Mnemonic.js';\nexport { _Mnemonic as Mnemonic };\n/**\n * Utilities & types for working with [EIP-191 Personal Messages](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e)\n *\n * @example\n * ### Computing Sign Payload\n *\n * An EIP-191 personal sign payload can be computed using {@link ox#PersonalMessage.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\nimport * as _PersonalMessage from './core/PersonalMessage.js';\nexport { _PersonalMessage as PersonalMessage };\n/**\n * Utilities & types for working with [EIP-1193 Providers](https://eips.ethereum.org/EIPS/eip-1193)\n *\n * @example\n * ### Instantiating External Providers\n *\n * External EIP-1193 Providers can be instantiated with {@link ox#Provider.(from:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating with an RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is also EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * Event emitters for EIP-1193 Providers can be created using {@link ox#Provider.(createEmitter:function)}:\n *\n * Useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @category Providers (EIP-1193)\n */\nimport * as _Provider from './core/Provider.js';\nexport { _Provider as Provider };\n/**\n * Utility functions for working with ECDSA public keys.\n *\n * @example\n * ### Serializing Public Keys\n *\n * Public Keys can be serialized to Hex or Bytes using {@link ox#PublicKey.(toHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const serialized = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @example\n * ### Deserializing Public Keys\n *\n * Public Keys can be deserialized from Hex or Bytes using {@link ox#PublicKey.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @category Crypto\n */\nimport * as _PublicKey from './core/PublicKey.js';\nexport { _PublicKey as PublicKey };\n/**\n * Utility functions for encoding and decoding [Recursive Length Prefix](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) structures.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Rlp } from 'ox'\n *\n * const data = Rlp.fromHex([Hex.fromString('hello'), Hex.fromString('world')])\n * // @log: '0xcc8568656c6c6f85776f726c64'\n *\n * const values = Rlp.toHex(data)\n * // @log: [Hex.fromString('hello'), Hex.fromString('world')]\n * ```\n *\n * @category Data\n */\nimport * as _Rlp from './core/Rlp.js';\nexport { _Rlp as Rlp };\n/**\n * Utility types for working with Ethereum JSON-RPC namespaces & schemas.\n *\n * @category JSON-RPC\n */\nimport * as _RpcSchema from './core/RpcSchema.js';\nexport { _RpcSchema as RpcSchema };\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Requests](https://www.jsonrpc.org/specification#request_object) and Ethereum JSON-RPC methods as\n * defined on the [Ethereum API specification](https://github.com/ethereum/execution-apis)\n *\n * @example\n * ### Instantiating a Request Store\n *\n * A Request Store can be instantiated using {@link ox#RpcRequest.(createStore:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @category JSON-RPC\n */\nimport * as _RpcRequest from './core/RpcRequest.js';\nexport { _RpcRequest as RpcRequest };\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Responses](https://www.jsonrpc.org/specification#response_object)\n *\n * @example\n * ### Instantiating an RPC Response\n *\n * RPC Responses can be instantiated using {@link ox#RpcResponse.(from:function)}:\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * :::note\n *\n * Type-safe instantiation from a `request` object is also supported. If a `request` is provided, then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Parsing an RPC Response\n *\n * RPC Responses can be parsed using {@link ox#RpcResponse.(parse:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category JSON-RPC\n */\nimport * as _RpcResponse from './core/RpcResponse.js';\nexport { _RpcResponse as RpcResponse };\n/**\n * Utility functions for working with JSON-RPC Transports.\n *\n * :::note\n * This is a convenience module distributed for experimenting with network connectivity on Ox.\n *\n * Consider using networking functionality from a higher-level library such as [Viem's Transports](https://viem.sh/docs/clients/transports/http)\n * if you need more features such as: retry logic, WebSockets/IPC, middleware, batch JSON-RPC, etc.\n * :::\n *\n * @example\n * ### HTTP Instantiation\n *\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @category JSON-RPC\n */\nimport * as _RpcTransport from './core/RpcTransport.js';\nexport { _RpcTransport as RpcTransport };\n/**\n * Utility functions for [secp256k1](https://www.secg.org/sec2-v2.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `Secp256k1` module is a friendly wrapper over [`@noble/curves/secp256k1`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [secp256k1](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Secp256k1.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Secp256k1.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Secp256k1.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Secp256k1.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nimport * as _Secp256k from './core/Secp256k1.js';\nexport { _Secp256k as Secp256k1 };\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `P256` module is a friendly wrapper over [`@noble/curves/p256`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [P256](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#P256.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#P256.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const publicKey = P256.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#P256.(verify:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = P256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nimport * as _P from './core/P256.js';\nexport { _P as P256 };\n/**\n * Utility functions for working with ECDSA signatures.\n *\n * @example\n * ### Serializing a Signature\n *\n * Signatures can be serialized to Hex or Bytes using {@link ox#Signature.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @example\n * ### Deserializing a Signature\n *\n * Signatures can be deserialized from Hex or Bytes using {@link ox#Signature.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @category Crypto\n */\nimport * as _Signature from './core/Signature.js';\nexport { _Signature as Signature };\n/**\n * Utility functions for working with\n * [EIP-4361: Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361)\n *\n * @example\n * ### Creating a SIWE Message\n *\n * SIWE messages can be created using {@link ox#Siwe.(createMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @example\n * ### Generating SIWE Nonces\n *\n * SIWE nonces can be generated using {@link ox#Siwe.(generateNonce:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @example\n * ### Parsing a SIWE Message\n *\n * SIWE messages can be parsed using {@link ox#Siwe.(parseMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @example\n * ### Validating a SIWE Message\n *\n * SIWE messages can be validated using {@link ox#Siwe.(validateMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @category Sign-In with Ethereum (EIP-4361)\n */\nimport * as _Siwe from './core/Siwe.js';\nexport { _Siwe as Siwe };\nimport * as _Solidity from './core/Solidity.js';\nexport { _Solidity as Solidity };\n/**\n * Utilities & types for working with **State Overrides**.\n *\n * @category Execution Spec\n */\nimport * as _StateOverrides from './core/StateOverrides.js';\nexport { _StateOverrides as StateOverrides };\n/**\n * Utilities & types for working with **Transactions** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Transactions can be converted from RPC format using {@link ox#Transaction.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @category Execution Spec\n */\nimport * as _Transaction from './core/Transaction.js';\nexport { _Transaction as Transaction };\n/**\n * Errors & Types for working with Transaction Envelopes.\n *\n * :::note\n * Refer to the following modules for specific Transaction Envelope types:\n * - [`TransactionEnvelopeLegacy`](/api/TransactionEnvelopeLegacy)\n * - [`TransactionEnvelopeEip1559`](/api/TransactionEnvelopeEip1559)\n * - [`TransactionEnvelopeEip2930`](/api/TransactionEnvelopeEip2930)\n * - [`TransactionEnvelopeEip4844`](/api/TransactionEnvelopeEip4844)\n * - [`TransactionEnvelopeEip7702`](/api/TransactionEnvelopeEip7702)\n * :::\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelope from './core/TransactionEnvelope.js';\nexport { _TransactionEnvelope as TransactionEnvelope };\n/**\n * Utility functions for working\n * with **Legacy Transaction Envelopes**.\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeLegacy.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeLegacy.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeLegacy.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeLegacy, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeLegacy.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeLegacy.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelopeLegacy from './core/TransactionEnvelopeLegacy.js';\nexport { _TransactionEnvelopeLegacy as TransactionEnvelopeLegacy };\n/**\n * Utility functions for working with [EIP-1559 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-1559)\n *\n *  @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip1559.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip1559.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip1559.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip1559, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip1559.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip1559.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelopeEip from './core/TransactionEnvelopeEip1559.js';\nexport { _TransactionEnvelopeEip as TransactionEnvelopeEip1559 };\n/**\n * Utility functions for working with [EIP-2930 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-2930)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip2930.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip2930.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip2930.(serialize:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip2930, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip2930.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip2930.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelopeEip2 from './core/TransactionEnvelopeEip2930.js';\nexport { _TransactionEnvelopeEip2 as TransactionEnvelopeEip2930 };\n/**\n * Utility functions for working with [EIP-4844 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-4844)\n *\n * @example\n * ### Instantiating Blobs\n *\n * Blobs can be instantiated using {@link ox#Blobs.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * ```\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip4844.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Hex, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip4844.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, {\n *   sidecars,\n *   signature\n * })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip4844.(serialize:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcTransport, TransactionEnvelopeEip4844, Secp256k1, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * // Compute the Blob Versioned Hashes.\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 0n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip4844.(hash:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelopeEip3 from './core/TransactionEnvelopeEip4844.js';\nexport { _TransactionEnvelopeEip3 as TransactionEnvelopeEip4844 };\n/**\n * Utility functions for working with [EIP-7702 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-7702)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip7702.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * :::tip\n *\n * See {@link ox#Authorization} for more details on instantiating and signing EIP-7702 Authorizations.\n *\n * :::\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip7702.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...', // [!code focus]\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { Authorization, RpcTransport, TransactionEnvelopeEip7702, Secp256k1, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nimport * as _TransactionEnvelopeEip4 from './core/TransactionEnvelopeEip7702.js';\nexport { _TransactionEnvelopeEip4 as TransactionEnvelopeEip7702 };\n/**\n * Utilities & types for working with **Transaction Receipts** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Receipts can be converted from RPC format using {@link ox#TransactionReceipt.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nimport * as _TransactionReceipt from './core/TransactionReceipt.js';\nexport { _TransactionReceipt as TransactionReceipt };\n/**\n * Utilities & types for working with **Transaction Requests** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4aca1d7a3e5aab24c8f6437131289ad386944eaa/src/schemas/transaction.yaml#L358-L423)\n *\n * @example\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({ // [!code focus]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]\n *   value: Value.fromEther('0.01'), // [!code focus]\n * }) // [!code focus]\n *\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [request],\n * })\n * ```\n *\n * @category Execution Spec\n */\nimport * as _TransactionRequest from './core/TransactionRequest.js';\nexport { _TransactionRequest as TransactionRequest };\n/**\n * Utility functions for working with [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712)\n *\n * @example\n * ### Getting Sign Payloads\n *\n * Typed Data can be converted to a sign payload using {@link ox#TypedData.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\nimport * as _TypedData from './core/TypedData.js';\nexport { _TypedData as TypedData };\n/**\n * Utilities & types for working with [EIP-191 Validator Data](https://eips.ethereum.org/EIPS/eip-191#0x00)\n *\n * @category Signed & Typed Data\n */\nimport * as _ValidatorData from './core/ValidatorData.js';\nexport { _ValidatorData as ValidatorData };\n/**\n * Utility functions for displaying and parsing Ethereum Values as defined under **2.1. Value** in the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n *\n * const value = Value.fromEther('1')\n * // @log: 1_000_000_000_000_000_000n\n *\n * const formattedValue = Value.formatEther(value)\n * // @log: '1'\n *\n * const value = Value.fromEther('1', 'szabo')\n * // @log: 1_000_000n\n * ```\n *\n * @category Data\n */\nimport * as _Value from './core/Value.js';\nexport { _Value as Value };\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Authentication API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API)\n *\n * @example\n * ### Creating Credentials\n *\n * Credentials can be created using {@link ox#WebAuthnP256.(createCredential:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebAuthnP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebAuthnP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nimport * as _WebAuthnP from './core/WebAuthnP256.js';\nexport { _WebAuthnP as WebAuthnP256 };\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)\n *\n * @example\n * ### Creating Key Pairs\n *\n * Key pairs can be created using {@link ox#WebCryptoP256.(createKeyPair:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebCryptoP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebCryptoP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nimport * as _WebCryptoP from './core/WebCryptoP256.js';\nexport { _WebCryptoP as WebCryptoP256 };\n/**\n * Utilities & types for working with Withdrawals as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/withdrawal.yaml)\n *\n * @category Execution Spec\n */\nimport * as _Withdrawal from './core/Withdrawal.js';\nexport { _Withdrawal as Withdrawal };","map":{"version":3,"names":["_Abi","Abi","_AbiConstructor","AbiConstructor","_AbiError","AbiError","_AbiEvent","AbiEvent","_AbiFunction","AbiFunction","_AbiItem","AbiItem","_AbiParameters","AbiParameters","_AccessList","AccessList","_AccountProof","AccountProof","_Address","Address","_AesGcm","AesGcm","_Authorization","Authorization","_Base","Base58","_Base2","Base64","_BinaryStateTree","BinaryStateTree","_Blobs","Blobs","_Block","Block","_BlockOverrides","BlockOverrides","_Bloom","Bloom","_Bls","Bls","_BlsPoint","BlsPoint","_Bytes","Bytes","_Caches","Caches","_ContractAddress","ContractAddress","_Ens","Ens","_Errors","Errors","_Filter","Filter","_Hash","Hash","_HdKey","HdKey","_Hex","Hex","_Fee","Fee","_Json","Json","_Kzg","Kzg","_Log","Log","_Mnemonic","Mnemonic","_PersonalMessage","PersonalMessage","_Provider","Provider","_PublicKey","PublicKey","_Rlp","Rlp","_RpcSchema","RpcSchema","_RpcRequest","RpcRequest","_RpcResponse","RpcResponse","_RpcTransport","RpcTransport","_Secp256k","Secp256k1","_P","P256","_Signature","Signature","_Siwe","Siwe","_Solidity","Solidity","_StateOverrides","StateOverrides","_Transaction","Transaction","_TransactionEnvelope","TransactionEnvelope","_TransactionEnvelopeLegacy","TransactionEnvelopeLegacy","_TransactionEnvelopeEip","TransactionEnvelopeEip1559","_TransactionEnvelopeEip2","TransactionEnvelopeEip2930","_TransactionEnvelopeEip3","TransactionEnvelopeEip4844","_TransactionEnvelopeEip4","TransactionEnvelopeEip7702","_TransactionReceipt","TransactionReceipt","_TransactionRequest","TransactionRequest","_TypedData","TypedData","_ValidatorData","ValidatorData","_Value","Value","_WebAuthnP","WebAuthnP256","_WebCryptoP","WebCryptoP256","_Withdrawal","Withdrawal"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/index.ts"],"sourcesContent":["/** @entrypointCategory Core */\n// biome-ignore lint/complexity/noUselessEmptyExport: tsdoc\nexport type {}\n\n/**\n * Utilities & types for working with [Application Binary Interfaces (ABIs)](https://docs.soliditylang.org/en/latest/abi-spec.html)\n *\n * :::note\n *\n * If you are looking for ABI parameter **encoding** & **decoding** functions, see {@link ox#AbiParameters.(encode:function)} & {@link ox#AbiParameters.(decode:function)}.\n *\n * :::\n *\n * @example\n * ### Instantiating JSON ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a JSON ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating Human Readable ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a human-readable ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([\n *   'function approve(address spender, uint256 amount) returns (bool)',\n * ])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABIs\n *\n * An {@link ox#Abi.Abi} can be formatted into a human-readable ABI by using {@link ox#Abi.(format:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n * //---cut---\n * const formatted = Abi.format(abi)\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @category ABI\n */\nexport * as Abi from './core/Abi.js'\n\n/**\n * Utilities & types for working with [Constructors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiConstructor` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiConstructor` can be instantiated from a JSON ABI by using {@link ox#AbiConstructor.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiConstructor` can be instantiated from a human-readable ABI by using {@link ox#AbiConstructor.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address owner)')\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Deploy Data\n *\n * Constructor arguments can be ABI-encoded using {@link ox#AbiConstructor.(encode:function)} (with bytecode) into deploy data. This data can then be passed to a transaction to deploy a contract.\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category ABI\n */\nexport * as AbiConstructor from './core/AbiConstructor.js'\n\n/**\n * Utilities & types for working with [Errors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiError` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiError` can be instantiated from a JSON ABI by using {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiError` can be instantiated from a human-readable ABI by using {@link ox#AbiError.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error BadSignatureV(uint8 v)')\n *\n * error\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Decoding Error Data\n *\n * Error data can be ABI-decoded using the {@link ox#AbiError.(decode:function)} function.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, 'InvalidSignature')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001') // [!code focus]\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @category ABI\n */\nexport * as AbiError from './core/AbiError.js'\n\n/**\n * Utilities & types for working with [Events](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiEvent` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiEvent` can be instantiated from a JSON ABI by using {@link ox#AbiEvent.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiEvent.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiEvent` can be instantiated from a human-readable ABI by using {@link ox#AbiEvent.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)' // [!code hl]\n * )\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Event Topics\n *\n * Encode an `AbiEvent` into topics using {@link ox#AbiEvent.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code hl]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code hl]\n * })\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### Decoding Event Topics and Data\n *\n * Event topics and data can be decoded using {@link ox#AbiEvent.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(transfer, log)\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @category ABI\n */\nexport * as AbiEvent from './core/AbiEvent.js'\n\n/**\n * Utilities & types for working with [Functions](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiFunction` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiFunction` can be instantiated from a JSON ABI by using {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'bar') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiFunction` can be instantiated from a human-readable ABI by using {@link ox#AbiFunction.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const bar = AbiFunction.from('function bar(string a) returns (uint256 x)')\n *\n * bar\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Function Data\n *\n * A Function and its arguments can be ABI-encoded into data using the {@link ox#AbiFunction.(encodeData:function)} function. The output of this function can then be passed to `eth_sendTransaction` or `eth_call` as the `data` parameter.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### Decoding a Function's Result\n *\n * A Function's result can be ABI-decoded using the {@link ox#AbiFunction.(decodeResult:function)} function.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n * //    ↑ Example data that could be returned from a contract call via `eth_call`.\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data) // [!code focus]\n * // @log: 42n\n * ```\n *\n * @category ABI\n */\nexport * as AbiFunction from './core/AbiFunction.js'\n\n/**\n * Utilities & types for working with [ABI Items](https://docs.soliditylang.org/en/latest/abi-spec.html#json)\n *\n * The `AbiItem` type is a super-type of:\n * - [`AbiConstructor`](/api/AbiConstructor)\n * - [`AbiFunction`](/api/AbiFunction)\n * - [`AbiEvent`](/api/AbiEvent)\n * - [`AbiError`](/api/AbiError)\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiItem` can be instantiated from a JSON ABI by using {@link ox#AbiItem.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABI Items\n *\n * An `AbiItem` can be formatted into a human-readable ABI Item by using {@link ox#AbiItem.(format:function)}:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * const formatted = AbiItem.format(abiItem)\n * // @log: 'function approve(address spender, uint256 amount) returns (bool)'\n * ```\n *\n * @category ABI\n */\nexport * as AbiItem from './core/AbiItem.js'\n\n/**\n * Utilities & types for encoding, decoding, and working with [ABI Parameters](https://docs.soliditylang.org/en/latest/abi-spec.html#types)\n *\n * @example\n * ### Encoding ABI Parameters\n *\n * ABI Parameters can be ABI-encoded as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec) using {@link ox#AbiParameters.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from('string, uint, bool'),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::tip\n *\n * The example above uses {@link ox#AbiParameters.(from:function)} to specify human-readable ABI Parameters.\n *\n * However, you can also pass JSON-ABI Parameters:\n *\n * ```ts\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [{ type: 'string' }, { type: 'uint' }, { type: 'bool' }],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Decoding ABI Parameters\n *\n * ABI-encoded data can be decoded using {@link ox#AbiParameters.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from('string, uint, bool'),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON-ABI Parameters\n *\n * JSON-ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABI Parameters\n *\n * Human Readable ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category ABI\n */\nexport * as AbiParameters from './core/AbiParameters.js'\n\n/**\n * Utilities & types for working with Access Lists as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4140e528360fea53c34a766d86a000c6c039100e/src/schemas/transaction.yaml#L73)\n *\n * @category Execution Spec\n */\nexport * as AccessList from './core/AccessList.js'\n\n/**\n * Utilities & types for working with Account Proofs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/state.yaml)\n *\n * @category Execution Spec\n */\nexport * as AccountProof from './core/AccountProof.js'\n\n/**\n * Utility functions for working with Ethereum addresses.\n *\n * @example\n * ### Instantiating Addresses\n *\n * An {@link ox#Address.Address} can be instantiated from a hex string using {@link ox#Address.(from:function)}:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const address = Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ### Validating Addresses\n *\n * The {@link ox#Address.(validate:function)} function will return `true` if the address is valid, and `false` otherwise:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const valid = Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * The {@link ox#Address.(assert:function)} function will throw an error if the address is invalid:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @example\n * ### Addresses from ECDSA Public Keys\n *\n * An {@link ox#Address.Address} can be computed from an ECDSA public key using {@link ox#Address.(fromPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Address, Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n *\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @category Addresses\n */\nexport * as Address from './core/Address.js'\n\n/**\n * Utilities & types for working with AES-GCM encryption. Internally uses the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API).\n *\n * @example\n * ### Encrypting Data\n *\n * Data can be encrypted using {@link ox#AesGcm.(encrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @example\n * ### Decrypting Data\n *\n * Data can be decrypted using {@link ox#AesGcm.(decrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const encrypted = await AesGcm.encrypt(Hex.fromString('i am a secret message'), key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @category Crypto\n */\nexport * as AesGcm from './core/AesGcm.js'\n\n/**\n * Utility functions for working with [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization lists & tuples.\n *\n * @example\n * ### Instantiating Authorizations\n *\n * An Authorization can be instantiated using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Computing Sign Payload\n *\n * A signing payload can be computed using {@link ox#Authorization.(getSignPayload:function)}. The result can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures to Authorizations\n *\n * A signature can be attached to an Authorization using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [authorization_signed],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @category Authorization (EIP-7702)\n */\nexport * as Authorization from './core/Authorization.js'\n\n/**\n * Utility functions for working with [Base58](https://digitalbazaar.github.io/base58-spec/) values.\n *\n * @example\n * ### Encoding to Base58\n *\n * Values can be encoded to Base58 with:\n *\n * - {@link ox#Base58.(fromString:function)}, or\n *\n * - {@link ox#Base58.(fromBytes:function)}, or\n *\n * - {@link ox#Base58.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.fromString('Hello World!')\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_bytes = Base58.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_hex = Base58.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @example\n * ### Decoding Base58\n *\n * Values can be decoded from Base58 with:\n *\n * - {@link ox#Base58.(toString:function)}, or\n *\n * - {@link ox#Base58.(toBytes:function)}, or\n *\n * - {@link ox#Base58.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.toString('2NEpo7TZRRrLZSi2U')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base58.toBytes('2NEpo7TZRRrLZSi2U')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base58.toHex('2NEpo7TZRRrLZSi2U')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\nexport * as Base58 from './core/Base58.js'\n\n/**\n * Utility functions for working with [RFC-4648](https://datatracker.ietf.org/doc/html/rfc4648) Base64.\n *\n * @example\n * ### Encoding to Base64\n *\n * Values can be encoded to Base64 with:\n *\n * - {@link ox#Base64.(fromString:function)}, or\n *\n * - {@link ox#Base64.(fromBytes:function)}, or\n *\n * - {@link ox#Base64.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.fromString('Hello World!')\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_bytes = Base64.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_hex = Base64.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: 'SGVsbG8gV29ybGQh=='\n * ```\n *\n * ### Decoding Base64\n *\n * Values can be decoded from Base64 with:\n *\n * - {@link ox#Base64.(toString:function)}, or\n *\n * - {@link ox#Base64.(toBytes:function)}, or\n *\n * - {@link ox#Base64.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.toString('SGVsbG8gV29ybGQh==')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base64.toBytes('SGVsbG8gV29ybGQh==')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base64.toHex('SGVsbG8gV29ybGQh==')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\nexport * as Base64 from './core/Base64.js'\n\n/**\n * Utility functions for working with [EIP-7864](https://eips.ethereum.org/EIPS/eip-7864) Binary State Trees.\n *\n * @category Binary State Tree (EIP-7864)\n */\nexport * as BinaryStateTree from './core/BinaryStateTree.js'\n\n/**\n * Utility functions for working with [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\nexport * as Blobs from './core/Blobs.js'\n\n/**\n * Utilities & types for working with Blocks as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Blocks can be converted from RPC format to internal format using {@link ox#Block.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Block } from 'ox'\n *\n * const block = await window.ethereum!\n *   .request({\n *     method: 'eth_getBlockByNumber',\n *     params: ['latest', false],\n *   })\n *   .then(Block.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nexport * as Block from './core/Block.js'\n\n/**\n * Utilities & types for working with **Block Overrides**.\n *\n * @category Execution Spec\n */\nexport * as BlockOverrides from './core/BlockOverrides.js'\n\n/**\n * Utility functions for working with Bloom Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @category Execution Spec\n */\nexport * as Bloom from './core/Bloom.js'\n\n/**\n * Utility functions for [BLS12-381](https://hackmd.io/\\@benjaminion/bls12-381) cryptography.\n *\n * :::info\n *\n * The `Bls` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Bls.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Bls.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * // @log: { x: 3251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Bls.(sign:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Bls.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @example\n * ### Aggregating Public Keys & Signatures\n *\n * Public keys and signatures can be aggregated using {@link ox#Bls.(aggregate:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKeys = [\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n * ]\n * const publicKey = Bls.aggregate(publicKeys)\n *\n * const signatures = [\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n * ]\n * const signature = Bls.aggregate(signatures)\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @category Crypto\n */\nexport * as Bls from './core/Bls.js'\n\n/**\n * Utility functions for working with BLS12-381 points.\n *\n * :::info\n *\n * The `BlsPoint` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Public Keys or Signatures to Hex\n *\n * BLS points can be converted to hex using {@link ox#BlsPoint.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * // @log: '0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66'\n *\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n * const signatureHex = BlsPoint.toHex(signature)\n * // @log: '0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c'\n * ```\n *\n * @example\n * ### Hex to Public Keys or Signatures\n *\n * BLS points can be converted from hex using {@link ox#BlsPoint.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = BlsPoint.fromHex('0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66', 'G1')\n * // @log: { x: 172...514n, y: 175...235n, z: 1n }\n *\n * const signature = BlsPoint.fromHex('0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c', 'G2')\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @category Crypto\n */\nexport * as BlsPoint from './core/BlsPoint.js'\n\n/**\n * A set of Ethereum-related utility functions for working with [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instances.\n *\n * @example\n * ### Instantiating Bytes\n *\n * Values can be instantiated as {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(fromArray:function)}\n *\n * - {@link ox#Bytes.(fromBoolean:function)}\n *\n * - {@link ox#Bytes.(fromHex:function)}\n *\n * - {@link ox#Bytes.(fromNumber:function)}\n *\n * - {@link ox#Bytes.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_array = Bytes.from([1, 2, 3, 4, 5])\n * // @log: Uint8Array [1, 2, 3, 4, 5]\n *\n * const value_boolean = Bytes.fromBoolean(true)\n * // @log: Uint8Array [1]\n *\n * const value_hex = Bytes.fromHex('0x1234567890abcdef')\n * // @log: Uint8Array [18, 52, 86, 120, 144, 175, 207, 15]\n *\n * const value_number = Bytes.fromNumber(1234567890)\n * // @log: Uint8Array [4, 160, 216]\n *\n * const value_string = Bytes.fromString('Hello World!')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n * ```\n *\n * @example\n * ### Converting from Bytes\n *\n * Values can be converted from {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(toBigInt:function)}\n *\n * - {@link ox#Bytes.(toBoolean:function)}\n *\n * - {@link ox#Bytes.(toHex:function)}\n *\n * - {@link ox#Bytes.(toNumber:function)}\n *\n * - {@link ox#Bytes.(toString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_bigint = Bytes.toBigInt(Bytes.from([4, 160, 216]))\n * // @log: 1234567890n\n *\n * const value_boolean = Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n *\n * const value_hex = Bytes.toHex(Bytes.from([222, 173, 190, 239]))\n * // @log: '0xdeadbeef'\n *\n * const value_number = Bytes.toNumber(Bytes.from([4, 160, 216]))\n * // @log: 1234567890\n *\n * const value_string = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Bytes\n *\n * Values can be concatenated using {@link ox#Bytes.(concat:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const a = Bytes.from([1, 2, 3])\n * const b = Bytes.from([4, 5, 6])\n * const c = Bytes.concat(a, b)\n * // @log: Uint8Array [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @example\n * ### Slicing Bytes\n *\n * Values can be sliced using {@link ox#Bytes.(slice:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.slice(Bytes.from([1, 2, 3, 4, 5, 6]), 2, 4)\n * // @log: Uint8Array [3, 4]\n * ```\n *\n * @example\n * ### Padding Bytes\n *\n * Values can be padded with zeroes using {@link ox#Bytes.(padLeft:function)} or {@link ox#Bytes.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_1 = Bytes.padLeft(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [0, 0, 1, 2, 3]\n *\n * const value_2 = Bytes.padRight(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [1, 2, 3, 0, 0]\n * ```\n *\n * @example\n * ### Trimming Bytes\n *\n * Zeroes in values can be trimmed using {@link ox#Bytes.(trimLeft:function)} or {@link ox#Bytes.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.trimLeft(Bytes.from([0, 0, 1, 2, 3]))\n * // @log: Uint8Array [1, 2, 3]\n * ```\n *\n * @category Data\n */\nexport * as Bytes from './core/Bytes.js'\n\nexport * as Caches from './core/Caches.js'\n\n/**\n * Utility functions for computing Contract Addresses.\n *\n * @example\n * ### Computing Contract Addresses (CREATE)\n *\n * A Contract Address that was instantiated using the `CREATE` opcode can be computed using {@link ox#ContractAddress.(fromCreate:function)}:\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### Computing Contract Addresses (CREATE2)\n *\n * A Contract Address that was instantiated using the `CREATE2` opcode can be computed using {@link ox#ContractAddress.(fromCreate2:function)}:\n *\n * ```ts twoslash\n * import { Bytes, ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: Bytes.from('0x6394198df16000526103ff60206004601c335afa6040516060f3'),\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @category Addresses\n */\nexport * as ContractAddress from './core/ContractAddress.js'\n\n/**\n * Utility functions for working with ENS names.\n *\n * @example\n * ### Normalizing ENS Names\n *\n * ENS names can be normalized using {@link ox#Ens.(normalize:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.normalize('w𝝣vm.eth')\n * // @log: 'wξvm.eth'\n * ```\n *\n * @example\n * ### Namehashing ENS Names\n *\n * ENS names can be namehashed using {@link ox#Ens.(namehash:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.namehash('alice.eth')\n * // @log: '0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec'\n * ```\n *\n * @category ENS\n */\nexport * as Ens from './core/Ens.js'\n\nexport * as Errors from './core/Errors.js'\n\n/**\n * Utilities & types for working with Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/filter.yaml)\n *\n * @category Execution Spec\n */\nexport * as Filter from './core/Filter.js'\n\n/**\n * Utility functions for hashing (keccak256, sha256, etc).\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * const value = Hash.keccak256('0xdeadbeef')\n * // '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @category Crypto\n */\nexport * as Hash from './core/Hash.js'\n\n/**\n * Utility functions for generating and working with [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::info\n *\n * The `HdKey` module is a friendly wrapper over [`@scure/bip32`](https://github.com/paulmillr/scure-bip32), an **audited** implementation of [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::\n *\n *\n * @category Crypto\n */\nexport * as HdKey from './core/HdKey.js'\n\n/**\n * A set of Ethereum-related utility functions for working with hexadecimal string values (e.g. `\"0xdeadbeef\"`).\n *\n * @example\n * ### Instantiating Hex\n *\n * Values can be instantiated as {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(fromBoolean:function)}\n *\n * - {@link ox#Hex.(fromBytes:function)}\n *\n * - {@link ox#Hex.(fromNumber:function)}\n *\n * - {@link ox#Hex.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * const value_boolean = Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * const value_bytes = Hex.fromBytes(Bytes.from([1, 2, 3]))\n * // @log: '0x010203'\n *\n * const value_number = Hex.fromNumber(1234567890)\n * // @log: '0x499602d2'\n *\n * const value_string = Hex.fromString('Hello World!')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @example\n * ### Converting from Hex\n *\n * Values can be converted from {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(toBoolean:function)}\n *\n * - {@link ox#Hex.(toBytes:function)}\n *\n * - {@link ox#Hex.(toNumber:function)}\n *\n * - {@link ox#Hex.(toString:function)}\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value_boolean = Hex.toBoolean('0x1')\n * // @log: true\n *\n * const value_bytes = Hex.toBytes('0x010203')\n * // @log: Uint8Array [1, 2, 3]\n *\n * const value_number = Hex.toNumber('0x499602d2')\n * // @log: 1234567890\n *\n * const value_string = Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Hex\n *\n * Hex values can be concatenated using {@link ox#Hex.(concat:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const a = Hex.fromString('0x1234567890abcdef')\n * const b = Hex.fromString('0xdeadbeef')\n * const c = Hex.concat(a, b)\n * // @log: '0x1234567890abcdefdeadbeef'\n * ```\n *\n * @example\n * ### Slicing Hex\n *\n * Hex values can be sliced using {@link ox#Hex.(slice:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.slice('0x1234567890abcdefdeadbeef', 2, 8)\n * // @log: '0x34567890'\n * ```\n *\n * @example\n * ### Padding Hex\n *\n * Hex values can be padded with zeroes using {@link ox#Hex.(padLeft:function)} or {@link ox#Hex.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.padLeft('0x1234567890abcdef', 16)\n * // @log: '0x00000000000000001234567890abcdef'\n * ```\n *\n * @example\n * ### Trimming Hex\n *\n * Hex values can be trimmed of zeroes using {@link ox#Hex.(trimLeft:function)} or {@link ox#Hex.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.trimLeft('0x00000000000000001234567890abcdef')\n * // @log: '0x1234567890abcdef'\n * ```\n *\n * @category Data\n */\nexport * as Hex from './core/Hex.js'\n\n/**\n * @category Execution Spec\n */\nexport * as Fee from './core/Fee.js'\n\n/**\n * Utility functions for working with JSON (with support for `bigint`).\n *\n * @example\n * ### Stringifying JSON\n *\n * JSON values can be stringified (with `bigint` support) using {@link ox#Json.(stringify:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}'\n * ```\n *\n * @example\n * ### Parsing JSON\n *\n * JSON values can be parsed (with `bigint` support) using {@link ox#Json.(parse:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const value = Json.parse('{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}')\n * // @log: { foo: 'bar', baz: 69420694206942069420694206942069420694206942069420n }\n * ```\n *\n * @category JSON\n */\nexport * as Json from './core/Json.js'\n\n/**\n * Utility functions for working with KZG Commitments.\n *\n * Mainly for [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\nexport * as Kzg from './core/Kzg.js'\n\n/**\n * Utilities & types for working with Logs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * :::tip\n *\n * Utilities for Log encoding & decoding can be found on the {@link ox#AbiEvent} module.\n *\n * :::\n *\n * @example\n * ### Converting from RPC Format\n *\n * Logs can be converted from their RPC format using {@link ox#Log.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nexport * as Log from './core/Log.js'\n\n/**\n * Utility functions for generating and working with [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) mnemonics.\n *\n * :::info\n *\n * The `Mnemonic` module is a friendly wrapper over [`@scure/bip39`](https://github.com/paulmillr/scure-bip39), an **audited** implementation of [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n *\n * :::\n *\n * @example\n * ### Generating a Random Mnemonic\n *\n * Random mnemonics can be generated using {@link ox#Mnemonic.(random:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @example\n * ### Converting to Private Key\n *\n * Mnemonics can be converted to a private key using {@link ox#Mnemonic.(toPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const privateKey = Mnemonic.toPrivateKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Converting to HD Key\n *\n * Mnemonics can be converted to a HD Key using {@link ox#Mnemonic.(toHdKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const hdKey = Mnemonic.toHdKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * ```\n *\n * @example\n * ### Converting to Seed\n *\n * Mnemonics can be converted to a master seed using {@link ox#Mnemonic.(toSeed:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @category Crypto\n */\nexport * as Mnemonic from './core/Mnemonic.js'\n\n/**\n * Utilities & types for working with [EIP-191 Personal Messages](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e)\n *\n * @example\n * ### Computing Sign Payload\n *\n * An EIP-191 personal sign payload can be computed using {@link ox#PersonalMessage.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\nexport * as PersonalMessage from './core/PersonalMessage.js'\n\n/**\n * Utilities & types for working with [EIP-1193 Providers](https://eips.ethereum.org/EIPS/eip-1193)\n *\n * @example\n * ### Instantiating External Providers\n *\n * External EIP-1193 Providers can be instantiated with {@link ox#Provider.(from:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating with an RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is also EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * Event emitters for EIP-1193 Providers can be created using {@link ox#Provider.(createEmitter:function)}:\n *\n * Useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @category Providers (EIP-1193)\n */\nexport * as Provider from './core/Provider.js'\n\n/**\n * Utility functions for working with ECDSA public keys.\n *\n * @example\n * ### Serializing Public Keys\n *\n * Public Keys can be serialized to Hex or Bytes using {@link ox#PublicKey.(toHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const serialized = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @example\n * ### Deserializing Public Keys\n *\n * Public Keys can be deserialized from Hex or Bytes using {@link ox#PublicKey.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @category Crypto\n */\nexport * as PublicKey from './core/PublicKey.js'\n\nexport type { Register } from './core/internal/register.js'\n\n/**\n * Utility functions for encoding and decoding [Recursive Length Prefix](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) structures.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Rlp } from 'ox'\n *\n * const data = Rlp.fromHex([Hex.fromString('hello'), Hex.fromString('world')])\n * // @log: '0xcc8568656c6c6f85776f726c64'\n *\n * const values = Rlp.toHex(data)\n * // @log: [Hex.fromString('hello'), Hex.fromString('world')]\n * ```\n *\n * @category Data\n */\nexport * as Rlp from './core/Rlp.js'\n\n/**\n * Utility types for working with Ethereum JSON-RPC namespaces & schemas.\n *\n * @category JSON-RPC\n */\nexport * as RpcSchema from './core/RpcSchema.js'\n\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Requests](https://www.jsonrpc.org/specification#request_object) and Ethereum JSON-RPC methods as\n * defined on the [Ethereum API specification](https://github.com/ethereum/execution-apis)\n *\n * @example\n * ### Instantiating a Request Store\n *\n * A Request Store can be instantiated using {@link ox#RpcRequest.(createStore:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @category JSON-RPC\n */\nexport * as RpcRequest from './core/RpcRequest.js'\n\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Responses](https://www.jsonrpc.org/specification#response_object)\n *\n * @example\n * ### Instantiating an RPC Response\n *\n * RPC Responses can be instantiated using {@link ox#RpcResponse.(from:function)}:\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * :::note\n *\n * Type-safe instantiation from a `request` object is also supported. If a `request` is provided, then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Parsing an RPC Response\n *\n * RPC Responses can be parsed using {@link ox#RpcResponse.(parse:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category JSON-RPC\n */\nexport * as RpcResponse from './core/RpcResponse.js'\n\n/**\n * Utility functions for working with JSON-RPC Transports.\n *\n * :::note\n * This is a convenience module distributed for experimenting with network connectivity on Ox.\n *\n * Consider using networking functionality from a higher-level library such as [Viem's Transports](https://viem.sh/docs/clients/transports/http)\n * if you need more features such as: retry logic, WebSockets/IPC, middleware, batch JSON-RPC, etc.\n * :::\n *\n * @example\n * ### HTTP Instantiation\n *\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @category JSON-RPC\n */\nexport * as RpcTransport from './core/RpcTransport.js'\n\n/**\n * Utility functions for [secp256k1](https://www.secg.org/sec2-v2.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `Secp256k1` module is a friendly wrapper over [`@noble/curves/secp256k1`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [secp256k1](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Secp256k1.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Secp256k1.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Secp256k1.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Secp256k1.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nexport * as Secp256k1 from './core/Secp256k1.js'\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `P256` module is a friendly wrapper over [`@noble/curves/p256`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [P256](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#P256.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#P256.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const publicKey = P256.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#P256.(verify:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = P256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nexport * as P256 from './core/P256.js'\n\n/**\n * Utility functions for working with ECDSA signatures.\n *\n * @example\n * ### Serializing a Signature\n *\n * Signatures can be serialized to Hex or Bytes using {@link ox#Signature.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @example\n * ### Deserializing a Signature\n *\n * Signatures can be deserialized from Hex or Bytes using {@link ox#Signature.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @category Crypto\n */\nexport * as Signature from './core/Signature.js'\n\n/**\n * Utility functions for working with\n * [EIP-4361: Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361)\n *\n * @example\n * ### Creating a SIWE Message\n *\n * SIWE messages can be created using {@link ox#Siwe.(createMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @example\n * ### Generating SIWE Nonces\n *\n * SIWE nonces can be generated using {@link ox#Siwe.(generateNonce:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @example\n * ### Parsing a SIWE Message\n *\n * SIWE messages can be parsed using {@link ox#Siwe.(parseMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @example\n * ### Validating a SIWE Message\n *\n * SIWE messages can be validated using {@link ox#Siwe.(validateMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @category Sign-In with Ethereum (EIP-4361)\n */\nexport * as Siwe from './core/Siwe.js'\n\nexport * as Solidity from './core/Solidity.js'\n\n/**\n * Utilities & types for working with **State Overrides**.\n *\n * @category Execution Spec\n */\nexport * as StateOverrides from './core/StateOverrides.js'\n\n/**\n * Utilities & types for working with **Transactions** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Transactions can be converted from RPC format using {@link ox#Transaction.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @category Execution Spec\n */\nexport * as Transaction from './core/Transaction.js'\n\n/**\n * Errors & Types for working with Transaction Envelopes.\n *\n * :::note\n * Refer to the following modules for specific Transaction Envelope types:\n * - [`TransactionEnvelopeLegacy`](/api/TransactionEnvelopeLegacy)\n * - [`TransactionEnvelopeEip1559`](/api/TransactionEnvelopeEip1559)\n * - [`TransactionEnvelopeEip2930`](/api/TransactionEnvelopeEip2930)\n * - [`TransactionEnvelopeEip4844`](/api/TransactionEnvelopeEip4844)\n * - [`TransactionEnvelopeEip7702`](/api/TransactionEnvelopeEip7702)\n * :::\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelope from './core/TransactionEnvelope.js'\n\n/**\n * Utility functions for working\n * with **Legacy Transaction Envelopes**.\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeLegacy.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeLegacy.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeLegacy.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeLegacy, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeLegacy.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeLegacy.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelopeLegacy from './core/TransactionEnvelopeLegacy.js'\n\n/**\n * Utility functions for working with [EIP-1559 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-1559)\n *\n *  @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip1559.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip1559.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip1559.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip1559, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip1559.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip1559.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelopeEip1559 from './core/TransactionEnvelopeEip1559.js'\n\n/**\n * Utility functions for working with [EIP-2930 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-2930)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip2930.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip2930.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip2930.(serialize:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip2930, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip2930.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip2930.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelopeEip2930 from './core/TransactionEnvelopeEip2930.js'\n\n/**\n * Utility functions for working with [EIP-4844 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-4844)\n *\n * @example\n * ### Instantiating Blobs\n *\n * Blobs can be instantiated using {@link ox#Blobs.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * ```\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip4844.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Hex, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip4844.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, {\n *   sidecars,\n *   signature\n * })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip4844.(serialize:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcTransport, TransactionEnvelopeEip4844, Secp256k1, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * // Compute the Blob Versioned Hashes.\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 0n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip4844.(hash:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelopeEip4844 from './core/TransactionEnvelopeEip4844.js'\n\n/**\n * Utility functions for working with [EIP-7702 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-7702)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip7702.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * :::tip\n *\n * See {@link ox#Authorization} for more details on instantiating and signing EIP-7702 Authorizations.\n *\n * :::\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip7702.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...', // [!code focus]\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { Authorization, RpcTransport, TransactionEnvelopeEip7702, Secp256k1, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\nexport * as TransactionEnvelopeEip7702 from './core/TransactionEnvelopeEip7702.js'\n\n/**\n * Utilities & types for working with **Transaction Receipts** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Receipts can be converted from RPC format using {@link ox#TransactionReceipt.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\nexport * as TransactionReceipt from './core/TransactionReceipt.js'\n\n/**\n * Utilities & types for working with **Transaction Requests** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4aca1d7a3e5aab24c8f6437131289ad386944eaa/src/schemas/transaction.yaml#L358-L423)\n *\n * @example\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({ // [!code focus]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]\n *   value: Value.fromEther('0.01'), // [!code focus]\n * }) // [!code focus]\n *\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [request],\n * })\n * ```\n *\n * @category Execution Spec\n */\nexport * as TransactionRequest from './core/TransactionRequest.js'\n\n/**\n * Utility functions for working with [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712)\n *\n * @example\n * ### Getting Sign Payloads\n *\n * Typed Data can be converted to a sign payload using {@link ox#TypedData.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\nexport * as TypedData from './core/TypedData.js'\n\n/**\n * Utilities & types for working with [EIP-191 Validator Data](https://eips.ethereum.org/EIPS/eip-191#0x00)\n *\n * @category Signed & Typed Data\n */\nexport * as ValidatorData from './core/ValidatorData.js'\n\n/**\n * Utility functions for displaying and parsing Ethereum Values as defined under **2.1. Value** in the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n *\n * const value = Value.fromEther('1')\n * // @log: 1_000_000_000_000_000_000n\n *\n * const formattedValue = Value.formatEther(value)\n * // @log: '1'\n *\n * const value = Value.fromEther('1', 'szabo')\n * // @log: 1_000_000n\n * ```\n *\n * @category Data\n */\nexport * as Value from './core/Value.js'\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Authentication API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API)\n *\n * @example\n * ### Creating Credentials\n *\n * Credentials can be created using {@link ox#WebAuthnP256.(createCredential:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebAuthnP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebAuthnP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nexport * as WebAuthnP256 from './core/WebAuthnP256.js'\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)\n *\n * @example\n * ### Creating Key Pairs\n *\n * Key pairs can be created using {@link ox#WebCryptoP256.(createKeyPair:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebCryptoP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebCryptoP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\nexport * as WebCryptoP256 from './core/WebCryptoP256.js'\n\n/**\n * Utilities & types for working with Withdrawals as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/withdrawal.yaml)\n *\n * @category Execution Spec\n */\nexport * as Withdrawal from './core/Withdrawal.js'\n"],"mappings":"AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAA,IAAA,MAmHqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,eAAA,MA0EgC,0BAA0B;AAAA,SAAAA,eAAA,IAA9CC,cAAc;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MAsE0B,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MAiH0B,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,YAAA,MA4F6B,uBAAuB;AAAA,SAAAA,YAAA,IAAxCC,WAAW;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,QAAA,MA4EyB,mBAAmB;AAAA,SAAAA,QAAA,IAAhCC,OAAO;AAEnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,cAAA,MAsG+B,yBAAyB;AAAA,SAAAA,cAAA,IAA5CC,aAAa;AAEzB;;;;;AAAA,YAAAC,WAAA,MAK4B,sBAAsB;AAAA,SAAAA,WAAA,IAAtCC,UAAU;AAEtB;;;;;AAAA,YAAAC,aAAA,MAK8B,wBAAwB;AAAA,SAAAA,aAAA,IAA1CC,YAAY;AAExB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,QAAA,MAqDyB,mBAAmB;AAAA,SAAAA,QAAA,IAAhCC,OAAO;AAEnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,OAAA,MAmCwB,kBAAkB;AAAA,SAAAA,OAAA,IAA9BC,MAAM;AAElB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,cAAA,MAwE+B,yBAAyB;AAAA,SAAAA,cAAA,IAA5CC,aAAa;AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,KAAA,MAqDwB,kBAAkB;AAAA,SAAAA,KAAA,IAA9BC,MAAM;AAElB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,MAAA,MAoDwB,kBAAkB;AAAA,SAAAA,MAAA,IAA9BC,MAAM;AAElB;;;;;AAAA,YAAAC,gBAAA,MAKiC,2BAA2B;AAAA,SAAAA,gBAAA,IAAhDC,eAAe;AAE3B;;;;;AAAA,YAAAC,MAAA,MAKuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,MAAA,MA8BuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAEjB;;;;;AAAA,YAAAC,eAAA,MAKgC,0BAA0B;AAAA,SAAAA,eAAA,IAA9CC,cAAc;AAE1B;;;;;AAAA,YAAAC,MAAA,MAKuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,IAAA,MAkHqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MA2C0B,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,MAAA,MA8HuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAAA,YAAAC,OAAA,MAEO,kBAAkB;AAAA,SAAAA,OAAA,IAA9BC,MAAM;AAElB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,gBAAA,MAoCiC,2BAA2B;AAAA,SAAAA,gBAAA,IAAhDC,eAAe;AAE3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,IAAA,MA6BqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAAA,YAAAC,OAAA,MAES,kBAAkB;AAAA,SAAAA,OAAA,IAA9BC,MAAM;AAElB;;;;;AAAA,YAAAC,OAAA,MAKwB,kBAAkB;AAAA,SAAAA,OAAA,IAA9BC,MAAM;AAElB;;;;;;;;;;;;;AAAA,YAAAC,KAAA,MAasB,gBAAgB;AAAA,SAAAA,KAAA,IAA1BC,IAAI;AAEhB;;;;;;;;;;;;AAAA,YAAAC,MAAA,MAYuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,IAAA,MAiHqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;AAAA,YAAAC,IAAA,MAGqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,KAAA,MAgCsB,gBAAgB;AAAA,SAAAA,KAAA,IAA1BC,IAAI;AAEhB;;;;;;;AAAA,YAAAC,IAAA,MAOqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,IAAA,MAyDqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MA2D0B,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;;;;;;;;;;;;;;AAAA,YAAAC,gBAAA,MAkBiC,2BAA2B;AAAA,SAAAA,gBAAA,IAAhDC,eAAe;AAE3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MAmF0B,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,UAAA,MAuC2B,qBAAqB;AAAA,SAAAA,UAAA,IAApCC,SAAS;AAIrB;;;;;;;;;;;;;;;;AAAA,YAAAC,IAAA,MAgBqB,eAAe;AAAA,SAAAA,IAAA,IAAxBC,GAAG;AAEf;;;;;AAAA,YAAAC,UAAA,MAK2B,qBAAqB;AAAA,SAAAA,UAAA,IAApCC,SAAS;AAErB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,WAAA,MAiC4B,sBAAsB;AAAA,SAAAA,WAAA,IAAtCC,UAAU;AAEtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,YAAA,MAiF6B,uBAAuB;AAAA,SAAAA,YAAA,IAAxCC,WAAW;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,aAAA,MAwB8B,wBAAwB;AAAA,SAAAA,aAAA,IAA1CC,YAAY;AAExB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,SAAA,MAuE2B,qBAAqB;AAAA,SAAAA,SAAA,IAApCC,SAAS;AAErB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,EAAA,MAuEsB,gBAAgB;AAAA,SAAAA,EAAA,IAA1BC,IAAI;AAEhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,UAAA,MAiC2B,qBAAqB;AAAA,SAAAA,UAAA,IAApCC,SAAS;AAErB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,KAAA,MAmGsB,gBAAgB;AAAA,SAAAA,KAAA,IAA1BC,IAAI;AAAA,YAAAC,SAAA,MAEU,oBAAoB;AAAA,SAAAA,SAAA,IAAlCC,QAAQ;AAEpB;;;;;AAAA,YAAAC,eAAA,MAKgC,0BAA0B;AAAA,SAAAA,eAAA,IAA9CC,cAAc;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,YAAA,MAqC6B,uBAAuB;AAAA,SAAAA,YAAA,IAAxCC,WAAW;AAEvB;;;;;;;;;;;;;;AAAA,YAAAC,oBAAA,MAcqC,+BAA+B;AAAA,SAAAA,oBAAA,IAAxDC,mBAAmB;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,0BAAA,MAyJ2C,qCAAqC;AAAA,SAAAA,0BAAA,IAApEC,yBAAyB;AAErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,uBAAA,MAqK4C,sCAAsC;AAAA,SAAAA,uBAAA,IAAtEC,0BAA0B;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,wBAAA,MA6J4C,sCAAsC;AAAA,SAAAA,wBAAA,IAAtEC,0BAA0B;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,wBAAA,MAsL4C,sCAAsC;AAAA,SAAAA,wBAAA,IAAtEC,0BAA0B;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,wBAAA,MAmI4C,sCAAsC;AAAA,SAAAA,wBAAA,IAAtEC,0BAA0B;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,mBAAA,MA2CoC,8BAA8B;AAAA,SAAAA,mBAAA,IAAtDC,kBAAkB;AAE9B;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,mBAAA,MAuBoC,8BAA8B;AAAA,SAAAA,mBAAA,IAAtDC,kBAAkB;AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,UAAA,MAgD2B,qBAAqB;AAAA,SAAAA,UAAA,IAApCC,SAAS;AAErB;;;;;AAAA,YAAAC,cAAA,MAK+B,yBAAyB;AAAA,SAAAA,cAAA,IAA5CC,aAAa;AAEzB;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,MAAA,MAoBuB,iBAAiB;AAAA,SAAAA,MAAA,IAA5BC,KAAK;AAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,UAAA,MAgF8B,wBAAwB;AAAA,SAAAA,UAAA,IAA1CC,YAAY;AAExB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,YAAAC,WAAA,MA+D+B,yBAAyB;AAAA,SAAAA,WAAA,IAA5CC,aAAa;AAEzB;;;;;AAAA,YAAAC,WAAA,MAK4B,sBAAsB;AAAA,SAAAA,WAAA,IAAtCC,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}