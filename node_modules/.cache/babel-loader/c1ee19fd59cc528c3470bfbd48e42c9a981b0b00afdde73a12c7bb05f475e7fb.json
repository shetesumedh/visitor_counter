{"ast":null,"code":"import { EventEmitter as j } from \"events\";\nimport { getAccountsFromNamespaces as O, getSdkError as x, isValidArray as y } from \"@walletconnect/utils\";\nimport { UniversalProvider as N } from \"@walletconnect/universal-provider\";\nconst $ = \"wc\",\n  k = \"ethereum_provider\",\n  q = `${$}@2:${k}:`,\n  U = \"https://rpc.walletconnect.org/v1/\",\n  f = [\"eth_sendTransaction\", \"personal_sign\"],\n  A = [\"eth_accounts\", \"eth_requestAccounts\", \"eth_sendRawTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"eth_sendTransaction\", \"personal_sign\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\", \"wallet_getPermissions\", \"wallet_requestPermissions\", \"wallet_registerOnboarding\", \"wallet_watchAsset\", \"wallet_scanQRCode\", \"wallet_sendCalls\", \"wallet_getCapabilities\", \"wallet_getCallsStatus\", \"wallet_showCallsStatus\"],\n  C = [\"chainChanged\", \"accountsChanged\"],\n  P = [\"chainChanged\", \"accountsChanged\", \"message\", \"disconnect\", \"connect\"],\n  D = async () => {\n    const {\n      createAppKit: s\n    } = await import(\"@reown/appkit/core\");\n    return s;\n  };\nvar z = Object.defineProperty,\n  L = Object.defineProperties,\n  K = Object.getOwnPropertyDescriptors,\n  M = Object.getOwnPropertySymbols,\n  Q = Object.prototype.hasOwnProperty,\n  V = Object.prototype.propertyIsEnumerable,\n  _ = (s, t, e) => t in s ? z(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  v = (s, t) => {\n    for (var e in t || (t = {})) Q.call(t, e) && _(s, e, t[e]);\n    if (M) for (var e of M(t)) V.call(t, e) && _(s, e, t[e]);\n    return s;\n  },\n  w = (s, t) => L(s, K(t)),\n  p = (s, t, e) => _(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction I(s) {\n  return Number(s[0].split(\":\")[1]);\n}\nfunction E(s) {\n  return `0x${s.toString(16)}`;\n}\nfunction G(s) {\n  const {\n    chains: t,\n    optionalChains: e,\n    methods: n,\n    optionalMethods: i,\n    events: a,\n    optionalEvents: o,\n    rpcMap: u\n  } = s;\n  if (!y(t)) throw new Error(\"Invalid chains\");\n  const c = {\n      chains: t,\n      methods: n || f,\n      events: a || C,\n      rpcMap: v({}, t.length ? {\n        [I(t)]: u[I(t)]\n      } : {})\n    },\n    l = a?.filter(d => !C.includes(d)),\n    r = n?.filter(d => !f.includes(d));\n  if (!e && !o && !i && !(l != null && l.length) && !(r != null && r.length)) return {\n    required: t.length ? c : void 0\n  };\n  const m = l?.length && r?.length || !e,\n    h = {\n      chains: [...new Set(m ? c.chains.concat(e || []) : e)],\n      methods: [...new Set(c.methods.concat(i != null && i.length ? i : A))],\n      events: [...new Set(c.events.concat(o != null && o.length ? o : P))],\n      rpcMap: u\n    };\n  return {\n    required: t.length ? c : void 0,\n    optional: e.length ? h : void 0\n  };\n}\nclass b {\n  constructor() {\n    p(this, \"events\", new j()), p(this, \"namespace\", \"eip155\"), p(this, \"accounts\", []), p(this, \"signer\"), p(this, \"chainId\", 1), p(this, \"modal\"), p(this, \"rpc\"), p(this, \"STORAGE_KEY\", q), p(this, \"on\", (t, e) => (this.events.on(t, e), this)), p(this, \"once\", (t, e) => (this.events.once(t, e), this)), p(this, \"removeListener\", (t, e) => (this.events.removeListener(t, e), this)), p(this, \"off\", (t, e) => (this.events.off(t, e), this)), p(this, \"parseAccount\", t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};\n  }\n  static async init(t) {\n    const e = new b();\n    return await e.initialize(t), e;\n  }\n  async request(t, e) {\n    return await this.signer.request(t, this.formatChainId(this.chainId), e);\n  }\n  sendAsync(t, e, n) {\n    this.signer.sendAsync(t, e, this.formatChainId(this.chainId), n);\n  }\n  get connected() {\n    return this.signer.client ? this.signer.client.core.relayer.connected : !1;\n  }\n  get connecting() {\n    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;\n  }\n  async enable() {\n    return this.session || (await this.connect()), await this.request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  async connect(t) {\n    var e;\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts(t);\n    const {\n      required: n,\n      optional: i\n    } = G(this.rpc);\n    try {\n      const a = await new Promise(async (u, c) => {\n        var l, r;\n        this.rpc.showQrModal && ((l = this.modal) == null || l.open(), (r = this.modal) == null || r.subscribeState(h => {\n          !h.open && !this.signer.session && (this.signer.abortPairingAttempt(), c(new Error(\"Connection request reset. Please try again.\")));\n        }));\n        const m = t != null && t.scopedProperties ? {\n          [this.namespace]: t.scopedProperties\n        } : void 0;\n        await this.signer.connect(w(v({\n          namespaces: v({}, n && {\n            [this.namespace]: n\n          })\n        }, i && {\n          optionalNamespaces: {\n            [this.namespace]: i\n          }\n        }), {\n          pairingTopic: t?.pairingTopic,\n          scopedProperties: m\n        })).then(h => {\n          u(h);\n        }).catch(h => {\n          var d;\n          (d = this.modal) == null || d.showErrorMessage(\"Unable to connect\"), c(new Error(h.message));\n        });\n      });\n      if (!a) return;\n      const o = O(a.namespaces, [this.namespace]);\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o), this.setAccounts(o), this.events.emit(\"connect\", {\n        chainId: E(this.chainId)\n      });\n    } catch (a) {\n      throw this.signer.logger.error(a), a;\n    } finally {\n      (e = this.modal) == null || e.close();\n    }\n  }\n  async authenticate(t, e) {\n    var n;\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts({\n      chains: t?.chains\n    });\n    try {\n      const i = await new Promise(async (o, u) => {\n          var c, l;\n          this.rpc.showQrModal && ((c = this.modal) == null || c.open(), (l = this.modal) == null || l.subscribeState(r => {\n            !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), u(new Error(\"Connection request reset. Please try again.\")));\n          })), await this.signer.authenticate(w(v({}, t), {\n            chains: this.rpc.chains\n          }), e).then(r => {\n            o(r);\n          }).catch(r => {\n            var m;\n            (m = this.modal) == null || m.showErrorMessage(\"Unable to connect\"), u(new Error(r.message));\n          });\n        }),\n        a = i.session;\n      if (a) {\n        const o = O(a.namespaces, [this.namespace]);\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o), this.setAccounts(o), this.events.emit(\"connect\", {\n          chainId: E(this.chainId)\n        });\n      }\n      return i;\n    } catch (i) {\n      throw this.signer.logger.error(i), i;\n    } finally {\n      (n = this.modal) == null || n.close();\n    }\n  }\n  async disconnect() {\n    this.session && (await this.signer.disconnect()), this.reset();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  get session() {\n    return this.signer.session;\n  }\n  registerEventListeners() {\n    this.signer.on(\"session_event\", t => {\n      const {\n          params: e\n        } = t,\n        {\n          event: n\n        } = e;\n      n.name === \"accountsChanged\" ? (this.accounts = this.parseAccounts(n.data), this.events.emit(\"accountsChanged\", this.accounts)) : n.name === \"chainChanged\" ? this.setChainId(this.formatChainId(n.data)) : this.events.emit(n.name, n.data), this.events.emit(\"session_event\", t);\n    }), this.signer.on(\"accountsChanged\", t => {\n      this.accounts = this.parseAccounts(t), this.events.emit(\"accountsChanged\", this.accounts);\n    }), this.signer.on(\"chainChanged\", t => {\n      const e = parseInt(t);\n      this.chainId = e, this.events.emit(\"chainChanged\", E(this.chainId)), this.persist();\n    }), this.signer.on(\"session_update\", t => {\n      this.events.emit(\"session_update\", t);\n    }), this.signer.on(\"session_delete\", t => {\n      this.reset(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", w(v({}, x(\"USER_DISCONNECTED\")), {\n        data: t.topic,\n        name: \"USER_DISCONNECTED\"\n      }));\n    }), this.signer.on(\"display_uri\", t => {\n      this.events.emit(\"display_uri\", t);\n    });\n  }\n  switchEthereumChain(t) {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: t.toString(16)\n      }]\n    });\n  }\n  isCompatibleChainId(t) {\n    return typeof t == \"string\" ? t.startsWith(`${this.namespace}:`) : !1;\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${t}`;\n  }\n  parseChainId(t) {\n    return Number(t.split(\":\")[1]);\n  }\n  setChainIds(t) {\n    const e = t.filter(n => this.isCompatibleChainId(n)).map(n => this.parseChainId(n));\n    e.length && (this.chainId = e[0], this.events.emit(\"chainChanged\", E(this.chainId)), this.persist());\n  }\n  setChainId(t) {\n    if (this.isCompatibleChainId(t)) {\n      const e = this.parseChainId(t);\n      this.chainId = e, this.switchEthereumChain(e);\n    }\n  }\n  parseAccountId(t) {\n    const [e, n, i] = t.split(\":\");\n    return {\n      chainId: `${e}:${n}`,\n      address: i\n    };\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(e => this.parseChainId(this.parseAccountId(e).chainId) === this.chainId).map(e => this.parseAccountId(e).address), this.events.emit(\"accountsChanged\", this.accounts);\n  }\n  getRpcConfig(t) {\n    var e, n;\n    const i = (e = t?.chains) != null ? e : [],\n      a = (n = t?.optionalChains) != null ? n : [],\n      o = i.concat(a);\n    if (!o.length) throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const u = i.length ? t?.methods || f : [],\n      c = i.length ? t?.events || C : [],\n      l = t?.optionalMethods || [],\n      r = t?.optionalEvents || [],\n      m = t?.rpcMap || this.buildRpcMap(o, t.projectId),\n      h = t?.qrModalOptions || void 0;\n    return {\n      chains: i?.map(d => this.formatChainId(d)),\n      optionalChains: a.map(d => this.formatChainId(d)),\n      methods: u,\n      events: c,\n      optionalMethods: l,\n      optionalEvents: r,\n      rpcMap: m,\n      showQrModal: !!(t != null && t.showQrModal),\n      qrModalOptions: h,\n      projectId: t.projectId,\n      metadata: t.metadata\n    };\n  }\n  buildRpcMap(t, e) {\n    const n = {};\n    return t.forEach(i => {\n      n[i] = this.getRpcUrl(i, e);\n    }), n;\n  }\n  async initialize(t) {\n    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? I(this.rpc.chains) : I(this.rpc.optionalChains), this.signer = await N.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: t.disableProviderPing,\n      relayUrl: t.relayUrl,\n      storage: t.storage,\n      storageOptions: t.storageOptions,\n      customStoragePrefix: t.customStoragePrefix,\n      telemetryEnabled: t.telemetryEnabled,\n      logger: t.logger\n    }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {\n      let e;\n      try {\n        const n = await D(),\n          {\n            convertWCMToAppKitOptions: i\n          } = await Promise.resolve().then(function () {\n            return nt;\n          }),\n          a = i(w(v({}, this.rpc.qrModalOptions), {\n            chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],\n            metadata: this.rpc.metadata,\n            projectId: this.rpc.projectId\n          }));\n        if (!a.networks.length) throw new Error(\"No networks found for WalletConnect\\xB7\");\n        e = n(w(v({}, a), {\n          universalProvider: this.signer,\n          manualWCControl: !0\n        }));\n      } catch (n) {\n        throw console.warn(n), new Error(\"To use QR modal, please install @reown/appkit package\");\n      }\n      if (e) try {\n        this.modal = e;\n      } catch (n) {\n        throw this.signer.logger.error(n), new Error(\"Could not generate WalletConnectModal Instance\");\n      }\n    }\n  }\n  loadConnectOpts(t) {\n    if (!t) return;\n    const {\n      chains: e,\n      optionalChains: n,\n      rpcMap: i\n    } = t;\n    e && y(e) && (this.rpc.chains = e.map(a => this.formatChainId(a)), e.forEach(a => {\n      this.rpc.rpcMap[a] = i?.[a] || this.getRpcUrl(a);\n    })), n && y(n) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n?.map(a => this.formatChainId(a)), n.forEach(a => {\n      this.rpc.rpcMap[a] = i?.[a] || this.getRpcUrl(a);\n    }));\n  }\n  getRpcUrl(t, e) {\n    var n;\n    return ((n = this.rpc.rpcMap) == null ? void 0 : n[t]) || `${U}?chainId=eip155:${t}&projectId=${e || this.rpc.projectId}`;\n  }\n  async loadPersistedSession() {\n    if (this.session) try {\n      const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),\n        e = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];\n      this.setChainIds(t ? [this.formatChainId(t)] : e?.accounts), this.setAccounts(e?.accounts);\n    } catch (t) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\"), this.signer.logger.error(t), await this.disconnect().catch(e => this.signer.logger.warn(e));\n    }\n  }\n  reset() {\n    this.chainId = 1, this.accounts = [];\n  }\n  persist() {\n    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n  parseAccounts(t) {\n    return typeof t == \"string\" || t instanceof String ? [this.parseAccount(t)] : t.map(e => this.parseAccount(e));\n  }\n}\nconst Y = b;\nvar H = Object.defineProperty,\n  B = Object.defineProperties,\n  F = Object.getOwnPropertyDescriptors,\n  S = Object.getOwnPropertySymbols,\n  X = Object.prototype.hasOwnProperty,\n  J = Object.prototype.propertyIsEnumerable,\n  T = (s, t, e) => t in s ? H(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  R = (s, t) => {\n    for (var e in t || (t = {})) X.call(t, e) && T(s, e, t[e]);\n    if (S) for (var e of S(t)) J.call(t, e) && T(s, e, t[e]);\n    return s;\n  },\n  Z = (s, t) => B(s, F(t));\nfunction tt(s) {\n  if (s) return {\n    \"--w3m-font-family\": s[\"--wcm-font-family\"],\n    \"--w3m-accent\": s[\"--wcm-accent-color\"],\n    \"--w3m-color-mix\": s[\"--wcm-background-color\"],\n    \"--w3m-z-index\": s[\"--wcm-z-index\"] ? Number(s[\"--wcm-z-index\"]) : void 0,\n    \"--w3m-qr-color\": s[\"--wcm-accent-color\"],\n    \"--w3m-font-size-master\": s[\"--wcm-text-medium-regular-size\"],\n    \"--w3m-border-radius-master\": s[\"--wcm-container-border-radius\"],\n    \"--w3m-color-mix-strength\": 0\n  };\n}\nconst et = s => {\n  const [t, e] = s.split(\":\");\n  return W({\n    id: e,\n    caipNetworkId: s,\n    chainNamespace: t,\n    name: \"\",\n    nativeCurrency: {\n      name: \"\",\n      symbol: \"\",\n      decimals: 8\n    },\n    rpcUrls: {\n      default: {\n        http: [\"https://rpc.walletconnect.org/v1\"]\n      }\n    }\n  });\n};\nfunction st(s) {\n  var t, e, n, i, a, o, u;\n  const c = (t = s.chains) == null ? void 0 : t.map(et).filter(Boolean);\n  if (c.length === 0) throw new Error(\"At least one chain must be specified\");\n  const l = c.find(m => {\n      var h;\n      return m.id === ((h = s.defaultChain) == null ? void 0 : h.id);\n    }),\n    r = {\n      projectId: s.projectId,\n      networks: c,\n      themeMode: s.themeMode,\n      themeVariables: tt(s.themeVariables),\n      chainImages: s.chainImages,\n      connectorImages: s.walletImages,\n      defaultNetwork: l,\n      metadata: Z(R({}, s.metadata), {\n        name: ((e = s.metadata) == null ? void 0 : e.name) || \"WalletConnect\",\n        description: ((n = s.metadata) == null ? void 0 : n.description) || \"Connect to WalletConnect-compatible wallets\",\n        url: ((i = s.metadata) == null ? void 0 : i.url) || \"https://walletconnect.org\",\n        icons: ((a = s.metadata) == null ? void 0 : a.icons) || [\"https://walletconnect.org/walletconnect-logo.png\"]\n      }),\n      showWallets: !0,\n      featuredWalletIds: s.explorerRecommendedWalletIds === \"NONE\" ? [] : Array.isArray(s.explorerRecommendedWalletIds) ? s.explorerRecommendedWalletIds : [],\n      excludeWalletIds: s.explorerExcludedWalletIds === \"ALL\" ? [] : Array.isArray(s.explorerExcludedWalletIds) ? s.explorerExcludedWalletIds : [],\n      enableEIP6963: !1,\n      enableInjected: !1,\n      enableCoinbase: !0,\n      enableWalletConnect: !0,\n      features: {\n        email: !1,\n        socials: !1\n      }\n    };\n  if ((o = s.mobileWallets) != null && o.length || (u = s.desktopWallets) != null && u.length) {\n    const m = [...(s.mobileWallets || []).map(g => ({\n        id: g.id,\n        name: g.name,\n        links: g.links\n      })), ...(s.desktopWallets || []).map(g => ({\n        id: g.id,\n        name: g.name,\n        links: {\n          native: g.links.native,\n          universal: g.links.universal\n        }\n      }))],\n      h = [...(r.featuredWalletIds || []), ...(r.excludeWalletIds || [])],\n      d = m.filter(g => !h.includes(g.id));\n    d.length && (r.customWallets = d);\n  }\n  return r;\n}\nfunction W(s) {\n  return R({\n    formatters: void 0,\n    fees: void 0,\n    serializers: void 0\n  }, s);\n}\nvar nt = Object.freeze({\n  __proto__: null,\n  convertWCMToAppKitOptions: st,\n  defineChain: W\n});\nexport { Y as EthereumProvider, P as OPTIONAL_EVENTS, A as OPTIONAL_METHODS, C as REQUIRED_EVENTS, f as REQUIRED_METHODS, b as default };","map":{"version":3,"names":[],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/constants/values.ts","/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/constants/rpc.ts","/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/utils/appkit.ts","/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/EthereumProvider.ts","/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/index.ts","/home/sumedhshete/visitor-counter/frontend/node_modules/@walletconnect/ethereum-provider/src/wcmToAppKit.ts"],"sourcesContent":["export const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"ethereum_provider\";\nexport const STORAGE_KEY = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n","export const REQUIRED_METHODS = [\"eth_sendTransaction\", \"personal_sign\"];\nexport const OPTIONAL_METHODS = [\n  \"eth_accounts\",\n  \"eth_requestAccounts\",\n  \"eth_sendRawTransaction\",\n  \"eth_sign\",\n  \"eth_signTransaction\",\n  \"eth_signTypedData\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData_v4\",\n  \"eth_sendTransaction\",\n  \"personal_sign\",\n  \"wallet_switchEthereumChain\",\n  \"wallet_addEthereumChain\",\n  \"wallet_getPermissions\",\n  \"wallet_requestPermissions\",\n  \"wallet_registerOnboarding\",\n  \"wallet_watchAsset\",\n  \"wallet_scanQRCode\",\n  \"wallet_sendCalls\",\n  \"wallet_getCapabilities\",\n  \"wallet_getCallsStatus\",\n  \"wallet_showCallsStatus\",\n];\nexport const REQUIRED_EVENTS = [\"chainChanged\", \"accountsChanged\"];\nexport const OPTIONAL_EVENTS = [\n  \"chainChanged\",\n  \"accountsChanged\",\n  \"message\",\n  \"disconnect\",\n  \"connect\",\n];\n","export const getAppkit = async () => {\n  const { createAppKit } = await import(\"@reown/appkit/core\");\n  return createAppKit;\n};\n","import { EventEmitter } from \"events\";\nimport { getAccountsFromNamespaces, getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\nimport {\n  IEthereumProvider as IProvider,\n  IEthereumProviderEvents,\n  ProviderAccounts,\n  RequestArguments,\n  QrModalOptions,\n} from \"./types\";\nimport {\n  Metadata,\n  Namespace,\n  UniversalProvider,\n  UniversalProviderOpts,\n} from \"@walletconnect/universal-provider\";\nimport { AuthTypes, SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport {\n  STORAGE_KEY,\n  REQUIRED_METHODS,\n  REQUIRED_EVENTS,\n  RPC_URL,\n  OPTIONAL_METHODS,\n  OPTIONAL_EVENTS,\n} from \"./constants\";\nimport { getAppkit } from \"./utils/appkit\";\n\nexport type RpcMethod =\n  | \"personal_sign\"\n  | \"eth_sendTransaction\"\n  | \"eth_accounts\"\n  | \"eth_requestAccounts\"\n  | \"eth_call\"\n  | \"eth_getBalance\"\n  | \"eth_sendRawTransaction\"\n  | \"eth_sign\"\n  | \"eth_signTransaction\"\n  | \"eth_signTypedData\"\n  | \"eth_signTypedData_v3\"\n  | \"eth_signTypedData_v4\"\n  | \"wallet_switchEthereumChain\"\n  | \"wallet_addEthereumChain\"\n  | \"wallet_getPermissions\"\n  | \"wallet_requestPermissions\"\n  | \"wallet_registerOnboarding\"\n  | \"wallet_watchAsset\"\n  | \"wallet_scanQRCode\"\n  | \"wallet_sendCalls\"\n  | \"wallet_getCapabilities\"\n  | \"wallet_getCallsStatus\"\n  | \"wallet_showCallsStatus\";\n\nexport type RpcEvent = \"accountsChanged\" | \"chainChanged\" | \"message\" | \"disconnect\" | \"connect\";\n\nexport interface EthereumRpcMap {\n  [chainId: string]: string;\n}\n\nexport interface SessionEvent {\n  event: { name: string; data: any };\n  chainId: string;\n}\n\nexport interface EthereumRpcConfig {\n  chains: string[];\n  optionalChains: string[];\n  methods: string[];\n  optionalMethods?: string[];\n  /**\n   * @description Events that the wallet MUST support or the connection will be rejected\n   */\n  events: string[];\n  optionalEvents?: string[];\n  rpcMap: EthereumRpcMap;\n  projectId: string;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n}\nexport interface ConnectOps {\n  chains?: number[];\n  optionalChains?: number[];\n  rpcMap?: EthereumRpcMap;\n  pairingTopic?: string;\n  scopedProperties?: unknown;\n}\n\nexport type AuthenticateParams = {\n  chains?: number[];\n} & Omit<AuthTypes.SessionAuthenticateParams, \"chains\">;\n\nexport interface IEthereumProvider extends IProvider {\n  connect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n  return `0x${chainId.toString(16)}`;\n}\n\nexport type NamespacesParams = {\n  chains: EthereumRpcConfig[\"chains\"];\n  optionalChains: EthereumRpcConfig[\"optionalChains\"];\n  methods?: EthereumRpcConfig[\"methods\"];\n  optionalMethods?: EthereumRpcConfig[\"methods\"];\n  events?: EthereumRpcConfig[\"events\"];\n  rpcMap: EthereumRpcConfig[\"rpcMap\"];\n  optionalEvents?: EthereumRpcConfig[\"events\"];\n};\n\nexport function buildNamespaces(params: NamespacesParams): {\n  required?: Namespace;\n  optional?: Namespace;\n} {\n  const { chains, optionalChains, methods, optionalMethods, events, optionalEvents, rpcMap } =\n    params;\n  if (!isValidArray(chains)) {\n    throw new Error(\"Invalid chains\");\n  }\n\n  const required: Namespace = {\n    chains,\n    methods: methods || REQUIRED_METHODS,\n    events: events || REQUIRED_EVENTS,\n    rpcMap: {\n      ...(chains.length\n        ? { [getEthereumChainId(chains)]: rpcMap[getEthereumChainId(chains)] }\n        : {}),\n    },\n  };\n\n  // make a list of events and methods that require additional permissions\n  // so we know if we should to include the required chains in the optional namespace\n  const eventsRequiringPermissions = events?.filter((event) => !REQUIRED_EVENTS.includes(event));\n  const methodsRequiringPermissions = methods?.filter((event) => !REQUIRED_METHODS.includes(event));\n\n  if (\n    !optionalChains &&\n    !optionalEvents &&\n    !optionalMethods &&\n    !eventsRequiringPermissions?.length &&\n    !methodsRequiringPermissions?.length\n  ) {\n    return { required: chains.length ? required : undefined };\n  }\n\n  /*\n   * decides whether or not to include the required chains in the optional namespace\n   * use case: if there is a single chain as required but additional methods/events as optional\n   */\n  const shouldIncludeRequiredChains =\n    (eventsRequiringPermissions?.length && methodsRequiringPermissions?.length) || !optionalChains;\n\n  const optional: Namespace = {\n    chains: [\n      ...new Set(\n        shouldIncludeRequiredChains ? required.chains.concat(optionalChains || []) : optionalChains,\n      ),\n    ],\n    methods: [\n      ...new Set(\n        required.methods.concat(optionalMethods?.length ? optionalMethods : OPTIONAL_METHODS),\n      ),\n    ],\n    events: [\n      ...new Set(required.events.concat(optionalEvents?.length ? optionalEvents : OPTIONAL_EVENTS)),\n    ],\n    rpcMap,\n  };\n\n  return {\n    required: chains.length ? required : undefined,\n    optional: optionalChains.length ? optional : undefined,\n  };\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n  | {\n      chains: ArrayOneOrMore<number>;\n      optionalChains?: number[];\n    }\n  | {\n      chains?: number[];\n      optionalChains: ArrayOneOrMore<number>;\n    };\n\nexport type EthereumProviderOptions = {\n  projectId: string;\n  /**\n   * @note Methods that your app intents to use and the peer MUST support. If the peer does not support these methods, the connection will be rejected.\n   * @default [\"eth_sendTransaction\", \"personal_sign\"]\n   */\n  methods?: string[];\n  /**\n   * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n   */\n  optionalMethods?: string[];\n  events?: string[];\n  optionalEvents?: string[];\n  rpcMap?: EthereumRpcMap;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n  disableProviderPing?: boolean;\n  relayUrl?: string;\n  storageOptions?: KeyValueStorageOptions;\n} & ChainsProps &\n  UniversalProviderOpts;\n\nexport class EthereumProvider implements IEthereumProvider {\n  public events = new EventEmitter();\n  public namespace = \"eip155\";\n  public accounts: string[] = [];\n  public signer: InstanceType<typeof UniversalProvider>;\n  public chainId = 1;\n  public modal?: any;\n\n  protected rpc: EthereumRpcConfig;\n  protected readonly STORAGE_KEY = STORAGE_KEY;\n\n  constructor() {\n    // assigned during initialize\n    this.signer = {} as InstanceType<typeof UniversalProvider>;\n    this.rpc = {} as EthereumRpcConfig;\n  }\n\n  static async init(opts: EthereumProviderOptions): Promise<EthereumProvider> {\n    const provider = new EthereumProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  public async request<T = unknown>(args: RequestArguments, expiry?: number): Promise<T> {\n    return await this.signer.request(args, this.formatChainId(this.chainId), expiry);\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    expiry?: number,\n  ): void {\n    this.signer.sendAsync(args, callback, this.formatChainId(this.chainId), expiry);\n  }\n\n  get connected(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connected;\n  }\n\n  get connecting(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connecting;\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.session) await this.connect();\n    const accounts = await this.request({ method: \"eth_requestAccounts\" });\n    return accounts as ProviderAccounts;\n  }\n\n  public async connect(opts?: ConnectOps): Promise<void> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts(opts);\n    const { required, optional } = buildNamespaces(this.rpc);\n    try {\n      const session = await new Promise<SessionTypes.Struct | undefined>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          const scopedProperties = opts?.scopedProperties\n            ? { [this.namespace]: opts.scopedProperties }\n            : undefined;\n\n          await this.signer\n            .connect({\n              namespaces: {\n                ...(required && {\n                  [this.namespace]: required,\n                }),\n              },\n              ...(optional && {\n                optionalNamespaces: {\n                  [this.namespace]: optional,\n                },\n              }),\n              pairingTopic: opts?.pairingTopic,\n              scopedProperties,\n            })\n            .then((session?: SessionTypes.Struct) => {\n              resolve(session);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      if (!session) return;\n\n      const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n      // if no required chains are set, use the approved accounts to fetch chainIds\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n      this.setAccounts(accounts);\n      this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async authenticate(\n    params: AuthenticateParams,\n    walletUniversalLink?: string,\n  ): Promise<AuthTypes.AuthenticateResponseResult | undefined> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts({\n      chains: params?.chains,\n    });\n\n    try {\n      const result = await new Promise<AuthTypes.AuthenticateResponseResult>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          await this.signer\n            .authenticate(\n              {\n                ...params,\n                chains: this.rpc.chains,\n              },\n              walletUniversalLink,\n            )\n            .then((result: AuthTypes.AuthenticateResponseResult) => {\n              resolve(result);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      const session = result.session;\n      if (session) {\n        const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n        // if no required chains are set, use the approved accounts to fetch chainIds as both contain <namespace>:<chainId>\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n        this.setAccounts(accounts);\n\n        this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n      }\n\n      return result;\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (this.session) {\n      await this.signer.disconnect();\n    }\n    this.reset();\n  }\n\n  public on: IEthereumProviderEvents[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n    return this;\n  };\n\n  public once: IEthereumProviderEvents[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n    return this;\n  };\n\n  public removeListener: IEthereumProviderEvents[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n    return this;\n  };\n\n  public off: IEthereumProviderEvents[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n    return this;\n  };\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  // ---------- Protected --------------------------------------------- //\n\n  protected registerEventListeners() {\n    this.signer.on(\"session_event\", (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      const { params } = payload;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.accounts = this.parseAccounts(event.data);\n        this.events.emit(\"accountsChanged\", this.accounts);\n      } else if (event.name === \"chainChanged\") {\n        this.setChainId(this.formatChainId(event.data));\n      } else {\n        this.events.emit(event.name as any, event.data);\n      }\n      this.events.emit(\"session_event\", payload);\n    });\n\n    this.signer.on(\"accountsChanged\", (accounts: string[]) => {\n      this.accounts = this.parseAccounts(accounts);\n      this.events.emit(\"accountsChanged\", this.accounts);\n    });\n\n    this.signer.on(\"chainChanged\", (chainId: string) => {\n      const chain = parseInt(chainId);\n      this.chainId = chain;\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    });\n\n    this.signer.on(\n      \"session_update\",\n      (payload: SignClientTypes.EventArguments[\"session_update\"]) => {\n        this.events.emit(\"session_update\", payload);\n      },\n    );\n\n    this.signer.on(\n      \"session_delete\",\n      (payload: SignClientTypes.EventArguments[\"session_delete\"]) => {\n        this.reset();\n        this.events.emit(\"session_delete\", payload);\n        this.events.emit(\"disconnect\", {\n          ...getSdkError(\"USER_DISCONNECTED\"),\n          data: payload.topic,\n          name: \"USER_DISCONNECTED\",\n        });\n      },\n    );\n\n    this.signer.on(\"display_uri\", (uri: string) => {\n      this.events.emit(\"display_uri\", uri);\n    });\n  }\n\n  protected switchEthereumChain(chainId: number): void {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainId.toString(16) }],\n    });\n  }\n\n  protected isCompatibleChainId(chainId: string): boolean {\n    return typeof chainId === \"string\" ? chainId.startsWith(`${this.namespace}:`) : false;\n  }\n\n  protected formatChainId(chainId: number): string {\n    return `${this.namespace}:${chainId}`;\n  }\n\n  protected parseChainId(chainId: string): number {\n    return Number(chainId.split(\":\")[1]);\n  }\n\n  protected setChainIds(chains: string[]) {\n    const compatible = chains.filter((x) => this.isCompatibleChainId(x));\n    const chainIds = compatible.map((c) => this.parseChainId(c));\n    if (chainIds.length) {\n      this.chainId = chainIds[0];\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    }\n  }\n\n  protected setChainId(chain: string) {\n    if (this.isCompatibleChainId(chain)) {\n      const chainId = this.parseChainId(chain);\n      this.chainId = chainId;\n      this.switchEthereumChain(chainId);\n    }\n  }\n\n  protected parseAccountId(account: string): { chainId: string; address: string } {\n    const [namespace, reference, address] = account.split(\":\");\n    const chainId = `${namespace}:${reference}`;\n    return { chainId, address };\n  }\n\n  protected setAccounts(accounts: string[]) {\n    this.accounts = accounts\n      .filter((x) => this.parseChainId(this.parseAccountId(x).chainId) === this.chainId)\n      .map((x) => this.parseAccountId(x).address);\n    this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  protected getRpcConfig(opts: EthereumProviderOptions): EthereumRpcConfig {\n    const requiredChains = opts?.chains ?? [];\n    const optionalChains = opts?.optionalChains ?? [];\n    const allChains = requiredChains.concat(optionalChains);\n    if (!allChains.length)\n      throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const requiredMethods = requiredChains.length ? opts?.methods || REQUIRED_METHODS : [];\n    const requiredEvents = requiredChains.length ? opts?.events || REQUIRED_EVENTS : [];\n    const optionalMethods = opts?.optionalMethods || [];\n    const optionalEvents = opts?.optionalEvents || [];\n    const rpcMap = opts?.rpcMap || this.buildRpcMap(allChains, opts.projectId);\n    const qrModalOptions = opts?.qrModalOptions || undefined;\n    return {\n      chains: requiredChains?.map((chain: number) => this.formatChainId(chain)),\n      optionalChains: optionalChains.map((chain: number) => this.formatChainId(chain)),\n      methods: requiredMethods,\n      events: requiredEvents,\n      optionalMethods,\n      optionalEvents,\n      rpcMap,\n      showQrModal: Boolean(opts?.showQrModal),\n      qrModalOptions,\n      projectId: opts.projectId,\n      metadata: opts.metadata,\n    };\n  }\n\n  protected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n    const map: EthereumRpcMap = {};\n    chains.forEach((chain) => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n\n  protected async initialize(opts: EthereumProviderOptions) {\n    this.rpc = this.getRpcConfig(opts);\n\n    this.chainId = this.rpc.chains.length\n      ? getEthereumChainId(this.rpc.chains)\n      : getEthereumChainId(this.rpc.optionalChains);\n    this.signer = await UniversalProvider.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: opts.disableProviderPing,\n      relayUrl: opts.relayUrl,\n      storage: opts.storage,\n      storageOptions: opts.storageOptions,\n      customStoragePrefix: opts.customStoragePrefix,\n      telemetryEnabled: opts.telemetryEnabled,\n      logger: opts.logger,\n    });\n    this.registerEventListeners();\n    await this.loadPersistedSession();\n    if (this.rpc.showQrModal) {\n      let appKit;\n      try {\n        const createAppKit = await getAppkit();\n        const { convertWCMToAppKitOptions } = await import(\"./wcmToAppKit\");\n        const options = convertWCMToAppKitOptions({\n          ...this.rpc.qrModalOptions,\n          chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],\n          metadata: this.rpc.metadata,\n          projectId: this.rpc.projectId,\n        });\n\n        if (!options.networks.length) {\n          throw new Error(\"No networks found for WalletConnectÂ·\");\n        }\n\n        appKit = createAppKit({\n          ...options,\n          universalProvider: this.signer as any,\n          manualWCControl: true,\n        });\n      } catch (e) {\n        console.warn(e);\n        throw new Error(\"To use QR modal, please install @reown/appkit package\");\n      }\n      if (appKit) {\n        try {\n          this.modal = appKit;\n        } catch (e) {\n          this.signer.logger.error(e);\n          throw new Error(\"Could not generate WalletConnectModal Instance\");\n        }\n      }\n    }\n  }\n\n  protected loadConnectOpts(opts?: ConnectOps) {\n    if (!opts) return;\n    const { chains, optionalChains, rpcMap } = opts;\n    if (chains && isValidArray(chains)) {\n      this.rpc.chains = chains.map((chain) => this.formatChainId(chain));\n      chains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n    if (optionalChains && isValidArray(optionalChains)) {\n      this.rpc.optionalChains = [];\n      this.rpc.optionalChains = optionalChains?.map((chain) => this.formatChainId(chain));\n      optionalChains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n  }\n\n  protected getRpcUrl(chainId: number, projectId?: string): string {\n    const providedRpc = this.rpc.rpcMap?.[chainId];\n    return (\n      providedRpc ||\n      `${RPC_URL}?chainId=eip155:${chainId}&projectId=${projectId || this.rpc.projectId}`\n    );\n  }\n\n  protected async loadPersistedSession() {\n    if (!this.session) return;\n    try {\n      const chainId = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n\n      // cater to both inline & nested namespace formats\n      const namespace = this.session.namespaces[`${this.namespace}:${chainId}`]\n        ? this.session.namespaces[`${this.namespace}:${chainId}`]\n        : this.session.namespaces[this.namespace];\n\n      this.setChainIds(chainId ? [this.formatChainId(chainId)] : namespace?.accounts);\n      this.setAccounts(namespace?.accounts);\n    } catch (error) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\");\n      this.signer.logger.error(error);\n      await this.disconnect().catch((error) => this.signer.logger.warn(error));\n    }\n  }\n\n  protected reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n\n  protected persist() {\n    if (!this.session) return;\n    this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  protected parseAccounts(payload: string | string[]): string[] {\n    if (typeof payload === \"string\" || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map((account: string) => this.parseAccount(account));\n  }\n\n  protected parseAccount = (payload: any): string => {\n    return this.isCompatibleChainId(payload) ? this.parseAccountId(payload).address : payload;\n  };\n}\n\nexport default EthereumProvider;\n","import { EthereumProvider as Provider } from \"./EthereumProvider\";\nexport const EthereumProvider = Provider;\nexport type { EthereumProviderOptions, RpcEvent, RpcMethod } from \"./EthereumProvider\";\nexport * from \"./constants/rpc\";\nexport default Provider;\n","import type { AppKitOptions, CaipNetwork, CaipNetworkId } from \"@reown/appkit\";\nimport type { WalletConnectModalConfig } from \"./types\";\nimport type { AppKitNetwork } from \"@reown/appkit/networks\";\nimport type { EthereumProviderOptions } from \"./EthereumProvider\";\nimport type { Assign, ChainFormatters, Prettify } from \"viem\";\n\nfunction convertThemeVariables(\n  wcmTheme?: WalletConnectModalConfig[\"themeVariables\"],\n): AppKitOptions[\"themeVariables\"] | undefined {\n  if (!wcmTheme) return undefined;\n\n  return {\n    \"--w3m-font-family\": wcmTheme[\"--wcm-font-family\"],\n    \"--w3m-accent\": wcmTheme[\"--wcm-accent-color\"],\n    \"--w3m-color-mix\": wcmTheme[\"--wcm-background-color\"],\n    \"--w3m-z-index\": wcmTheme[\"--wcm-z-index\"] ? Number(wcmTheme[\"--wcm-z-index\"]) : undefined,\n\n    \"--w3m-qr-color\": wcmTheme[\"--wcm-accent-color\"],\n\n    \"--w3m-font-size-master\": wcmTheme[\"--wcm-text-medium-regular-size\"],\n    \"--w3m-border-radius-master\": wcmTheme[\"--wcm-container-border-radius\"],\n    \"--w3m-color-mix-strength\": 0,\n  };\n}\n\nconst mapCaipIdToAppKitCaipNetwork = (caipId: CaipNetworkId): CaipNetwork => {\n  const [namespace, chainId] = caipId.split(\":\");\n  const chain = defineChain({\n    id: chainId,\n    caipNetworkId: caipId,\n    chainNamespace: namespace as CaipNetwork[\"chainNamespace\"],\n    name: \"\",\n    nativeCurrency: {\n      name: \"\",\n      symbol: \"\",\n      decimals: 8,\n    },\n    rpcUrls: {\n      default: { http: [\"https://rpc.walletconnect.org/v1\"] },\n    },\n  });\n\n  return chain as CaipNetwork;\n};\n\nexport function convertWCMToAppKitOptions(\n  wcmConfig: WalletConnectModalConfig & { metadata?: EthereumProviderOptions[\"metadata\"] },\n): AppKitOptions {\n  // Convert chains toCaipNetwork format\n  const networks: CaipNetwork[] = (wcmConfig.chains as CaipNetworkId[])\n    ?.map(mapCaipIdToAppKitCaipNetwork)\n    .filter(Boolean);\n\n  // Ensure at least one network is present\n  if (networks.length === 0) {\n    throw new Error(\"At least one chain must be specified\");\n  }\n\n  const defaultNetwork = networks.find((network) => network.id === wcmConfig.defaultChain?.id);\n  const appKitOptions: AppKitOptions = {\n    projectId: wcmConfig.projectId,\n    networks: networks as [AppKitNetwork, ...AppKitNetwork[]],\n    themeMode: wcmConfig.themeMode,\n    themeVariables: convertThemeVariables(wcmConfig.themeVariables),\n    chainImages: wcmConfig.chainImages,\n    connectorImages: wcmConfig.walletImages,\n    defaultNetwork,\n    metadata: {\n      ...wcmConfig.metadata,\n      name: wcmConfig.metadata?.name || \"WalletConnect\",\n      description: wcmConfig.metadata?.description || \"Connect to WalletConnect-compatible wallets\",\n      url: wcmConfig.metadata?.url || \"https://walletconnect.org\",\n      icons: wcmConfig.metadata?.icons || [\"https://walletconnect.org/walletconnect-logo.png\"],\n    },\n    showWallets: true,\n    // Explorer options mapping\n    featuredWalletIds:\n      wcmConfig.explorerRecommendedWalletIds === \"NONE\"\n        ? []\n        : Array.isArray(wcmConfig.explorerRecommendedWalletIds)\n          ? wcmConfig.explorerRecommendedWalletIds\n          : [],\n\n    excludeWalletIds:\n      wcmConfig.explorerExcludedWalletIds === \"ALL\"\n        ? []\n        : Array.isArray(wcmConfig.explorerExcludedWalletIds)\n          ? wcmConfig.explorerExcludedWalletIds\n          : [],\n\n    // Additional AppKit-specific options that don't have direct WCM equivalents\n    enableEIP6963: false, // Disable 6963 by default\n    enableInjected: false, // Disable injected by default\n    enableCoinbase: true, // Default to true\n    enableWalletConnect: true, // Default to true,\n    features: {\n      email: false,\n      socials: false,\n    },\n  };\n\n  // Add mobile and desktop wallets as custom wallets if provided\n  if (wcmConfig.mobileWallets?.length || wcmConfig.desktopWallets?.length) {\n    const customWallets = [\n      ...(wcmConfig.mobileWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: wallet.links,\n      })),\n      ...(wcmConfig.desktopWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: {\n          native: wallet.links.native,\n          universal: wallet.links.universal,\n        },\n      })),\n    ];\n\n    const allWallets = [\n      ...(appKitOptions.featuredWalletIds || []),\n      ...(appKitOptions.excludeWalletIds || []),\n    ];\n\n    // Only add a custom wallet if it's not on the other lists\n    const uniqueCustomWallets = customWallets.filter((wallet) => !allWallets.includes(wallet.id));\n\n    if (uniqueCustomWallets.length) {\n      appKitOptions.customWallets = uniqueCustomWallets;\n    }\n  }\n\n  return appKitOptions;\n}\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends CaipNetwork<formatters>,\n>(chain: chain): Prettify<Assign<CaipNetwork<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<CaipNetwork<undefined>, chain>;\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}