{"ast":null,"code":"import { parseAccount } from '../../../accounts/utils/parseAccount.js';\nimport { prepareAuthorization } from '../../../actions/index.js';\nimport { estimateFeesPerGas } from '../../../actions/public/estimateFeesPerGas.js';\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js';\nimport { AccountNotFoundError } from '../../../errors/account.js';\nimport { encodeFunctionData } from '../../../utils/abi/encodeFunctionData.js';\nimport { concat } from '../../../utils/data/concat.js';\nimport { getAction } from '../../../utils/getAction.js';\nimport { getPaymasterData as getPaymasterData_ } from '../paymaster/getPaymasterData.js';\nimport { getPaymasterStubData as getPaymasterStubData_ } from '../paymaster/getPaymasterStubData.js';\nimport { estimateUserOperationGas } from './estimateUserOperationGas.js';\nconst defaultParameters = ['factory', 'fees', 'gas', 'paymaster', 'nonce', 'signature', 'authorization'];\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation(client, parameters_) {\n  const parameters = parameters_;\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride\n  } = parameters;\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n  if (!account_) throw new AccountNotFoundError();\n  const account = parseAccount(account_);\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n  const bundlerClient = client;\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster;\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined;\n  const {\n    getPaymasterStubData,\n    getPaymasterData\n  } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true) return {\n      getPaymasterStubData: parameters => getAction(bundlerClient, getPaymasterStubData_, 'getPaymasterStubData')(parameters),\n      getPaymasterData: parameters => getAction(bundlerClient, getPaymasterData_, 'getPaymasterData')(parameters)\n    };\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const {\n        getPaymasterStubData,\n        getPaymasterData\n      } = paymaster;\n      return {\n        getPaymasterStubData: getPaymasterData && getPaymasterStubData ? getPaymasterStubData : getPaymasterData,\n        getPaymasterData: getPaymasterData && getPaymasterStubData ? getPaymasterData : undefined\n      };\n    }\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined\n    };\n  })();\n  const paymasterContext = parameters.paymasterContext ? parameters.paymasterContext : bundlerClient?.paymasterContext;\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address\n  };\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([(async () => {\n    if (parameters.calls) return account.encodeCalls(parameters.calls.map(call_ => {\n      const call = call_;\n      if (call.abi) return {\n        data: encodeFunctionData(call),\n        to: call.to,\n        value: call.value\n      };\n      return call;\n    }));\n    return parameters.callData;\n  })(), (async () => {\n    if (!properties.includes('factory')) return undefined;\n    if (parameters.initCode) return {\n      initCode: parameters.initCode\n    };\n    if (parameters.factory && parameters.factoryData) {\n      return {\n        factory: parameters.factory,\n        factoryData: parameters.factoryData\n      };\n    }\n    const {\n      factory,\n      factoryData\n    } = await account.getFactoryArgs();\n    if (account.entryPoint.version === '0.6') return {\n      initCode: factory && factoryData ? concat([factory, factoryData]) : undefined\n    };\n    return {\n      factory,\n      factoryData\n    };\n  })(), (async () => {\n    if (!properties.includes('fees')) return undefined;\n    // If we have sufficient properties for fees, return them.\n    if (typeof parameters.maxFeePerGas === 'bigint' && typeof parameters.maxPriorityFeePerGas === 'bigint') return request;\n    // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n    if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n      const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n        account,\n        bundlerClient,\n        userOperation: request\n      });\n      return {\n        ...request,\n        ...fees\n      };\n    }\n    // Otherwise, we will need to estimate the fees to fill the fee properties.\n    try {\n      const client_ = bundlerClient.client ?? client;\n      const fees = await getAction(client_, estimateFeesPerGas, 'estimateFeesPerGas')({\n        chain: client_.chain,\n        type: 'eip1559'\n      });\n      return {\n        maxFeePerGas: typeof parameters.maxFeePerGas === 'bigint' ? parameters.maxFeePerGas : BigInt(\n        // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n        2n * fees.maxFeePerGas),\n        maxPriorityFeePerGas: typeof parameters.maxPriorityFeePerGas === 'bigint' ? parameters.maxPriorityFeePerGas : BigInt(\n        // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n        2n * fees.maxPriorityFeePerGas)\n      };\n    } catch {\n      return undefined;\n    }\n  })(), (async () => {\n    if (!properties.includes('nonce')) return undefined;\n    if (typeof parameters.nonce === 'bigint') return parameters.nonce;\n    return account.getNonce();\n  })(), (async () => {\n    if (!properties.includes('authorization')) return undefined;\n    if (typeof parameters.authorization === 'object') return parameters.authorization;\n    if (account.authorization && !(await account.isDeployed())) {\n      const authorization = await prepareAuthorization(account.client, account.authorization);\n      return {\n        ...authorization,\n        r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n        s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        yParity: 1\n      };\n    }\n    return undefined;\n  })()]);\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n  if (typeof callData !== 'undefined') request.callData = callData;\n  if (typeof factory !== 'undefined') request = {\n    ...request,\n    ...factory\n  };\n  if (typeof fees !== 'undefined') request = {\n    ...request,\n    ...fees\n  };\n  if (typeof nonce !== 'undefined') request.nonce = nonce;\n  if (typeof authorization !== 'undefined') request.authorization = authorization;\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined') request.signature = parameters.signature;else request.signature = await account.getStubSignature(request);\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode) request.initCode = '0x';\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n  let chainId;\n  async function getChainId() {\n    if (chainId) return chainId;\n    if (client.chain) return client.chain.id;\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({});\n    chainId = chainId_;\n    return chainId;\n  }\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false;\n  if (properties.includes('paymaster') && getPaymasterStubData && !paymasterAddress && !parameters.paymasterAndData) {\n    const {\n      isFinal = false,\n      sponsor,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...request\n    });\n    isPaymasterPopulated = isFinal;\n    request = {\n      ...request,\n      ...paymasterArgs\n    };\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData) request.paymasterAndData = '0x';\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(request);\n      request = {\n        ...request,\n        ...gas\n      };\n    }\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (typeof request.callGasLimit === 'undefined' || typeof request.preVerificationGas === 'undefined' || typeof request.verificationGasLimit === 'undefined' || request.paymaster && typeof request.paymasterPostOpGasLimit === 'undefined' || request.paymaster && typeof request.paymasterVerificationGasLimit === 'undefined') {\n      const gas = await getAction(bundlerClient, estimateUserOperationGas, 'estimateUserOperationGas')({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') –\n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster ? {\n          paymasterPostOpGasLimit: 0n,\n          paymasterVerificationGasLimit: 0n\n        } : {}),\n        ...request\n      });\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas: request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit: request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit: request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit: request.paymasterVerificationGasLimit ?? gas.paymasterVerificationGasLimit\n      };\n    }\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (properties.includes('paymaster') && getPaymasterData && !paymasterAddress && !parameters.paymasterAndData && !isPaymasterPopulated) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...request\n    });\n    request = {\n      ...request,\n      ...paymaster\n    };\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n  delete request.calls;\n  delete request.parameters;\n  delete request.paymasterContext;\n  if (typeof request.paymaster !== 'string') delete request.paymaster;\n  ////////////////////////////////////////////////////////////////////////////////\n  return request;\n}","map":{"version":3,"names":["parseAccount","prepareAuthorization","estimateFeesPerGas","getChainId","getChainId_","AccountNotFoundError","encodeFunctionData","concat","getAction","getPaymasterData","getPaymasterData_","getPaymasterStubData","getPaymasterStubData_","estimateUserOperationGas","defaultParameters","prepareUserOperation","client","parameters_","parameters","account","account_","properties","stateOverride","bundlerClient","paymaster","paymasterAddress","undefined","paymasterContext","request","sender","address","callData","factory","fees","nonce","authorization","Promise","all","calls","encodeCalls","map","call_","call","abi","data","to","value","includes","initCode","factoryData","getFactoryArgs","entryPoint","version","maxFeePerGas","maxPriorityFeePerGas","userOperation","client_","chain","type","BigInt","getNonce","isDeployed","r","s","yParity","signature","getStubSignature","chainId","id","chainId_","isPaymasterPopulated","paymasterAndData","isFinal","sponsor","paymasterArgs","entryPointAddress","context","estimateGas","gas","callGasLimit","preVerificationGas","verificationGasLimit","paymasterPostOpGasLimit","paymasterVerificationGasLimit"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/account-abstraction/actions/bundler/prepareUserOperation.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport { prepareAuthorization } from '../../../actions/index.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateFeesPerGas,\n} from '../../../actions/public/estimateFeesPerGas.js'\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  OneOf,\n  Prettify,\n  UnionOmit,\n} from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { BundlerClient } from '../../clients/createBundlerClient.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport {\n  type GetPaymasterDataErrorType,\n  getPaymasterData as getPaymasterData_,\n} from '../paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataErrorType,\n  getPaymasterStubData as getPaymasterStubData_,\n} from '../paymaster/getPaymasterStubData.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  estimateUserOperationGas,\n} from './estimateUserOperationGas.js'\n\nconst defaultParameters = [\n  'factory',\n  'fees',\n  'gas',\n  'paymaster',\n  'nonce',\n  'signature',\n  'authorization',\n] as const\n\nexport type PrepareUserOperationParameterType =\n  | 'factory'\n  | 'fees'\n  | 'gas'\n  | 'paymaster'\n  | 'nonce'\n  | 'signature'\n  | 'authorization'\n\ntype FactoryProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          initCode: UserOperation['initCode']\n        }\n      : never)\n\ntype GasProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n        }\n      : never)\n\ntype FeeProperties = {\n  maxFeePerGas: UserOperation['maxFeePerGas']\n  maxPriorityFeePerGas: UserOperation['maxPriorityFeePerGas']\n}\n\ntype NonceProperties = {\n  nonce: UserOperation['nonce']\n}\n\ntype PaymasterProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          paymasterAndData: UserOperation['paymasterAndData']\n        }\n      : never)\n\ntype SignatureProperties = {\n  signature: UserOperation['signature']\n}\n\ntype AuthorizationProperties = {\n  authorization: UserOperation['authorization']\n}\n\nexport type PrepareUserOperationRequest<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Assign<\n  UserOperationRequest<_derivedVersion>,\n  OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n    parameters?: readonly PrepareUserOperationParameterType[] | undefined\n    paymaster?:\n      | Address\n      | true\n      | {\n          /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n          getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n          /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n          getPaymasterStubData?:\n            | PaymasterActions['getPaymasterStubData']\n            | undefined\n        }\n      | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown | undefined\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n>\n\nexport type PrepareUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n> = request & GetSmartAccountParameter<account, accountOverride>\n\nexport type PrepareUserOperationReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n  //\n  _parameters extends\n    PrepareUserOperationParameterType = request['parameters'] extends readonly PrepareUserOperationParameterType[]\n    ? request['parameters'][number]\n    : (typeof defaultParameters)[number],\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<\n  UnionOmit<request, 'calls' | 'parameters'> & {\n    callData: Hex\n    paymasterAndData: _derivedVersion extends '0.6' ? Hex : undefined\n    sender: UserOperation['sender']\n  } & (Extract<_parameters, 'authorization'> extends never\n      ? {}\n      : AuthorizationProperties) &\n    (Extract<_parameters, 'factory'> extends never\n      ? {}\n      : FactoryProperties<_derivedVersion>) &\n    (Extract<_parameters, 'nonce'> extends never ? {} : NonceProperties) &\n    (Extract<_parameters, 'fees'> extends never ? {} : FeeProperties) &\n    (Extract<_parameters, 'gas'> extends never\n      ? {}\n      : GasProperties<_derivedVersion>) &\n    (Extract<_parameters, 'paymaster'> extends never\n      ? {}\n      : PaymasterProperties<_derivedVersion>) &\n    (Extract<_parameters, 'signature'> extends never ? {} : SignatureProperties)\n>\n\nexport type PrepareUserOperationErrorType =\n  | ParseAccountErrorType\n  | GetPaymasterStubDataErrorType\n  | GetPaymasterDataErrorType\n  | EncodeFunctionDataErrorType\n  | ConcatErrorType\n  | EstimateFeesPerGasErrorType\n  | ErrorType\n\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation<\n  account extends SmartAccount | undefined,\n  const calls extends readonly unknown[],\n  const request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  >,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters_: PrepareUserOperationParameters<\n    account,\n    accountOverride,\n    calls,\n    request\n  >,\n): Promise<\n  PrepareUserOperationReturnType<account, accountOverride, calls, request>\n> {\n  const parameters = parameters_ as PrepareUserOperationParameters\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride,\n  } = parameters\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const bundlerClient = client as unknown as BundlerClient\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined\n  const { getPaymasterStubData, getPaymasterData } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true)\n      return {\n        getPaymasterStubData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterStubData_,\n            'getPaymasterStubData',\n          )(parameters),\n        getPaymasterData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterData_,\n            'getPaymasterData',\n          )(parameters),\n      }\n\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const { getPaymasterStubData, getPaymasterData } = paymaster\n      return {\n        getPaymasterStubData: (getPaymasterData && getPaymasterStubData\n          ? getPaymasterStubData\n          : getPaymasterData) as typeof getPaymasterStubData,\n        getPaymasterData:\n          getPaymasterData && getPaymasterStubData\n            ? getPaymasterData\n            : undefined,\n      }\n    }\n\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined,\n    }\n  })()\n  const paymasterContext = parameters.paymasterContext\n    ? parameters.paymasterContext\n    : bundlerClient?.paymasterContext\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address,\n  } as PrepareUserOperationRequest\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([\n    (async () => {\n      if (parameters.calls)\n        return account.encodeCalls(\n          parameters.calls.map((call_) => {\n            const call = call_ as Call\n            if (call.abi)\n              return {\n                data: encodeFunctionData(call),\n                to: call.to,\n                value: call.value,\n              } as Call\n            return call as Call\n          }),\n        )\n      return parameters.callData\n    })(),\n    (async () => {\n      if (!properties.includes('factory')) return undefined\n      if (parameters.initCode) return { initCode: parameters.initCode }\n      if (parameters.factory && parameters.factoryData) {\n        return {\n          factory: parameters.factory,\n          factoryData: parameters.factoryData,\n        }\n      }\n\n      const { factory, factoryData } = await account.getFactoryArgs()\n\n      if (account.entryPoint.version === '0.6')\n        return {\n          initCode:\n            factory && factoryData ? concat([factory, factoryData]) : undefined,\n        }\n      return {\n        factory,\n        factoryData,\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('fees')) return undefined\n\n      // If we have sufficient properties for fees, return them.\n      if (\n        typeof parameters.maxFeePerGas === 'bigint' &&\n        typeof parameters.maxPriorityFeePerGas === 'bigint'\n      )\n        return request\n\n      // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n      if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n        const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n          account,\n          bundlerClient,\n          userOperation: request as UserOperation,\n        })\n        return {\n          ...request,\n          ...fees,\n        }\n      }\n\n      // Otherwise, we will need to estimate the fees to fill the fee properties.\n      try {\n        const client_ = bundlerClient.client ?? client\n        const fees = await getAction(\n          client_,\n          estimateFeesPerGas,\n          'estimateFeesPerGas',\n        )({\n          chain: client_.chain,\n          type: 'eip1559',\n        })\n        return {\n          maxFeePerGas:\n            typeof parameters.maxFeePerGas === 'bigint'\n              ? parameters.maxFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n                  2n * fees.maxFeePerGas,\n                ),\n          maxPriorityFeePerGas:\n            typeof parameters.maxPriorityFeePerGas === 'bigint'\n              ? parameters.maxPriorityFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n                  2n * fees.maxPriorityFeePerGas,\n                ),\n        }\n      } catch {\n        return undefined\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('nonce')) return undefined\n      if (typeof parameters.nonce === 'bigint') return parameters.nonce\n      return account.getNonce()\n    })(),\n    (async () => {\n      if (!properties.includes('authorization')) return undefined\n      if (typeof parameters.authorization === 'object')\n        return parameters.authorization\n      if (account.authorization && !(await account.isDeployed())) {\n        const authorization = await prepareAuthorization(\n          account.client,\n          account.authorization,\n        )\n        return {\n          ...authorization,\n          r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n          s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n          yParity: 1,\n        } satisfies SignedAuthorization\n      }\n      return undefined\n    })(),\n  ])\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (typeof callData !== 'undefined') request.callData = callData\n  if (typeof factory !== 'undefined')\n    request = { ...request, ...(factory as any) }\n  if (typeof fees !== 'undefined') request = { ...request, ...(fees as any) }\n  if (typeof nonce !== 'undefined') request.nonce = nonce\n  if (typeof authorization !== 'undefined')\n    request.authorization = authorization\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined')\n      request.signature = parameters.signature\n    else\n      request.signature = await account.getStubSignature(\n        request as UserOperation,\n      )\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode)\n    request.initCode = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (client.chain) return client.chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterStubData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData\n  ) {\n    const {\n      isFinal = false,\n      sponsor,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    isPaymasterPopulated = isFinal\n    request = {\n      ...request,\n      ...paymasterArgs,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData)\n    request.paymasterAndData = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(\n        request as UserOperation,\n      )\n      request = {\n        ...request,\n        ...gas,\n      } as PrepareUserOperationRequest\n    }\n\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (\n      typeof request.callGasLimit === 'undefined' ||\n      typeof request.preVerificationGas === 'undefined' ||\n      typeof request.verificationGasLimit === 'undefined' ||\n      (request.paymaster &&\n        typeof request.paymasterPostOpGasLimit === 'undefined') ||\n      (request.paymaster &&\n        typeof request.paymasterVerificationGasLimit === 'undefined')\n    ) {\n      const gas = await getAction(\n        bundlerClient,\n        estimateUserOperationGas,\n        'estimateUserOperationGas',\n      )({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') –\n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster\n          ? {\n              paymasterPostOpGasLimit: 0n,\n              paymasterVerificationGasLimit: 0n,\n            }\n          : {}),\n        ...request,\n      } as EstimateUserOperationGasParameters)\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas:\n          request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit:\n          request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit:\n          request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit:\n          request.paymasterVerificationGasLimit ??\n          gas.paymasterVerificationGasLimit,\n      } as PrepareUserOperationRequest\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData &&\n    !isPaymasterPopulated\n  ) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    request = {\n      ...request,\n      ...paymaster,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  delete request.calls\n  delete request.parameters\n  delete request.paymasterContext\n  if (typeof request.paymaster !== 'string') delete request.paymaster\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  return request as unknown as PrepareUserOperationReturnType<\n    account,\n    accountOverride,\n    calls,\n    request\n  >\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}