{"ast":null,"code":"/**\n * Get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join('.') || '.';\n}\n/**\n * Faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array, value) {\n  const {\n    length\n  } = array;\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n  return 0;\n}\n/**\n * Create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(replacer, circularReplacer) {\n  const hasReplacer = typeof replacer === 'function';\n  const hasCircularReplacer = typeof circularReplacer === 'function';\n  const cache = [];\n  const keys = [];\n  return function replace(key, value) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n        keys[keys.length] = key;\n        const valueCutoff = getCutoff(cache, value);\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\n/**\n * Stringifier that handles circular values\n *\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\nexport function serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer((key, value_) => {\n    let value = value_;\n    if (typeof value === 'bigint') value = {\n      __type: 'bigint',\n      value: value_.toString()\n    };\n    if (value instanceof Map) value = {\n      __type: 'Map',\n      value: Array.from(value_.entries())\n    };\n    return replacer?.(key, value) ?? value;\n  }, circularReplacer), indent ?? undefined);\n}","map":{"version":3,"names":["getReferenceKey","keys","cutoff","slice","join","getCutoff","array","value","length","index","createReplacer","replacer","circularReplacer","hasReplacer","hasCircularReplacer","cache","replace","key","thisCutoff","splice","valueCutoff","call","serialize","indent","JSON","stringify","value_","__type","toString","Map","Array","from","entries","undefined"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/core/src/utils/serialize.ts"],"sourcesContent":["/**\n * Get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys: string[], cutoff: number) {\n  return keys.slice(0, cutoff).join('.') || '.'\n}\n\n/**\n * Faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array: any[], value: any) {\n  const { length } = array\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1\n    }\n  }\n\n  return 0\n}\n\ntype StandardReplacer = (key: string, value: any) => any\ntype CircularReplacer = (key: string, value: any, referenceKey: string) => any\n\n/**\n * Create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(\n  replacer?: StandardReplacer | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n): StandardReplacer {\n  const hasReplacer = typeof replacer === 'function'\n  const hasCircularReplacer = typeof circularReplacer === 'function'\n\n  const cache: any[] = []\n  const keys: string[] = []\n\n  return function replace(this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this)\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this\n        } else {\n          cache.splice(thisCutoff)\n          keys.splice(thisCutoff)\n        }\n\n        keys[keys.length] = key\n\n        const valueCutoff = getCutoff(cache, value)\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer\n            ? circularReplacer.call(\n                this,\n                key,\n                value,\n                getReferenceKey(keys, valueCutoff),\n              )\n            : `[ref=${getReferenceKey(keys, valueCutoff)}]`\n        }\n      } else {\n        cache[0] = value\n        keys[0] = key\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value\n  }\n}\n\n/**\n * Stringifier that handles circular values\n *\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\nexport function serialize(\n  value: any,\n  replacer?: StandardReplacer | null | undefined,\n  indent?: number | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n) {\n  return JSON.stringify(\n    value,\n    createReplacer((key, value_) => {\n      let value = value_\n      if (typeof value === 'bigint')\n        value = { __type: 'bigint', value: value_.toString() }\n      if (value instanceof Map)\n        value = { __type: 'Map', value: Array.from(value_.entries()) }\n      return replacer?.(key, value) ?? value\n    }, circularReplacer),\n    indent ?? undefined,\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}