{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simulateCalls = simulateCalls;\nconst AbiConstructor = require(\"ox/AbiConstructor\");\nconst AbiFunction = require(\"ox/AbiFunction\");\nconst parseAccount_js_1 = require(\"../../accounts/utils/parseAccount.js\");\nconst address_js_1 = require(\"../../constants/address.js\");\nconst contracts_js_1 = require(\"../../constants/contracts.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst index_js_1 = require(\"../../utils/index.js\");\nconst createAccessList_js_1 = require(\"./createAccessList.js\");\nconst simulateBlocks_js_1 = require(\"./simulateBlocks.js\");\nconst getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';\nasync function simulateCalls(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation\n  } = parameters;\n  const account = parameters.account ? (0, parseAccount_js_1.parseAccount)(parameters.account) : undefined;\n  if (traceAssetChanges && !account) throw new base_js_1.BaseError('`account` is required when `traceAssetChanges` is true');\n  const getBalanceData = account ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n    bytecode: contracts_js_1.deploylessCallViaBytecodeBytecode,\n    args: [getBalanceCode, AbiFunction.encodeData(AbiFunction.from('function getBalance(address)'), [account.address])]\n  }) : undefined;\n  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async call => {\n    if (!call.data && !call.abi) return;\n    const {\n      accessList\n    } = await (0, createAccessList_js_1.createAccessList)(client, {\n      account: account.address,\n      ...call,\n      data: call.abi ? (0, encodeFunctionData_js_1.encodeFunctionData)(call) : call.data\n    });\n    return accessList.map(({\n      address,\n      storageKeys\n    }) => storageKeys.length > 0 ? address : null);\n  })).then(x => x.flat().filter(Boolean)) : [];\n  const blocks = await (0, simulateBlocks_js_1.simulateBlocks)(client, {\n    blockNumber,\n    blockTag: blockTag,\n    blocks: [...(traceAssetChanges ? [{\n      calls: [{\n        data: getBalanceData\n      }],\n      stateOverrides\n    }, {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: address_js_1.zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: address_js_1.zeroAddress,\n        nonce: 0\n      }]\n    }] : []), {\n      calls: [...calls, {}].map(call => ({\n        ...call,\n        from: account?.address\n      })),\n      stateOverrides\n    }, ...(traceAssetChanges ? [{\n      calls: [{\n        data: getBalanceData\n      }]\n    }, {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: address_js_1.zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: address_js_1.zeroAddress,\n        nonce: 0\n      }]\n    }, {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function decimals() returns (uint256)')],\n        functionName: 'decimals',\n        from: address_js_1.zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: address_js_1.zeroAddress,\n        nonce: 0\n      }]\n    }, {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function tokenURI(uint256) returns (string)')],\n        functionName: 'tokenURI',\n        args: [0n],\n        from: address_js_1.zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: address_js_1.zeroAddress,\n        nonce: 0\n      }]\n    }, {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function symbol() returns (string)')],\n        functionName: 'symbol',\n        from: address_js_1.zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: address_js_1.zeroAddress,\n        nonce: 0\n      }]\n    }] : [])],\n    traceTransfers,\n    validation\n  });\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0];\n  const [block_ethPre, block_assetsPre,, block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];\n  const {\n    calls: block_calls,\n    ...block\n  } = block_results;\n  const results = block_calls.slice(0, -1) ?? [];\n  const ethPre = block_ethPre?.calls ?? [];\n  const assetsPre = block_assetsPre?.calls ?? [];\n  const balancesPre = [...ethPre, ...assetsPre].map(call => call.status === 'success' ? (0, index_js_1.hexToBigInt)(call.data) : null);\n  const ethPost = block_ethPost?.calls ?? [];\n  const assetsPost = block_assetsPost?.calls ?? [];\n  const balancesPost = [...ethPost, ...assetsPost].map(call => call.status === 'success' ? (0, index_js_1.hexToBigInt)(call.data) : null);\n  const decimals = (block_decimals?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const symbols = (block_symbols?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const tokenURI = (block_tokenURI?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const changes = [];\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i];\n    if (typeof balancePost !== 'bigint') continue;\n    if (typeof balancePre !== 'bigint') continue;\n    const decimals_ = decimals[i - 1];\n    const symbol_ = symbols[i - 1];\n    const tokenURI_ = tokenURI[i - 1];\n    const token = (() => {\n      if (i === 0) return {\n        address: address_js_1.ethAddress,\n        decimals: 18,\n        symbol: 'ETH'\n      };\n      return {\n        address: assetAddresses[i - 1],\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined\n      };\n    })();\n    if (changes.some(change => change.token.address === token.address)) continue;\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre\n      }\n    });\n  }\n  return {\n    assetChanges: changes,\n    block,\n    results\n  };\n}","map":{"version":3,"names":["exports","simulateCalls","AbiConstructor","require","AbiFunction","parseAccount_js_1","address_js_1","contracts_js_1","base_js_1","encodeFunctionData_js_1","index_js_1","createAccessList_js_1","simulateBlocks_js_1","getBalanceCode","client","parameters","blockNumber","blockTag","calls","stateOverrides","traceAssetChanges","traceTransfers","validation","account","parseAccount","undefined","BaseError","getBalanceData","encode","from","bytecode","deploylessCallViaBytecodeBytecode","args","encodeData","address","assetAddresses","Promise","all","map","call","data","abi","accessList","createAccessList","encodeFunctionData","storageKeys","length","then","x","flat","filter","Boolean","blocks","simulateBlocks","i","functionName","to","zeroAddress","nonce","block_results","block_ethPre","block_assetsPre","block_ethPost","block_assetsPost","block_decimals","block_tokenURI","block_symbols","block_calls","block","results","slice","ethPre","assetsPre","balancesPre","status","hexToBigInt","ethPost","assetsPost","balancesPost","decimals","result","symbols","tokenURI","changes","balancePost","entries","balancePre","decimals_","symbol_","tokenURI_","token","ethAddress","symbol","Number","some","change","push","value","pre","post","diff","assetChanges"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/actions/public/simulateCalls.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as AbiConstructor from 'ox/AbiConstructor'\nimport * as AbiFunction from 'ox/AbiFunction'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { ethAddress, zeroAddress } from '../../constants/address.js'\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { Mutable } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { hexToBigInt } from '../../utils/index.js'\nimport {\n  type CreateAccessListErrorType,\n  createAccessList,\n} from './createAccessList.js'\nimport {\n  type SimulateBlocksErrorType,\n  type SimulateBlocksParameters,\n  simulateBlocks,\n} from './simulateBlocks.js'\n\nconst getBalanceCode =\n  '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033'\n\nexport type SimulateCallsParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n  account extends Account | Address | undefined = Account | Address | undefined,\n> = Omit<SimulateBlocksParameters, 'blocks' | 'returnFullTransactions'> & {\n  /** Account attached to the calls (msg.sender). */\n  account?: account | undefined\n  /** Calls to simulate. */\n  calls: Calls<Narrow<calls>>\n  /** State overrides. */\n  stateOverrides?: StateOverride | undefined\n  /** Whether to trace asset changes. */\n  traceAssetChanges?: boolean | undefined\n}\n\nexport type SimulateCallsReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Asset changes. */\n  assetChanges: readonly {\n    token: {\n      address: Address\n      decimals?: number | undefined\n      symbol?: string | undefined\n    }\n    value: { pre: bigint; post: bigint; diff: bigint }\n  }[]\n  /** Block results. */\n  block: Block\n  /** Call results. */\n  results: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n}\n\nexport type SimulateCallsErrorType =\n  | AbiFunction.encodeData.ErrorType\n  | AbiFunction.from.ErrorType\n  | CreateAccessListErrorType\n  | EncodeFunctionDataErrorType\n  | SimulateBlocksErrorType\n  | ErrorType\n\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateCallsParameters<calls, account>,\n): Promise<SimulateCallsReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n\n  if (traceAssetChanges && !account)\n    throw new BaseError(\n      '`account` is required when `traceAssetChanges` is true',\n    )\n\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account\n    ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n        bytecode: deploylessCallViaBytecodeBytecode,\n        args: [\n          getBalanceCode,\n          AbiFunction.encodeData(\n            AbiFunction.from('function getBalance(address)'),\n            [account.address],\n          ),\n        ],\n      })\n    : undefined\n\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges\n    ? await Promise.all(\n        parameters.calls.map(async (call: any) => {\n          if (!call.data && !call.abi) return\n          const { accessList } = await createAccessList(client, {\n            account: account!.address,\n            ...call,\n            data: call.abi ? encodeFunctionData(call) : call.data,\n          })\n          return accessList.map(({ address, storageKeys }) =>\n            storageKeys.length > 0 ? address : null,\n          )\n        }),\n      ).then((x) => x.flat().filter(Boolean))\n    : []\n\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag as undefined,\n    blocks: [\n      ...(traceAssetChanges\n        ? [\n            // ETH pre balances\n            {\n              calls: [{ data: getBalanceData }],\n              stateOverrides,\n            },\n\n            // Asset pre balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n\n      {\n        calls: [...calls, {}].map((call) => ({\n          ...(call as Call),\n          from: account?.address,\n        })) as any,\n        stateOverrides,\n      },\n\n      ...(traceAssetChanges\n        ? [\n            // ETH post balances\n            {\n              calls: [{ data: getBalanceData }],\n            },\n\n            // Asset post balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Decimals\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from('function decimals() returns (uint256)'),\n                ],\n                functionName: 'decimals',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Token URI\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from(\n                    'function tokenURI(uint256) returns (string)',\n                  ),\n                ],\n                functionName: 'tokenURI',\n                args: [0n],\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Symbols\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [AbiFunction.from('function symbol() returns (string)')],\n                functionName: 'symbol',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n    ],\n    traceTransfers,\n    validation,\n  })\n\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0]\n  const [\n    block_ethPre,\n    block_assetsPre,\n    ,\n    block_ethPost,\n    block_assetsPost,\n    block_decimals,\n    block_tokenURI,\n    block_symbols,\n  ] = traceAssetChanges ? blocks : []\n\n  // Extract call results from the simulation.\n  const { calls: block_calls, ...block } = block_results\n  const results = block_calls.slice(0, -1) ?? []\n\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? []\n  const assetsPre = block_assetsPre?.calls ?? []\n  const balancesPre = [...ethPre, ...assetsPre].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? []\n  const assetsPost = block_assetsPost?.calls ?? []\n  const balancesPost = [...ethPost, ...assetsPost].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (number | null)[]\n  const symbols = (block_symbols?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n  const tokenURI = (block_tokenURI?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n\n  const changes: Mutable<SimulateCallsReturnType<calls>['assetChanges']> = []\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i]\n\n    if (typeof balancePost !== 'bigint') continue\n    if (typeof balancePre !== 'bigint') continue\n\n    const decimals_ = decimals[i - 1]\n    const symbol_ = symbols[i - 1]\n    const tokenURI_ = tokenURI[i - 1]\n\n    const token = (() => {\n      if (i === 0)\n        return {\n          address: ethAddress,\n          decimals: 18,\n          symbol: 'ETH',\n        }\n\n      return {\n        address: assetAddresses[i - 1]! as Address,\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined,\n      }\n    })()\n\n    if (changes.some((change) => change.token.address === token.address))\n      continue\n\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre,\n      },\n    })\n  }\n\n  return {\n    assetChanges: changes,\n    block,\n    results,\n  } as unknown as SimulateCallsReturnType<calls>\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}