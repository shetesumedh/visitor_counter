{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Kzg from './Kzg.js';\nimport * as Cursor from './internal/cursor.js';\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6;\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32;\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096;\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -\n// terminator byte (0x80).\n1 -\n// zero byte (0x00) appended to each field element.\n1 * fieldElementsPerBlob * blobsPerTransaction;\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes(commitments, options = {}) {\n  const {\n    version\n  } = options;\n  const as = options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes');\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash(commitment, options = {}) {\n  const {\n    version = 1\n  } = options;\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes');\n  const versionedHash = Hash.sha256(commitment, {\n    as: 'Bytes'\n  });\n  versionedHash.set([version], 0);\n  return as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash);\n}\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from(data, options = {}) {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes');\n  const data_ = typeof data === 'string' ? Bytes.fromHex(data) : data;\n  const size_ = Bytes.size(data_);\n  if (!size_) throw new EmptyBlobError();\n  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({\n    maxSize: maxBytesPerTransaction,\n    size: size_\n  });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob));\n    let size = 0;\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00);\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes);\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80);\n        active = false;\n        break;\n      }\n      size++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return as === 'Bytes' ? blobs.map(x => x.bytes) : blobs.map(x => Hex.fromBytes(x.bytes));\n}\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes(sidecars, options = {}) {\n  const {\n    version\n  } = options;\n  const as = options.as ?? (typeof sidecars[0].blob === 'string' ? 'Hex' : 'Bytes');\n  const hashes = [];\n  for (const {\n    commitment\n  } of sidecars) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to(blobs, to) {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0);\n  const data = Cursor.create(new Uint8Array(length));\n  let active = true;\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob);\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1);\n      let consume = 31;\n      if (blob.length - cursor.position < 31) consume = blob.length - cursor.position;\n      for (const _ in Array.from({\n        length: consume\n      })) {\n        const byte = cursor.readByte();\n        const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n        if (isTerminator) {\n          active = false;\n          break;\n        }\n        data.pushByte(byte);\n      }\n    }\n  }\n  const trimmedData = data.bytes.slice(0, data.position);\n  return to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(blobs) {\n  return to(blobs, 'Hex');\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(blobs) {\n  return to(blobs, 'Bytes');\n}\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = [];\n  for (const blob of blobs_) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n  return as === 'Bytes' ? commitments : commitments.map(x => Hex.fromBytes(x));\n}\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = typeof options.commitments[0] === 'string' ? options.commitments.map(x => Bytes.fromHex(x)) : options.commitments;\n  const proofs = [];\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i];\n    const commitment = commitments[i];\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n  }\n  return as === 'Bytes' ? proofs : proofs.map(x => Hex.fromBytes(x));\n}\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const commitments = options.commitments ?? toCommitments(blobs, {\n    kzg: kzg\n  });\n  const proofs = options.proofs ?? toProofs(blobs, {\n    commitments: commitments,\n    kzg: kzg\n  });\n  const sidecars = [];\n  for (let i = 0; i < blobs.length; i++) sidecars.push({\n    blob: blobs[i],\n    commitment: commitments[i],\n    proof: proofs[i]\n  });\n  return sidecars;\n}\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes(blobs, options) {\n  const commitments = toCommitments(blobs, options);\n  return commitmentsToVersionedHashes(commitments, options);\n}\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  constructor({\n    maxSize,\n    size\n  }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.BlobSizeTooLargeError'\n    });\n  }\n}\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  constructor() {\n    super('Blob data must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobError'\n    });\n  }\n}\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  constructor() {\n    super('Blob versioned hashes must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobVersionedHashesError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  constructor({\n    hash,\n    size\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashSizeError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  constructor({\n    hash,\n    version\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [`Expected: ${Kzg.versionedHashVersion}`, `Received: ${version}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashVersionError'\n    });\n  }\n}","map":{"version":3,"names":["Bytes","Errors","Hash","Hex","Kzg","Cursor","blobsPerTransaction","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","commitmentsToVersionedHashes","commitments","options","version","as","hashes","commitment","push","commitmentToVersionedHash","versionedHash","sha256","set","fromBytes","from","data","data_","fromHex","size_","size","EmptyBlobError","BlobSizeTooLargeError","maxSize","blobs","active","position","blob","create","Uint8Array","bytes","slice","pushByte","pushBytes","length","map","x","sidecarsToVersionedHashes","sidecars","to","to_","blobs_","reduce","cursor","incrementPosition","consume","_","Array","byte","readByte","isTerminator","inspectBytes","remaining","includes","trimmedData","toHex","toBytes","toCommitments","kzg","blobToKzgCommitment","toProofs","proofs","i","computeBlobKzgProof","toSidecars","proof","toVersionedHashes","BaseError","constructor","metaMessages","Object","defineProperty","EmptyBlobVersionedHashesError","InvalidVersionedHashSizeError","hash","InvalidVersionedHashVersionError","versionedHashVersion"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/Blobs.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Kzg from './Kzg.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { Compute, Mutable, OneOf, UnionCompute } from './internal/types.js'\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n\n/** Root type for a Blob. */\nexport type Blob<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  type\n\n/** A list of {@link ox#Blobs.Blob}. */\nexport type Blobs<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  readonly Blob<type>[]\n\n/** Type for a Blob Sidecar that contains a blob, as well as its KZG commitment and proof. */\nexport type BlobSidecar<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = Compute<{\n  /** The blob associated with the transaction. */\n  blob: type\n  /** The KZG commitment corresponding to this blob. */\n  commitment: type\n  /** The KZG proof corresponding to this blob and commitment. */\n  proof: type\n}>\n\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (commitments extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (commitments extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  commitments: commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  options: commitmentsToVersionedHashes.Options<as> = {},\n): commitmentsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as never,\n    )\n  }\n  return hashes as never\n}\n\nexport declare namespace commitmentsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (commitment extends Hex.Hex ? 'Hex' : never)\n    | (commitment extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  commitment: commitment | Hex.Hex | Bytes.Bytes,\n  options: commitmentToVersionedHash.Options<as> = {},\n): commitmentToVersionedHash.ReturnType<as> {\n  const { version = 1 } = options\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes')\n\n  const versionedHash = Hash.sha256(commitment, { as: 'Bytes' })\n  versionedHash.set([version], 0)\n  return (\n    as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash)\n  ) as commitmentToVersionedHash.ReturnType<as>\n}\n\nexport declare namespace commitmentToVersionedHash {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hash. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from<\n  const data extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (data extends Hex.Hex ? 'Hex' : never)\n    | (data extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  data: data | Hex.Hex | Bytes.Bytes,\n  options: from.Options<as> = {},\n): from.ReturnType<as> {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes')\n  const data_ = (\n    typeof data === 'string' ? Bytes.fromHex(data) : data\n  ) as Bytes.Bytes\n\n  const size_ = Bytes.size(data_)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    as === 'Bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => Hex.fromBytes(x.bytes))\n  ) as never\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | BlobSizeTooLargeError\n    | EmptyBlobError\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Cursor.create.ErrorType\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes<\n  const sidecars extends BlobSidecars,\n  as extends 'Hex' | 'Bytes' =\n    | (sidecars extends BlobSidecars<Hex.Hex> ? 'Hex' : never)\n    | (sidecars extends BlobSidecars<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  sidecars: sidecars | BlobSidecars,\n  options: sidecarsToVersionedHashes.Options<as> = {},\n): sidecarsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof sidecars[0]!.blob === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const { commitment } of sidecars) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n\nexport declare namespace sidecarsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = commitmentToVersionedHash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to?: to | 'Hex' | 'Bytes' | undefined,\n): to.ReturnType<to> {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as Hex.Hex))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0)\n  const data = Cursor.create(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData) as never\n}\n\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (to extends 'Bytes' ? Bytes.Bytes : never)\n    | (to extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Cursor.create.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toHex.ReturnType {\n  return to(blobs, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ReturnType = to.ReturnType<'Hex'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toBytes.ReturnType {\n  return to(blobs, 'Bytes')\n}\n\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toCommitments.Options<as>,\n): toCommitments.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const commitments: Bytes.Bytes[] = []\n  for (const blob of blobs_)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (\n    as === 'Bytes' ? commitments : commitments.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toCommitments {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport declare namespace toBytes {\n  type ReturnType = to.ReturnType<'Bytes'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs<\n  const blobs extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (blobs extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toProofs.Options<blobs, commitments, as>,\n): toProofs.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n  const commitments = (\n    typeof options.commitments[0] === 'string'\n      ? options.commitments.map((x) => Bytes.fromHex(x as any))\n      : options.commitments\n  ) as Bytes.Bytes[]\n\n  const proofs: Bytes.Bytes[] = []\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i]!\n    const commitment = commitments[i]!\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (\n    as === 'Bytes' ? proofs : proofs.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toProofs {\n  type Options<\n    blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex> =\n      | Blobs<Bytes.Bytes>\n      | Blobs<Hex.Hex>,\n    commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[] =\n      | readonly Bytes.Bytes[]\n      | readonly Hex.Hex[],\n    as extends 'Hex' | 'Bytes' =\n      | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n  > = {\n    /** Commitments for the blobs. */\n    commitments: (commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[]) &\n      (commitments extends blobs\n        ? {}\n        : `commitments must be the same type as blobs`)\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'computeBlobKzgProof'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n>(\n  blobs: blobs,\n  options: toSidecars.Options<blobs>,\n): toSidecars.ReturnType<blobs> {\n  const { kzg } = options\n\n  const commitments = options.commitments ?? toCommitments(blobs, { kzg: kzg! })\n  const proofs =\n    options.proofs ??\n    toProofs(blobs, { commitments: commitments as any, kzg: kzg! })\n\n  const sidecars: Mutable<BlobSidecars> = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i]!,\n      commitment: commitments[i]!,\n      proof: proofs[i]!,\n    })\n\n  return sidecars as never\n}\n\nexport declare namespace toSidecars {\n  type Options<\n    blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes> =\n      | Blobs<Hex.Hex>\n      | Blobs<Bytes.Bytes>,\n  > = {\n    kzg?: Kzg.Kzg | undefined\n  } & OneOf<\n    | {}\n    | {\n        /** Commitment for each blob. */\n        commitments: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n        /** Proof for each blob. */\n        proofs: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n      }\n  >\n\n  type ReturnType<blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>> =\n    UnionCompute<\n      | (blobs extends Blobs<Hex.Hex> ? BlobSidecars<Hex.Hex> : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? BlobSidecars<Bytes.Bytes> : never)\n    >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toVersionedHashes.Options<as>,\n): toVersionedHashes.ReturnType<as> {\n  const commitments = toCommitments(blobs, options)\n  return commitmentsToVersionedHashes(commitments, options)\n}\n\nexport declare namespace toVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | toCommitments.ErrorType\n    | commitmentsToVersionedHashes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** A list of {@link ox#Blobs.BlobSidecar}. */\nexport type BlobSidecars<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = readonly Compute<BlobSidecar<type>>[]\n\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  override readonly name = 'Blobs.BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobVersionedHashesError'\n  constructor() {\n    super('Blob versioned hashes must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hex.Hex\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hex.Hex\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${Kzg.versionedHashVersion}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}