{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.charCodeMap = void 0;\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.charCodeToBase16 = charCodeToBase16;\nexports.pad = pad;\nexports.trim = trim;\nconst Bytes = require(\"../Bytes.js\");\nfunction assertSize(bytes, size_) {\n  if (Bytes.size(bytes) > size_) throw new Bytes.SizeOverflowError({\n    givenSize: Bytes.size(bytes),\n    maxSize: size_\n  });\n}\nfunction assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1) throw new Bytes.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: Bytes.size(value)\n  });\n}\nfunction assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && Bytes.size(value) !== end - start) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value)\n    });\n  }\n}\nexports.charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction charCodeToBase16(char) {\n  if (char >= exports.charCodeMap.zero && char <= exports.charCodeMap.nine) return char - exports.charCodeMap.zero;\n  if (char >= exports.charCodeMap.A && char <= exports.charCodeMap.F) return char - (exports.charCodeMap.A - 10);\n  if (char >= exports.charCodeMap.a && char <= exports.charCodeMap.f) return char - (exports.charCodeMap.a - 10);\n  return undefined;\n}\nfunction pad(bytes, options = {}) {\n  const {\n    dir,\n    size = 32\n  } = options;\n  if (size === 0) return bytes;\n  if (bytes.length > size) throw new Bytes.SizeExceedsPaddingSizeError({\n    size: bytes.length,\n    targetSize: size,\n    type: 'Bytes'\n  });\n  const paddedBytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right';\n    paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n  }\n  return paddedBytes;\n}\nfunction trim(value, options = {}) {\n  const {\n    dir = 'left'\n  } = options;\n  let data = value;\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;\n  }\n  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  return data;\n}","map":{"version":3,"names":["exports","assertSize","assertStartOffset","assertEndOffset","charCodeToBase16","pad","trim","Bytes","require","bytes","size_","size","SizeOverflowError","givenSize","maxSize","value","start","SliceOffsetOutOfBoundsError","offset","position","end","charCodeMap","zero","nine","A","F","a","f","char","undefined","options","dir","length","SizeExceedsPaddingSizeError","targetSize","type","paddedBytes","Uint8Array","i","padEnd","data","sliceLength","toString","slice"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/internal/bytes.ts"],"sourcesContent":["import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\n\n/** @internal */\nexport function assertSize(bytes: Bytes.Bytes, size_: number): void {\n  if (Bytes.size(bytes) > size_)\n    throw new Bytes.SizeOverflowError({\n      givenSize: Bytes.size(bytes),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Bytes.size.ErrorType\n    | Bytes.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Bytes.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  export type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Bytes.size(value) !== end - start\n  ) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value),\n    })\n  }\n}\n\n/** @internal */\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\n/** @internal */\nexport function charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\n/** @internal */\nexport function pad(bytes: Bytes.Bytes, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n  if (size === 0) return bytes\n  if (bytes.length > size)\n    throw new Bytes.SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'Bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]!\n  }\n  return paddedBytes\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Bytes.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Bytes.Bytes,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  return data as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}