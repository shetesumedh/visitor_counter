{"ast":null,"code":"import * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\n/**\n * Computes Contract Address generated by the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) or [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ### CREATE\n *\n * Computes via the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### CREATE2\n *\n * Computes via the [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate2:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options.\n * @returns Contract Address.\n */\nexport function from(options) {\n  if (options.salt) return fromCreate2(options);\n  return fromCreate(options);\n}\n/**\n * Computes contract address via [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate(options) {\n  const from = Bytes.fromHex(Address.from(options.from));\n  let nonce = Bytes.fromNumber(options.nonce);\n  if (nonce[0] === 0) nonce = new Uint8Array([]);\n  return Address.from(`0x${Hash.keccak256(Rlp.fromBytes([from, nonce], {\n    as: 'Hex'\n  })).slice(26)}`);\n}\n/**\n * Computes contract address via [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate2(options) {\n  const from = Bytes.fromHex(Address.from(options.from));\n  const salt = Bytes.padLeft(Bytes.validate(options.salt) ? options.salt : Bytes.fromHex(options.salt), 32);\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in options) {\n      if (Bytes.validate(options.bytecodeHash)) return options.bytecodeHash;\n      return Bytes.fromHex(options.bytecodeHash);\n    }\n    return Hash.keccak256(options.bytecode, {\n      as: 'Bytes'\n    });\n  })();\n  return Address.from(Hex.slice(Hash.keccak256(Bytes.concat(Bytes.fromHex('0xff'), from, salt, bytecodeHash), {\n    as: 'Hex'\n  }), 12));\n}","map":{"version":3,"names":["Address","Bytes","Hash","Hex","Rlp","from","options","salt","fromCreate2","fromCreate","fromHex","nonce","fromNumber","Uint8Array","keccak256","fromBytes","as","slice","padLeft","validate","bytecodeHash","bytecode","concat"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/ContractAddress.ts"],"sourcesContent":["import * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Rlp from './Rlp.js'\nimport type { OneOf } from './internal/types.js'\n\n/**\n * Computes Contract Address generated by the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) or [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ### CREATE\n *\n * Computes via the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### CREATE2\n *\n * Computes via the [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate2:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options.\n * @returns Contract Address.\n */\nexport function from(options: from.Options): Address.Address {\n  if (options.salt) return fromCreate2(options)\n  return fromCreate(options)\n}\n\nexport declare namespace from {\n  export type Options = OneOf<fromCreate.Options | fromCreate2.Options>\n\n  type ErrorType =\n    | fromCreate.ErrorType\n    | fromCreate2.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate(options: fromCreate.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n\n  let nonce = Bytes.fromNumber(options.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return Address.from(\n    `0x${Hash.keccak256(Rlp.fromBytes([from, nonce], { as: 'Hex' })).slice(26)}` as Address.Address,\n  )\n}\n\nexport declare namespace fromCreate {\n  type Options = {\n    /** The address the contract was deployed from. */\n    from: Address.Address\n    /** The nonce of the transaction which deployed the contract. */\n    nonce: bigint\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | Address.from.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.fromNumber.ErrorType\n    | Rlp.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate2(options: fromCreate2.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n  const salt = Bytes.padLeft(\n    Bytes.validate(options.salt) ? options.salt : Bytes.fromHex(options.salt),\n    32,\n  )\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in options) {\n      if (Bytes.validate(options.bytecodeHash)) return options.bytecodeHash\n      return Bytes.fromHex(options.bytecodeHash)\n    }\n    return Hash.keccak256(options.bytecode, { as: 'Bytes' })\n  })()\n\n  return Address.from(\n    Hex.slice(\n      Hash.keccak256(\n        Bytes.concat(Bytes.fromHex('0xff'), from, salt, bytecodeHash),\n        { as: 'Hex' },\n      ),\n      12,\n    ),\n  )\n}\n\nexport declare namespace fromCreate2 {\n  type Options =\n    | {\n        bytecode: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n    | {\n        bytecodeHash: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n\n  type ErrorType =\n    | Address.from.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.validate.ErrorType\n    | Bytes.padLeft.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.slice.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,GAAG,MAAM,UAAU;AAG/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,OAAM,SAAUC,IAAIA,CAACC,OAAqB;EACxC,IAAIA,OAAO,CAACC,IAAI,EAAE,OAAOC,WAAW,CAACF,OAAO,CAAC;EAC7C,OAAOG,UAAU,CAACH,OAAO,CAAC;AAC5B;AAWA;;;;;;;;;;;;;;;;;AAiBA,OAAM,SAAUG,UAAUA,CAACH,OAA2B;EACpD,MAAMD,IAAI,GAAGJ,KAAK,CAACS,OAAO,CAACV,OAAO,CAACK,IAAI,CAACC,OAAO,CAACD,IAAI,CAAC,CAAC;EAEtD,IAAIM,KAAK,GAAGV,KAAK,CAACW,UAAU,CAACN,OAAO,CAACK,KAAK,CAAC;EAC3C,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAEA,KAAK,GAAG,IAAIE,UAAU,CAAC,EAAE,CAAC;EAE9C,OAAOb,OAAO,CAACK,IAAI,CACjB,KAAKH,IAAI,CAACY,SAAS,CAACV,GAAG,CAACW,SAAS,CAAC,CAACV,IAAI,EAAEM,KAAK,CAAC,EAAE;IAAEK,EAAE,EAAE;EAAK,CAAE,CAAC,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC,EAAqB,CAChG;AACH;AAmBA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUT,WAAWA,CAACF,OAA4B;EACtD,MAAMD,IAAI,GAAGJ,KAAK,CAACS,OAAO,CAACV,OAAO,CAACK,IAAI,CAACC,OAAO,CAACD,IAAI,CAAC,CAAC;EACtD,MAAME,IAAI,GAAGN,KAAK,CAACiB,OAAO,CACxBjB,KAAK,CAACkB,QAAQ,CAACb,OAAO,CAACC,IAAI,CAAC,GAAGD,OAAO,CAACC,IAAI,GAAGN,KAAK,CAACS,OAAO,CAACJ,OAAO,CAACC,IAAI,CAAC,EACzE,EAAE,CACH;EAED,MAAMa,YAAY,GAAG,CAAC,MAAK;IACzB,IAAI,cAAc,IAAId,OAAO,EAAE;MAC7B,IAAIL,KAAK,CAACkB,QAAQ,CAACb,OAAO,CAACc,YAAY,CAAC,EAAE,OAAOd,OAAO,CAACc,YAAY;MACrE,OAAOnB,KAAK,CAACS,OAAO,CAACJ,OAAO,CAACc,YAAY,CAAC;IAC5C;IACA,OAAOlB,IAAI,CAACY,SAAS,CAACR,OAAO,CAACe,QAAQ,EAAE;MAAEL,EAAE,EAAE;IAAO,CAAE,CAAC;EAC1D,CAAC,EAAC,CAAE;EAEJ,OAAOhB,OAAO,CAACK,IAAI,CACjBF,GAAG,CAACc,KAAK,CACPf,IAAI,CAACY,SAAS,CACZb,KAAK,CAACqB,MAAM,CAACrB,KAAK,CAACS,OAAO,CAAC,MAAM,CAAC,EAAEL,IAAI,EAAEE,IAAI,EAAEa,YAAY,CAAC,EAC7D;IAAEJ,EAAE,EAAE;EAAK,CAAE,CACd,EACD,EAAE,CACH,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}