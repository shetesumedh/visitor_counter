{"ast":null,"code":"import { sendTransaction } from '../../../actions/wallet/sendTransaction.js';\nimport { withCache } from '../../../utils/promise/withCache.js';\nimport { ExecuteUnsupportedError } from '../errors.js';\nimport { encodeExecuteBatchesData } from '../utils/encodeExecuteBatchesData.js';\nimport { getExecuteError } from '../utils/getExecuteError.js';\nimport { supportsExecutionMode } from './supportsExecutionMode.js';\n/**\n * Executes batches of call(s) using \"batch of batches\" mode on an [ERC-7821-compatible contract](https://eips.ethereum.org/EIPS/eip-7821).\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { executeBatches } from 'viem/experimental/erc7821'\n *\n * const account = privateKeyToAccount('0x...')\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await executeBatches(client, {\n *   account,\n *   batches: [\n *     {\n *       calls: [\n *         {\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *           value: parseEther('1'),\n *         },\n *       ],\n *     },\n *     {\n *       calls: [\n *         {\n *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',\n *           value: parseEther('2'),\n *         },\n *         {\n *           data: '0xdeadbeef',\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         },\n *       ],\n *     },\n *   ],\n *   to: account.address,\n * })\n * ```\n *\n * @example\n * ```ts\n * // Account Hoisting\n * import { createClient, http, parseEther } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { executeBatches } from 'viem/experimental/erc7821'\n *\n * const account = privateKeyToAccount('0x...')\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await executeBatches(client, {\n *   batches: [\n *     {\n *       calls: [\n *         {\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *           value: parseEther('1'),\n *         },\n *       ],\n *     },\n *     {\n *       calls: [\n *         {\n *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',\n *           value: parseEther('2'),\n *         },\n *         {\n *           data: '0xdeadbeef',\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         },\n *       ],\n *     },\n *   ],\n *   to: account.address,\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link ExecuteBatchesParameters}\n * @returns Transaction hash. {@link ExecuteBatchesReturnType}\n */\nexport async function executeBatches(client, parameters) {\n  const {\n    authorizationList,\n    batches\n  } = parameters;\n  const address = authorizationList?.[0]?.address ?? parameters.address;\n  const supported = await withCache(() => supportsExecutionMode(client, {\n    address,\n    mode: 'batchOfBatches'\n  }), {\n    cacheKey: `supportsExecutionMode.${client.uid}.${address}.batchOfBatches`\n  });\n  if (!supported) throw new ExecuteUnsupportedError();\n  try {\n    return await sendTransaction(client, {\n      ...parameters,\n      to: parameters.address,\n      data: encodeExecuteBatchesData({\n        batches\n      })\n    });\n  } catch (e) {\n    const calls = batches.flatMap(b => b.calls);\n    throw getExecuteError(e, {\n      calls\n    });\n  }\n}","map":{"version":3,"names":["sendTransaction","withCache","ExecuteUnsupportedError","encodeExecuteBatchesData","getExecuteError","supportsExecutionMode","executeBatches","client","parameters","authorizationList","batches","address","supported","mode","cacheKey","uid","to","data","e","calls","flatMap","b"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/experimental/erc7821/actions/executeBatches.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\n\nimport {\n  type SendTransactionErrorType,\n  sendTransaction,\n} from '../../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type { Batches, Calls } from '../../../types/calls.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionPick } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { withCache } from '../../../utils/promise/withCache.js'\nimport { ExecuteUnsupportedError } from '../errors.js'\nimport {\n  type EncodeExecuteBatchesDataErrorType,\n  encodeExecuteBatchesData,\n} from '../utils/encodeExecuteBatchesData.js'\nimport {\n  type GetExecuteErrorReturnType,\n  getExecuteError,\n} from '../utils/getExecuteError.js'\nimport { supportsExecutionMode } from './supportsExecutionMode.js'\n\n/** @internal */\nexport type Batch = { calls: readonly unknown[]; opData?: Hex | undefined }\n\nexport type ExecuteBatchesParameters<\n  batches extends readonly Batch[] = readonly Batch[],\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionPick<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'authorizationList'\n    | 'gas'\n    | 'gasPrice'\n    | 'maxFeePerGas'\n    | 'maxPriorityFeePerGas'\n  >\n> &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> & {\n    /** Address that will execute the calls. */\n    address: Address\n    /** Batches to execute. */\n    batches: Batches<Narrow<batches>, { opData?: Hex | undefined }>\n  }\n\nexport type ExecuteBatchesReturnType = Hex\n\nexport type ExecuteBatchesErrorType =\n  | GetExecuteErrorReturnType\n  | EncodeExecuteBatchesDataErrorType\n  | SendTransactionErrorType\n  | ErrorType\n\n/**\n * Executes batches of call(s) using \"batch of batches\" mode on an [ERC-7821-compatible contract](https://eips.ethereum.org/EIPS/eip-7821).\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { executeBatches } from 'viem/experimental/erc7821'\n *\n * const account = privateKeyToAccount('0x...')\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await executeBatches(client, {\n *   account,\n *   batches: [\n *     {\n *       calls: [\n *         {\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *           value: parseEther('1'),\n *         },\n *       ],\n *     },\n *     {\n *       calls: [\n *         {\n *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',\n *           value: parseEther('2'),\n *         },\n *         {\n *           data: '0xdeadbeef',\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         },\n *       ],\n *     },\n *   ],\n *   to: account.address,\n * })\n * ```\n *\n * @example\n * ```ts\n * // Account Hoisting\n * import { createClient, http, parseEther } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { executeBatches } from 'viem/experimental/erc7821'\n *\n * const account = privateKeyToAccount('0x...')\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await executeBatches(client, {\n *   batches: [\n *     {\n *       calls: [\n *         {\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *           value: parseEther('1'),\n *         },\n *       ],\n *     },\n *     {\n *       calls: [\n *         {\n *           to: '0xcb98643b8786950F0461f3B0edf99D88F274574D',\n *           value: parseEther('2'),\n *         },\n *         {\n *           data: '0xdeadbeef',\n *           to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         },\n *       ],\n *     },\n *   ],\n *   to: account.address,\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link ExecuteBatchesParameters}\n * @returns Transaction hash. {@link ExecuteBatchesReturnType}\n */\nexport async function executeBatches<\n  batches extends readonly Batch[],\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: ExecuteBatchesParameters<batches, chain, account, chainOverride>,\n): Promise<ExecuteBatchesReturnType> {\n  const { authorizationList, batches } = parameters\n\n  const address = authorizationList?.[0]?.address ?? parameters.address\n\n  const supported = await withCache(\n    () =>\n      supportsExecutionMode(client, {\n        address,\n        mode: 'batchOfBatches',\n      }),\n    {\n      cacheKey: `supportsExecutionMode.${client.uid}.${address}.batchOfBatches`,\n    },\n  )\n  if (!supported) throw new ExecuteUnsupportedError()\n\n  try {\n    return await sendTransaction(client, {\n      ...parameters,\n      to: parameters.address,\n      data: encodeExecuteBatchesData({ batches }),\n    } as any)\n  } catch (e) {\n    const calls = batches.flatMap((b) => b.calls) as Calls<Narrow<batches>>\n    throw getExecuteError(e as BaseError, { calls })\n  }\n}\n"],"mappings":"AAEA,SAEEA,eAAe,QACV,4CAA4C;AAenD,SAASC,SAAS,QAAQ,qCAAqC;AAC/D,SAASC,uBAAuB,QAAQ,cAAc;AACtD,SAEEC,wBAAwB,QACnB,sCAAsC;AAC7C,SAEEC,eAAe,QACV,6BAA6B;AACpC,SAASC,qBAAqB,QAAQ,4BAA4B;AAqClE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA,OAAO,eAAeC,cAAcA,CAMlCC,MAAyC,EACzCC,UAA4E;EAE5E,MAAM;IAAEC,iBAAiB;IAAEC;EAAO,CAAE,GAAGF,UAAU;EAEjD,MAAMG,OAAO,GAAGF,iBAAiB,GAAG,CAAC,CAAC,EAAEE,OAAO,IAAIH,UAAU,CAACG,OAAO;EAErE,MAAMC,SAAS,GAAG,MAAMX,SAAS,CAC/B,MACEI,qBAAqB,CAACE,MAAM,EAAE;IAC5BI,OAAO;IACPE,IAAI,EAAE;GACP,CAAC,EACJ;IACEC,QAAQ,EAAE,yBAAyBP,MAAM,CAACQ,GAAG,IAAIJ,OAAO;GACzD,CACF;EACD,IAAI,CAACC,SAAS,EAAE,MAAM,IAAIV,uBAAuB,EAAE;EAEnD,IAAI;IACF,OAAO,MAAMF,eAAe,CAACO,MAAM,EAAE;MACnC,GAAGC,UAAU;MACbQ,EAAE,EAAER,UAAU,CAACG,OAAO;MACtBM,IAAI,EAAEd,wBAAwB,CAAC;QAAEO;MAAO,CAAE;KACpC,CAAC;EACX,CAAC,CAAC,OAAOQ,CAAC,EAAE;IACV,MAAMC,KAAK,GAAGT,OAAO,CAACU,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAACF,KAAK,CAA2B;IACvE,MAAMf,eAAe,CAACc,CAAc,EAAE;MAAEC;IAAK,CAAE,CAAC;EAClD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}