{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatAbiParameter = formatAbiParameter;\nconst regex_js_1 = require(\"../regex.js\");\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\nfunction formatAbiParameter(abiParameter) {\n  let type = abiParameter.type;\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '(';\n    const length = abiParameter.components.length;\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i];\n      type += formatAbiParameter(component);\n      if (i < length - 1) type += ', ';\n    }\n    const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);\n    type += `)${result?.array ?? ''}`;\n    return formatAbiParameter({\n      ...abiParameter,\n      type\n    });\n  }\n  if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;\n  if (abiParameter.name) return `${type} ${abiParameter.name}`;\n  return type;\n}","map":{"version":3,"names":["exports","formatAbiParameter","regex_js_1","require","tupleRegex","abiParameter","type","test","length","components","i","component","result","execTyped","array","indexed","name"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/abitype/src/human-readable/formatAbiParameter.ts"],"sourcesContent":["import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n"],"mappings":";;;;;AAkEAA,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAjEA,MAAAC,UAAA,GAAAC,OAAA;AAqDA,MAAMC,UAAU,GAAG,+BAA+B;AAYlD,SAAgBH,kBAAkBA,CAEhCI,YAA0B;EAG1B,IAAIC,IAAI,GAAGD,YAAY,CAACC,IAAI;EAC5B,IAAIF,UAAU,CAACG,IAAI,CAACF,YAAY,CAACC,IAAI,CAAC,IAAI,YAAY,IAAID,YAAY,EAAE;IACtEC,IAAI,GAAG,GAAG;IACV,MAAME,MAAM,GAAGH,YAAY,CAACI,UAAU,CAACD,MAAgB;IACvD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAGN,YAAY,CAACI,UAAU,CAACC,CAAC,CAAE;MAC7CJ,IAAI,IAAIL,kBAAkB,CAACU,SAAS,CAAC;MACrC,IAAID,CAAC,GAAGF,MAAM,GAAG,CAAC,EAAEF,IAAI,IAAI,IAAI;IAClC;IACA,MAAMM,MAAM,GAAG,IAAAV,UAAA,CAAAW,SAAS,EAAqBT,UAAU,EAAEC,YAAY,CAACC,IAAI,CAAC;IAC3EA,IAAI,IAAI,IAAIM,MAAM,EAAEE,KAAK,IAAI,EAAE,EAAE;IACjC,OAAOb,kBAAkB,CAAC;MACxB,GAAGI,YAAY;MACfC;KACD,CAAW;EACd;EAEA,IAAI,SAAS,IAAID,YAAY,IAAIA,YAAY,CAACU,OAAO,EACnDT,IAAI,GAAG,GAAGA,IAAI,UAAU;EAE1B,IAAID,YAAY,CAACW,IAAI,EAAE,OAAO,GAAGV,IAAI,IAAID,YAAY,CAACW,IAAI,EAAY;EACtE,OAAOV,IAAc;AACvB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}