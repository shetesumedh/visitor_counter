{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.responseCache = exports.promiseCache = void 0;\nexports.getCache = getCache;\nexports.withCache = withCache;\nexports.promiseCache = new Map();\nexports.responseCache = new Map();\nfunction getCache(cacheKey) {\n  const buildCache = (cacheKey, cache) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: data => cache.set(cacheKey, data)\n  });\n  const promise = buildCache(cacheKey, exports.promiseCache);\n  const response = buildCache(cacheKey, exports.responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\nasync function withCache(fn, {\n  cacheKey,\n  cacheTime = Number.POSITIVE_INFINITY\n}) {\n  const cache = getCache(cacheKey);\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) return response.data;\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    cache.promise.clear();\n  }\n}","map":{"version":3,"names":["exports","getCache","withCache","promiseCache","Map","responseCache","cacheKey","buildCache","cache","clear","delete","get","set","data","promise","response","fn","cacheTime","Number","POSITIVE_INFINITY","age","Date","getTime","created"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/promise/withCache.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\n\n/** @internal */\nexport const promiseCache = /*#__PURE__*/ new Map()\n/** @internal */\nexport const responseCache = /*#__PURE__*/ new Map()\n\nexport type GetCacheErrorType = ErrorType\n\nexport function getCache<data>(cacheKey: string) {\n  const buildCache = <data>(cacheKey: string, cache: Map<string, data>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: data) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<data>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: data }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number | undefined\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<data>(\n  fn: () => Promise<data>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<data>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < cacheTime) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  try {\n    const data = await promise\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data })\n\n    return data\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear()\n  }\n}\n"],"mappings":";;;;;;AASAA,OAAA,CAAAC,QAAA,GAAAA,QAAA;AAkCAD,OAAA,CAAAE,SAAA,GAAAA,SAAA;AAxCaF,OAAA,CAAAG,YAAY,GAAiB,IAAIC,GAAG,EAAE;AAEtCJ,OAAA,CAAAK,aAAa,GAAiB,IAAID,GAAG,EAAE;AAIpD,SAAgBH,QAAQA,CAAOK,QAAgB;EAC7C,MAAMC,UAAU,GAAGA,CAAOD,QAAgB,EAAEE,KAAwB,MAAM;IACxEC,KAAK,EAAEA,CAAA,KAAMD,KAAK,CAACE,MAAM,CAACJ,QAAQ,CAAC;IACnCK,GAAG,EAAEA,CAAA,KAAMH,KAAK,CAACG,GAAG,CAACL,QAAQ,CAAC;IAC9BM,GAAG,EAAGC,IAAU,IAAKL,KAAK,CAACI,GAAG,CAACN,QAAQ,EAAEO,IAAI;GAC9C,CAAC;EAEF,MAAMC,OAAO,GAAGP,UAAU,CAAgBD,QAAQ,EAAEN,OAAA,CAAAG,YAAY,CAAC;EACjE,MAAMY,QAAQ,GAAGR,UAAU,CACzBD,QAAQ,EACRN,OAAA,CAAAK,aAAa,CACd;EAED,OAAO;IACLI,KAAK,EAAEA,CAAA,KAAK;MACVK,OAAO,CAACL,KAAK,EAAE;MACfM,QAAQ,CAACN,KAAK,EAAE;IAClB,CAAC;IACDK,OAAO;IACPC;GACD;AACH;AAaO,eAAeb,SAASA,CAC7Bc,EAAuB,EACvB;EAAEV,QAAQ;EAAEW,SAAS,GAAGC,MAAM,CAACC;AAAiB,CAAuB;EAEvE,MAAMX,KAAK,GAAGP,QAAQ,CAAOK,QAAQ,CAAC;EAKtC,MAAMS,QAAQ,GAAGP,KAAK,CAACO,QAAQ,CAACJ,GAAG,EAAE;EACrC,IAAII,QAAQ,IAAIE,SAAS,GAAG,CAAC,EAAE;IAC7B,MAAMG,GAAG,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGP,QAAQ,CAACQ,OAAO,CAACD,OAAO,EAAE;IAC7D,IAAIF,GAAG,GAAGH,SAAS,EAAE,OAAOF,QAAQ,CAACF,IAAI;EAC3C;EAEA,IAAIC,OAAO,GAAGN,KAAK,CAACM,OAAO,CAACH,GAAG,EAAE;EACjC,IAAI,CAACG,OAAO,EAAE;IACZA,OAAO,GAAGE,EAAE,EAAE;IAIdR,KAAK,CAACM,OAAO,CAACF,GAAG,CAACE,OAAO,CAAC;EAC5B;EAEA,IAAI;IACF,MAAMD,IAAI,GAAG,MAAMC,OAAO;IAI1BN,KAAK,CAACO,QAAQ,CAACH,GAAG,CAAC;MAAEW,OAAO,EAAE,IAAIF,IAAI,EAAE;MAAER;IAAI,CAAE,CAAC;IAEjD,OAAOA,IAAI;EACb,CAAC,SAAS;IAGRL,KAAK,CAACM,OAAO,CAACL,KAAK,EAAE;EACvB;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}