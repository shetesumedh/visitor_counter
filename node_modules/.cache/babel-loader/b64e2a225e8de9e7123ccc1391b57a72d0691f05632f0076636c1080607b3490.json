{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Cipher = void 0;\nconst util_1 = require(\"../core/util\");\nclass Cipher {\n  // @param secret hex representation of 32-byte secret\n  constructor(secret) {\n    this.secret = secret;\n  }\n  /**\n   *\n   * @param plainText string to be encrypted\n   * returns hex string representation of bytes in the order: initialization vector (iv),\n   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n   * encrypted plainText.\n   */\n  async encrypt(plainText) {\n    const secret = this.secret;\n    if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n    const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n    const secretKey = await crypto.subtle.importKey('raw', (0, util_1.hexStringToUint8Array)(secret), {\n      name: 'aes-gcm'\n    }, false, ['encrypt', 'decrypt']);\n    const enc = new TextEncoder();\n    // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n    const encryptedResult = await window.crypto.subtle.encrypt({\n      name: 'AES-GCM',\n      iv: ivBytes\n    }, secretKey, enc.encode(plainText));\n    const tagLength = 16;\n    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n    const authTagBytes = new Uint8Array(authTag);\n    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n    const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n    return (0, util_1.uint8ArrayToHex)(concatted);\n  }\n  /**\n   *\n   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n   */\n  async decrypt(cipherText) {\n    const secret = this.secret;\n    if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n    return new Promise((resolve, reject) => {\n      void async function () {\n        const secretKey = await crypto.subtle.importKey('raw', (0, util_1.hexStringToUint8Array)(secret), {\n          name: 'aes-gcm'\n        }, false, ['encrypt', 'decrypt']);\n        const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n        const ivBytes = encrypted.slice(0, 12);\n        const authTagBytes = encrypted.slice(12, 28);\n        const encryptedPlaintextBytes = encrypted.slice(28);\n        const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n        const algo = {\n          name: 'AES-GCM',\n          iv: new Uint8Array(ivBytes)\n        };\n        try {\n          const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n          const decoder = new TextDecoder();\n          resolve(decoder.decode(decrypted));\n        } catch (err) {\n          reject(err);\n        }\n      }();\n    });\n  }\n}\nexports.Cipher = Cipher;","map":{"version":3,"names":["Object","defineProperty","exports","value","Cipher","util_1","require","constructor","secret","encrypt","plainText","length","Error","ivBytes","crypto","getRandomValues","Uint8Array","secretKey","subtle","importKey","hexStringToUint8Array","name","enc","TextEncoder","encryptedResult","window","iv","encode","tagLength","authTag","slice","byteLength","encryptedPlaintext","authTagBytes","encryptedPlaintextBytes","concatted","uint8ArrayToHex","decrypt","cipherText","Promise","resolve","reject","encrypted","concattedBytes","algo","decrypted","decoder","TextDecoder","decode","err"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/cbw-sdk/dist/lib/Cipher.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cipher = void 0;\nconst util_1 = require(\"../core/util\");\nclass Cipher {\n    // @param secret hex representation of 32-byte secret\n    constructor(secret) {\n        this.secret = secret;\n    }\n    /**\n     *\n     * @param plainText string to be encrypted\n     * returns hex string representation of bytes in the order: initialization vector (iv),\n     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n     * encrypted plainText.\n     */\n    async encrypt(plainText) {\n        const secret = this.secret;\n        if (secret.length !== 64)\n            throw Error(`secret must be 256 bits`);\n        const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n        const secretKey = await crypto.subtle.importKey('raw', (0, util_1.hexStringToUint8Array)(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);\n        const enc = new TextEncoder();\n        // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n        const encryptedResult = await window.crypto.subtle.encrypt({\n            name: 'AES-GCM',\n            iv: ivBytes,\n        }, secretKey, enc.encode(plainText));\n        const tagLength = 16;\n        const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n        const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n        const authTagBytes = new Uint8Array(authTag);\n        const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n        const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n        return (0, util_1.uint8ArrayToHex)(concatted);\n    }\n    /**\n     *\n     * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n     */\n    async decrypt(cipherText) {\n        const secret = this.secret;\n        if (secret.length !== 64)\n            throw Error(`secret must be 256 bits`);\n        return new Promise((resolve, reject) => {\n            void (async function () {\n                const secretKey = await crypto.subtle.importKey('raw', (0, util_1.hexStringToUint8Array)(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);\n                const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n                const ivBytes = encrypted.slice(0, 12);\n                const authTagBytes = encrypted.slice(12, 28);\n                const encryptedPlaintextBytes = encrypted.slice(28);\n                const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n                const algo = {\n                    name: 'AES-GCM',\n                    iv: new Uint8Array(ivBytes),\n                };\n                try {\n                    const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n                    const decoder = new TextDecoder();\n                    resolve(decoder.decode(decrypted));\n                }\n                catch (err) {\n                    reject(err);\n                }\n            })();\n        });\n    }\n}\nexports.Cipher = Cipher;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}