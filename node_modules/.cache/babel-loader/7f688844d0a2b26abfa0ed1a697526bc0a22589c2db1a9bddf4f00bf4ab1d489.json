{"ast":null,"code":"import { parseAccount } from '../../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../../errors/account.js';\nimport { getAction } from '../../../utils/getAction.js';\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js';\nimport { formatUserOperationRequest } from '../../utils/formatters/userOperationRequest.js';\nimport { prepareUserOperation } from './prepareUserOperation.js';\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation(client, parameters) {\n  const {\n    account: account_ = client.account,\n    entryPointAddress\n  } = parameters;\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError();\n  const account = account_ ? parseAccount(account_) : undefined;\n  const request = account ? await getAction(client, prepareUserOperation, 'prepareUserOperation')(parameters) : parameters;\n  const signature = parameters.signature || (await account?.signUserOperation?.(request));\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature\n  });\n  try {\n    return await client.request({\n      method: 'eth_sendUserOperation',\n      params: [rpcParameters, entryPointAddress ?? account?.entryPoint?.address]\n    }, {\n      retryCount: 0\n    });\n  } catch (error) {\n    const calls = parameters.calls;\n    throw getUserOperationError(error, {\n      ...request,\n      ...(calls ? {\n        calls\n      } : {}),\n      signature\n    });\n  }\n}","map":{"version":3,"names":["parseAccount","AccountNotFoundError","getAction","getUserOperationError","formatUserOperationRequest","prepareUserOperation","sendUserOperation","client","parameters","account","account_","entryPointAddress","sender","undefined","request","signature","signUserOperation","rpcParameters","method","params","entryPoint","address","retryCount","error","calls"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/account-abstraction/actions/bundler/sendUserOperation.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Assign, MaybeRequired, OneOf } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type SendUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  >\nexport type SendUserOperationReturnType = Hex\n\nexport type SendUserOperationErrorType =\n  | FormatUserOperationRequestErrorType\n  | PrepareUserOperationErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationParameters<account, accountOverride, calls>,\n) {\n  const { account: account_ = client.account, entryPointAddress } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )(parameters as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  const signature = (parameters.signature ||\n    (await account?.signUserOperation?.(request as UserOperation)))!\n\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature,\n  } as UserOperation)\n\n  try {\n    return await client.request(\n      {\n        method: 'eth_sendUserOperation',\n        params: [\n          rpcParameters,\n          (entryPointAddress ?? account?.entryPoint?.address)!,\n        ],\n      },\n      { retryCount: 0 },\n    )\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n      signature,\n    })\n  }\n}\n"],"mappings":"AACA,SAASA,YAAY,QAAQ,yCAAyC;AAGtE,SAASC,oBAAoB,QAAQ,4BAA4B;AAQjE,SAASC,SAAS,QAAQ,6BAA6B;AAevD,SAASC,qBAAqB,QAAQ,6CAA6C;AACnF,SAEEC,0BAA0B,QACrB,gDAAgD;AACvD,SAGEC,oBAAoB,QACf,2BAA2B;AAoDlC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAO,eAAeC,iBAAiBA,CAKrCC,MAAqD,EACrDC,UAAwE;EAExE,MAAM;IAAEC,OAAO,EAAEC,QAAQ,GAAGH,MAAM,CAACE,OAAO;IAAEE;EAAiB,CAAE,GAAGH,UAAU;EAE5E,IAAI,CAACE,QAAQ,IAAI,CAACF,UAAU,CAACI,MAAM,EAAE,MAAM,IAAIX,oBAAoB,EAAE;EACrE,MAAMQ,OAAO,GAAGC,QAAQ,GAAGV,YAAY,CAACU,QAAQ,CAAC,GAAGG,SAAS;EAE7D,MAAMC,OAAO,GAAGL,OAAO,GACnB,MAAMP,SAAS,CACbK,MAAM,EACNF,oBAAoB,EACpB,sBAAsB,CACvB,CAACG,UAAuD,CAAC,GAC1DA,UAAU;EAEd,MAAMO,SAAS,GAAIP,UAAU,CAACO,SAAS,KACpC,MAAMN,OAAO,EAAEO,iBAAiB,GAAGF,OAAwB,CAAC,CAAG;EAElE,MAAMG,aAAa,GAAGb,0BAA0B,CAAC;IAC/C,GAAGU,OAAO;IACVC;GACgB,CAAC;EAEnB,IAAI;IACF,OAAO,MAAMR,MAAM,CAACO,OAAO,CACzB;MACEI,MAAM,EAAE,uBAAuB;MAC/BC,MAAM,EAAE,CACNF,aAAa,EACZN,iBAAiB,IAAIF,OAAO,EAAEW,UAAU,EAAEC,OAAO;KAErD,EACD;MAAEC,UAAU,EAAE;IAAC,CAAE,CAClB;EACH,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,MAAMC,KAAK,GAAIhB,UAAkB,CAACgB,KAAK;IACvC,MAAMrB,qBAAqB,CAACoB,KAAkB,EAAE;MAC9C,GAAIT,OAAyB;MAC7B,IAAIU,KAAK,GAAG;QAAEA;MAAK,CAAE,GAAG,EAAE,CAAC;MAC3BT;KACD,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}