{"ast":null,"code":"import { PACKAGE_NAME, PACKAGE_VERSION } from '../core/constants.js';\nimport { standardErrors } from '../core/error/errors.js';\nexport async function fetchRPCRequest(request, rpcUrl) {\n  const requestBody = Object.assign(Object.assign({}, request), {\n    jsonrpc: '2.0',\n    id: crypto.randomUUID()\n  });\n  const res = await window.fetch(rpcUrl, {\n    method: 'POST',\n    body: JSON.stringify(requestBody),\n    mode: 'cors',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Cbw-Sdk-Version': PACKAGE_VERSION,\n      'X-Cbw-Sdk-Platform': PACKAGE_NAME\n    }\n  });\n  const {\n    result,\n    error\n  } = await res.json();\n  if (error) throw error;\n  return result;\n}\n/**\n * Validates the arguments for an invalid request and returns an error if any validation fails.\n * Valid request args are defined here: https://eips.ethereum.org/EIPS/eip-1193#request\n * @param args The request arguments to validate.\n * @returns An error object if the arguments are invalid, otherwise undefined.\n */\nexport function checkErrorForInvalidRequestArgs(args) {\n  if (!args || typeof args !== 'object' || Array.isArray(args)) {\n    throw standardErrors.rpc.invalidParams({\n      message: 'Expected a single, non-array, object argument.',\n      data: args\n    });\n  }\n  const {\n    method,\n    params\n  } = args;\n  if (typeof method !== 'string' || method.length === 0) {\n    throw standardErrors.rpc.invalidParams({\n      message: \"'args.method' must be a non-empty string.\",\n      data: args\n    });\n  }\n  if (params !== undefined && !Array.isArray(params) && (typeof params !== 'object' || params === null)) {\n    throw standardErrors.rpc.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\",\n      data: args\n    });\n  }\n  switch (method) {\n    case 'eth_sign':\n    case 'eth_signTypedData_v2':\n    case 'eth_subscribe':\n    case 'eth_unsubscribe':\n      throw standardErrors.provider.unsupportedMethod();\n  }\n}","map":{"version":3,"names":["PACKAGE_NAME","PACKAGE_VERSION","standardErrors","fetchRPCRequest","request","rpcUrl","requestBody","Object","assign","jsonrpc","id","crypto","randomUUID","res","window","fetch","method","body","JSON","stringify","mode","headers","result","error","json","checkErrorForInvalidRequestArgs","args","Array","isArray","rpc","invalidParams","message","data","params","length","undefined","provider","unsupportedMethod"],"sources":["../../src/util/provider.ts"],"sourcesContent":[null],"mappings":"AAAA,SAASA,YAAY,EAAEC,eAAe,QAAQ,sBAAqB;AACnE,SAASC,cAAc,QAAQ,yBAAwB;AAGvD,OAAO,eAAeC,eAAeA,CAACC,OAAyB,EAAEC,MAAc;EAC7E,MAAMC,WAAW,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACZJ,OAAO;IACVK,OAAO,EAAE,KAAK;IACdC,EAAE,EAAEC,MAAM,CAACC,UAAU;EAAE,EACxB;EACD,MAAMC,GAAG,GAAG,MAAMC,MAAM,CAACC,KAAK,CAACV,MAAM,EAAE;IACrCW,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACb,WAAW,CAAC;IACjCc,IAAI,EAAE,MAAM;IACZC,OAAO,EAAE;MACP,cAAc,EAAE,kBAAkB;MAClC,mBAAmB,EAAEpB,eAAe;MACpC,oBAAoB,EAAED;;GAEzB,CAAC;EACF,MAAM;IAAEsB,MAAM;IAAEC;EAAK,CAAE,GAAG,MAAMV,GAAG,CAACW,IAAI,EAAE;EAC1C,IAAID,KAAK,EAAE,MAAMA,KAAK;EACtB,OAAOD,MAAM;AACf;AAEA;;;;;;AAMA,OAAM,SAAUG,+BAA+BA,CAACC,IAAa;EAC3D,IAAI,CAACA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IAC5D,MAAMxB,cAAc,CAAC2B,GAAG,CAACC,aAAa,CAAC;MACrCC,OAAO,EAAE,gDAAgD;MACzDC,IAAI,EAAEN;KACP,CAAC;EACJ;EAEA,MAAM;IAAEV,MAAM;IAAEiB;EAAM,CAAE,GAAGP,IAAwB;EAEnD,IAAI,OAAOV,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACkB,MAAM,KAAK,CAAC,EAAE;IACrD,MAAMhC,cAAc,CAAC2B,GAAG,CAACC,aAAa,CAAC;MACrCC,OAAO,EAAE,2CAA2C;MACpDC,IAAI,EAAEN;KACP,CAAC;EACJ;EAEA,IACEO,MAAM,KAAKE,SAAS,IACpB,CAACR,KAAK,CAACC,OAAO,CAACK,MAAM,CAAC,KACrB,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,CAAC,EAC/C;IACA,MAAM/B,cAAc,CAAC2B,GAAG,CAACC,aAAa,CAAC;MACrCC,OAAO,EAAE,uDAAuD;MAChEC,IAAI,EAAEN;KACP,CAAC;EACJ;EAEA,QAAQV,MAAM;IACZ,KAAK,UAAU;IACf,KAAK,sBAAsB;IAC3B,KAAK,eAAe;IACpB,KAAK,iBAAiB;MACpB,MAAMd,cAAc,CAACkC,QAAQ,CAACC,iBAAiB,EAAE;EACrD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}