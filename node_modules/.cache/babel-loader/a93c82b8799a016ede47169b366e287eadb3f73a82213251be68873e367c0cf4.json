{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTupleRegex = exports.integerRegex = exports.bytesRegex = void 0;\nexports.execTyped = execTyped;\nfunction execTyped(regex, string) {\n  const match = regex.exec(string);\n  return match?.groups;\n}\nexports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nexports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexports.isTupleRegex = /^\\(.+?\\).*?$/;","map":{"version":3,"names":["exports","execTyped","regex","string","match","exec","groups","bytesRegex","integerRegex","isTupleRegex"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/abitype/src/regex.ts"],"sourcesContent":["// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n"],"mappings":";;;;;;AAEAA,OAAA,CAAAC,SAAA,GAAAA,SAAA;AAAA,SAAgBA,SAASA,CAAOC,KAAa,EAAEC,MAAc;EAC3D,MAAMC,KAAK,GAAGF,KAAK,CAACG,IAAI,CAACF,MAAM,CAAC;EAChC,OAAOC,KAAK,EAAEE,MAA0B;AAC1C;AAIaN,OAAA,CAAAO,UAAU,GAAG,sCAAsC;AAInDP,OAAA,CAAAQ,YAAY,GACvB,8HAA8H;AAEnHR,OAAA,CAAAS,YAAY,GAAG,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}