{"ast":null,"code":"import { ChainDisconnectedError, ProviderDisconnectedError, createTransport, hexToNumber, withRetry, withTimeout } from 'viem';\nexport function unstable_connector(connector, config = {}) {\n  const {\n    type\n  } = connector;\n  const {\n    key = 'connector',\n    name = 'Connector',\n    retryDelay\n  } = config;\n  return parameters => {\n    const {\n      chain,\n      connectors\n    } = parameters;\n    const retryCount = config.retryCount ?? parameters.retryCount;\n    const request = async ({\n      method,\n      params\n    }) => {\n      const connector = connectors?.getState().find(c => c.type === type);\n      if (!connector) throw new ProviderDisconnectedError(new Error(`Could not find connector of type \"${type}\" in \\`connectors\\` passed to \\`createConfig\\`.`));\n      const provider = await connector.getProvider({\n        chainId: chain?.id\n      });\n      if (!provider) throw new ProviderDisconnectedError(new Error('Provider is disconnected.'));\n      // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to\n      // immediately resolve a JSON-RPC request on page load.\n      const chainId = hexToNumber(await withRetry(() => withTimeout(() => provider.request({\n        method: 'eth_chainId'\n      }), {\n        timeout: 100\n      })));\n      if (chain && chainId !== chain.id) throw new ChainDisconnectedError(new Error(`The current chain of the connector (id: ${chainId}) does not match the target chain for the request (id: ${chain.id} – ${chain.name}).`));\n      const body = {\n        method,\n        params\n      };\n      return provider.request(body);\n    };\n    return createTransport({\n      key,\n      name,\n      request,\n      retryCount,\n      retryDelay,\n      type: 'connector'\n    });\n  };\n}","map":{"version":3,"names":["ChainDisconnectedError","ProviderDisconnectedError","createTransport","hexToNumber","withRetry","withTimeout","unstable_connector","connector","config","type","key","name","retryDelay","parameters","chain","connectors","retryCount","request","method","params","getState","find","c","Error","provider","getProvider","chainId","id","timeout","body"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/core/src/transports/connector.ts"],"sourcesContent":["import {\n  ChainDisconnectedError,\n  type EIP1193Parameters,\n  type EIP1193Provider,\n  type EIP1193RequestFn,\n  ProviderDisconnectedError,\n  type TransportConfig,\n  type WalletRpcSchema,\n  createTransport,\n  hexToNumber,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nimport type { Connector, Transport } from '../createConfig.js'\n\nexport type ConnectorTransportConfig = {\n  /** The key of the transport. */\n  key?: TransportConfig['key'] | undefined\n  /** The name of the transport. */\n  name?: TransportConfig['name'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n}\n\nexport type ConnectorTransport = Transport\n\nexport function unstable_connector(\n  connector: Pick<Connector, 'type'>,\n  config: ConnectorTransportConfig = {},\n): Transport<'connector'> {\n  const { type } = connector\n  const { key = 'connector', name = 'Connector', retryDelay } = config\n\n  return (parameters) => {\n    const { chain, connectors } = parameters\n    const retryCount = config.retryCount ?? parameters.retryCount\n\n    const request: EIP1193RequestFn = async ({ method, params }) => {\n      const connector = connectors?.getState().find((c) => c.type === type)\n      if (!connector)\n        throw new ProviderDisconnectedError(\n          new Error(\n            `Could not find connector of type \"${type}\" in \\`connectors\\` passed to \\`createConfig\\`.`,\n          ),\n        )\n\n      const provider = (await connector.getProvider({\n        chainId: chain?.id,\n      })) as EIP1193Provider | undefined\n      if (!provider)\n        throw new ProviderDisconnectedError(\n          new Error('Provider is disconnected.'),\n        )\n\n      // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to\n      // immediately resolve a JSON-RPC request on page load.\n      const chainId = hexToNumber(\n        await withRetry(() =>\n          withTimeout(() => provider.request({ method: 'eth_chainId' }), {\n            timeout: 100,\n          }),\n        ),\n      )\n      if (chain && chainId !== chain.id)\n        throw new ChainDisconnectedError(\n          new Error(\n            `The current chain of the connector (id: ${chainId}) does not match the target chain for the request (id: ${chain.id} – ${chain.name}).`,\n          ),\n        )\n\n      const body = { method, params } as EIP1193Parameters<WalletRpcSchema>\n      return provider.request(body)\n    }\n\n    return createTransport({\n      key,\n      name,\n      request,\n      retryCount,\n      retryDelay,\n      type: 'connector',\n    })\n  }\n}\n"],"mappings":"AAAA,SACEA,sBAAsB,EAItBC,yBAAyB,EAGzBC,eAAe,EACfC,WAAW,EACXC,SAAS,EACTC,WAAW,QACN,MAAM;AAiBb,OAAM,SAAUC,kBAAkBA,CAChCC,SAAkC,EAClCC,MAAA,GAAmC,EAAE;EAErC,MAAM;IAAEC;EAAI,CAAE,GAAGF,SAAS;EAC1B,MAAM;IAAEG,GAAG,GAAG,WAAW;IAAEC,IAAI,GAAG,WAAW;IAAEC;EAAU,CAAE,GAAGJ,MAAM;EAEpE,OAAQK,UAAU,IAAI;IACpB,MAAM;MAAEC,KAAK;MAAEC;IAAU,CAAE,GAAGF,UAAU;IACxC,MAAMG,UAAU,GAAGR,MAAM,CAACQ,UAAU,IAAIH,UAAU,CAACG,UAAU;IAE7D,MAAMC,OAAO,GAAqB,MAAAA,CAAO;MAAEC,MAAM;MAAEC;IAAM,CAAE,KAAI;MAC7D,MAAMZ,SAAS,GAAGQ,UAAU,EAAEK,QAAQ,EAAE,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACb,IAAI,KAAKA,IAAI,CAAC;MACrE,IAAI,CAACF,SAAS,EACZ,MAAM,IAAIN,yBAAyB,CACjC,IAAIsB,KAAK,CACP,qCAAqCd,IAAI,iDAAiD,CAC3F,CACF;MAEH,MAAMe,QAAQ,GAAI,MAAMjB,SAAS,CAACkB,WAAW,CAAC;QAC5CC,OAAO,EAAEZ,KAAK,EAAEa;OACjB,CAAiC;MAClC,IAAI,CAACH,QAAQ,EACX,MAAM,IAAIvB,yBAAyB,CACjC,IAAIsB,KAAK,CAAC,2BAA2B,CAAC,CACvC;MAEH;MACA;MACA,MAAMG,OAAO,GAAGvB,WAAW,CACzB,MAAMC,SAAS,CAAC,MACdC,WAAW,CAAC,MAAMmB,QAAQ,CAACP,OAAO,CAAC;QAAEC,MAAM,EAAE;MAAa,CAAE,CAAC,EAAE;QAC7DU,OAAO,EAAE;OACV,CAAC,CACH,CACF;MACD,IAAId,KAAK,IAAIY,OAAO,KAAKZ,KAAK,CAACa,EAAE,EAC/B,MAAM,IAAI3B,sBAAsB,CAC9B,IAAIuB,KAAK,CACP,2CAA2CG,OAAO,0DAA0DZ,KAAK,CAACa,EAAE,MAAMb,KAAK,CAACH,IAAI,IAAI,CACzI,CACF;MAEH,MAAMkB,IAAI,GAAG;QAAEX,MAAM;QAAEC;MAAM,CAAwC;MACrE,OAAOK,QAAQ,CAACP,OAAO,CAACY,IAAI,CAAC;IAC/B,CAAC;IAED,OAAO3B,eAAe,CAAC;MACrBQ,GAAG;MACHC,IAAI;MACJM,OAAO;MACPD,UAAU;MACVJ,UAAU;MACVH,IAAI,EAAE;KACP,CAAC;EACJ,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}