{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getHttpRpcClient = getHttpRpcClient;\nconst request_js_1 = require(\"../../errors/request.js\");\nconst withTimeout_js_1 = require(\"../promise/withTimeout.js\");\nconst stringify_js_1 = require(\"../stringify.js\");\nconst id_js_1 = require(\"./id.js\");\nfunction getHttpRpcClient(url, options = {}) {\n  return {\n    async request(params) {\n      const {\n        body,\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000\n      } = params;\n      const fetchOptions = {\n        ...(options.fetchOptions ?? {}),\n        ...(params.fetchOptions ?? {})\n      };\n      const {\n        headers,\n        method,\n        signal: signal_\n      } = fetchOptions;\n      try {\n        const response = await (0, withTimeout_js_1.withTimeout)(async ({\n          signal\n        }) => {\n          const init = {\n            ...fetchOptions,\n            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map(body => ({\n              jsonrpc: '2.0',\n              id: body.id ?? id_js_1.idCache.take(),\n              ...body\n            }))) : (0, stringify_js_1.stringify)({\n              jsonrpc: '2.0',\n              id: body.id ?? id_js_1.idCache.take(),\n              ...body\n            }),\n            headers: {\n              'Content-Type': 'application/json',\n              ...headers\n            },\n            method: method || 'POST',\n            signal: signal_ || (timeout > 0 ? signal : null)\n          };\n          const request = new Request(url, init);\n          const args = (await onRequest?.(request, init)) ?? {\n            ...init,\n            url\n          };\n          const response = await fetch(args.url ?? url, args);\n          return response;\n        }, {\n          errorInstance: new request_js_1.TimeoutError({\n            body,\n            url\n          }),\n          timeout,\n          signal: true\n        });\n        if (onResponse) await onResponse(response);\n        let data;\n        if (response.headers.get('Content-Type')?.startsWith('application/json')) data = await response.json();else {\n          data = await response.text();\n          try {\n            data = JSON.parse(data || '{}');\n          } catch (err) {\n            if (response.ok) throw err;\n            data = {\n              error: data\n            };\n          }\n        }\n        if (!response.ok) {\n          throw new request_js_1.HttpRequestError({\n            body,\n            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url\n          });\n        }\n        return data;\n      } catch (err) {\n        if (err instanceof request_js_1.HttpRequestError) throw err;\n        if (err instanceof request_js_1.TimeoutError) throw err;\n        throw new request_js_1.HttpRequestError({\n          body,\n          cause: err,\n          url\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["exports","getHttpRpcClient","request_js_1","require","withTimeout_js_1","stringify_js_1","id_js_1","url","options","request","params","body","onRequest","onResponse","timeout","fetchOptions","headers","method","signal","signal_","response","withTimeout","init","Array","isArray","stringify","map","jsonrpc","id","idCache","take","Request","args","fetch","errorInstance","TimeoutError","data","get","startsWith","json","text","JSON","parse","err","ok","error","HttpRequestError","details","statusText","status","cause"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/utils/rpc/http.ts"],"sourcesContent":["import {\n  HttpRequestError,\n  type HttpRequestErrorType as HttpRequestErrorType_,\n  TimeoutError,\n  type TimeoutErrorType,\n} from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport type { MaybePromise } from '../../types/utils.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from '../promise/withTimeout.js'\nimport { stringify } from '../stringify.js'\nimport { idCache } from './id.js'\n\nexport type HttpRpcClientOptions = {\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: Omit<RequestInit, 'body'> | undefined\n  /** A callback to handle the request. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: number | undefined\n}\n\nexport type HttpRequestParameters<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = {\n  /** The RPC request body. */\n  body: body\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined\n  /** A callback to handle the response. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: HttpRpcClientOptions['timeout'] | undefined\n}\n\nexport type HttpRequestReturnType<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = body extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpRequestErrorType =\n  | HttpRequestErrorType_\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nexport type HttpRpcClient = {\n  request<body extends RpcRequest | RpcRequest[]>(\n    params: HttpRequestParameters<body>,\n  ): Promise<HttpRequestReturnType<body>>\n}\n\nexport function getHttpRpcClient(\n  url: string,\n  options: HttpRpcClientOptions = {},\n): HttpRpcClient {\n  return {\n    async request(params) {\n      const {\n        body,\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000,\n      } = params\n\n      const fetchOptions = {\n        ...(options.fetchOptions ?? {}),\n        ...(params.fetchOptions ?? {}),\n      }\n\n      const { headers, method, signal: signal_ } = fetchOptions\n\n      try {\n        const response = await withTimeout(\n          async ({ signal }) => {\n            const init: RequestInit = {\n              ...fetchOptions,\n              body: Array.isArray(body)\n                ? stringify(\n                    body.map((body) => ({\n                      jsonrpc: '2.0',\n                      id: body.id ?? idCache.take(),\n                      ...body,\n                    })),\n                  )\n                : stringify({\n                    jsonrpc: '2.0',\n                    id: body.id ?? idCache.take(),\n                    ...body,\n                  }),\n              headers: {\n                'Content-Type': 'application/json',\n                ...headers,\n              },\n              method: method || 'POST',\n              signal: signal_ || (timeout > 0 ? signal : null),\n            }\n            const request = new Request(url, init)\n            const args = (await onRequest?.(request, init)) ?? { ...init, url }\n            const response = await fetch(args.url ?? url, args)\n            return response\n          },\n          {\n            errorInstance: new TimeoutError({ body, url }),\n            timeout,\n            signal: true,\n          },\n        )\n\n        if (onResponse) await onResponse(response)\n\n        let data: any\n        if (\n          response.headers.get('Content-Type')?.startsWith('application/json')\n        )\n          data = await response.json()\n        else {\n          data = await response.text()\n          try {\n            data = JSON.parse(data || '{}')\n          } catch (err) {\n            if (response.ok) throw err\n            data = { error: data }\n          }\n        }\n\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url,\n          })\n        }\n\n        return data\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err\n        if (err instanceof TimeoutError) throw err\n        throw new HttpRequestError({\n          body,\n          cause: err as Error,\n          url,\n        })\n      }\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}