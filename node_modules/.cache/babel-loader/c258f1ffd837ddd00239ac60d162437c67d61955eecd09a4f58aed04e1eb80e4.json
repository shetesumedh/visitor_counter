{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;\nexports.offchainLookup = offchainLookup;\nexports.ccipRequest = ccipRequest;\nconst call_js_1 = require(\"../actions/public/call.js\");\nconst ccip_js_1 = require(\"../errors/ccip.js\");\nconst request_js_1 = require(\"../errors/request.js\");\nconst decodeErrorResult_js_1 = require(\"./abi/decodeErrorResult.js\");\nconst encodeAbiParameters_js_1 = require(\"./abi/encodeAbiParameters.js\");\nconst isAddressEqual_js_1 = require(\"./address/isAddressEqual.js\");\nconst concat_js_1 = require(\"./data/concat.js\");\nconst isHex_js_1 = require(\"./data/isHex.js\");\nconst localBatchGatewayRequest_js_1 = require(\"./ens/localBatchGatewayRequest.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nexports.offchainLookupSignature = '0x556f1830';\nexports.offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nasync function offchainLookup(client, {\n  blockNumber,\n  blockTag,\n  data,\n  to\n}) {\n  const {\n    args\n  } = (0, decodeErrorResult_js_1.decodeErrorResult)({\n    data,\n    abi: [exports.offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  const {\n    ccipRead\n  } = client;\n  const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function' ? ccipRead.request : ccipRequest;\n  try {\n    if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender)) throw new ccip_js_1.OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = urls.includes(localBatchGatewayRequest_js_1.localBatchGatewayUrl) ? await (0, localBatchGatewayRequest_js_1.localBatchGatewayRequest)({\n      data: callData,\n      ccipRequest: ccipRequest_\n    }) : await ccipRequest_({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await (0, call_js_1.call)(client, {\n      blockNumber,\n      blockTag,\n      data: (0, concat_js_1.concat)([callbackSelector, (0, encodeAbiParameters_js_1.encodeAbiParameters)([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new ccip_js_1.OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nasync function ccipRequest({\n  data,\n  sender,\n  urls\n}) {\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    const headers = method === 'POST' ? {\n      'Content-Type': 'application/json'\n    } : {};\n    try {\n      const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {\n        body: JSON.stringify(body),\n        headers,\n        method\n      });\n      let result;\n      if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new request_js_1.HttpRequestError({\n          body,\n          details: result?.error ? (0, stringify_js_1.stringify)(result.error) : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!(0, isHex_js_1.isHex)(result)) {\n        error = new ccip_js_1.OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new request_js_1.HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","map":{"version":3,"names":["exports","offchainLookup","ccipRequest","call_js_1","require","ccip_js_1","request_js_1","decodeErrorResult_js_1","encodeAbiParameters_js_1","isAddressEqual_js_1","concat_js_1","isHex_js_1","localBatchGatewayRequest_js_1","stringify_js_1","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","client","blockNumber","blockTag","data","to","args","decodeErrorResult","abi","sender","urls","callData","callbackSelector","extraData","ccipRead","ccipRequest_","request","isAddressEqual","OffchainLookupSenderMismatchError","result","includes","localBatchGatewayUrl","localBatchGatewayRequest","data_","call","concat","encodeAbiParameters","err","OffchainLookupError","cause","error","Error","i","length","url","method","body","undefined","headers","response","fetch","replace","toLowerCase","JSON","stringify","get","startsWith","json","text","ok","HttpRequestError","details","statusText","status","isHex","OffchainLookupResponseMalformedError","message"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}