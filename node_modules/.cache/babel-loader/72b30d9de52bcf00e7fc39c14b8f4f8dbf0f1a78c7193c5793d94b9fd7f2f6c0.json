{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nconst abitype = require(\"abitype\");\nconst AbiItem = require(\"./AbiItem.js\");\nconst AbiParameters = require(\"./AbiParameters.js\");\nconst Hex = require(\"./Hex.js\");\nfunction decode(abiConstructor, options) {\n  const {\n    bytecode\n  } = options;\n  if (abiConstructor.inputs.length === 0) return undefined;\n  const data = options.data.replace(bytecode, '0x');\n  return AbiParameters.decode(abiConstructor.inputs, data);\n}\nfunction encode(abiConstructor, options) {\n  const {\n    bytecode,\n    args\n  } = options;\n  return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length ? AbiParameters.encode(abiConstructor.inputs, args) : '0x');\n}\nfunction format(abiConstructor) {\n  return abitype.formatAbiItem(abiConstructor);\n}\nfunction from(abiConstructor) {\n  return AbiItem.from(abiConstructor);\n}\nfunction fromAbi(abi) {\n  const item = abi.find(item => item.type === 'constructor');\n  if (!item) throw new AbiItem.NotFoundError({\n    name: 'constructor'\n  });\n  return item;\n}","map":{"version":3,"names":["exports","decode","encode","format","from","fromAbi","abitype","require","AbiItem","AbiParameters","Hex","abiConstructor","options","bytecode","inputs","length","undefined","data","replace","args","concat","formatAbiItem","abi","item","find","type","NotFoundError","name"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/AbiConstructor.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiConstructor.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `constructor` type. */\nexport type AbiConstructor = abitype.AbiConstructor\n\n/** @internal */\nexport function decode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\n/**\n * ABI-decodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const bytecode = '0x...'\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode,\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(constructor, { // [!code focus]\n *   bytecode, // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param abiConstructor - The ABI Constructor to decode.\n * @param options - Decoding options.\n * @returns The decoded constructor inputs.\n */\nexport function decode(\n  abiConstructor: AbiConstructor,\n  options: decode.Options,\n): readonly unknown[] | undefined\n/** @internal */\nexport function decode(\n  abiConstructor: AbiConstructor,\n  options: decode.Options,\n): decode.ReturnType {\n  const { bytecode } = options\n  if (abiConstructor.inputs.length === 0) return undefined\n  const data = options.data.replace(bytecode, '0x') as Hex.Hex\n  return AbiParameters.decode(abiConstructor.inputs, data)\n}\n\nexport declare namespace decode {\n  interface Options {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The encoded constructor. */\n    data: Hex.Hex\n  }\n\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    | (abiConstructor['inputs']['length'] extends 0\n        ? undefined\n        : abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>)\n    | (IsNarrowable<abiConstructor, AbiConstructor> extends true\n        ? never\n        : undefined)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType {\n  const { bytecode, args } = options\n  return Hex.concat(\n    bytecode,\n    abiConstructor.inputs?.length && args?.length\n      ? AbiParameters.encode(abiConstructor.inputs, args as readonly unknown[])\n      : '0x',\n  )\n}\n\nexport declare namespace encode {\n  type Options<\n    abiConstructor extends AbiConstructor = AbiConstructor,\n    ///\n    args extends abitype.AbiParametersToPrimitiveTypes<\n      abiConstructor['inputs']\n    > = abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>,\n  > = {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The constructor arguments to encode. */\n    args?: args | undefined\n  } & (readonly [] extends args\n    ? {}\n    : {\n        /** The constructor arguments to encode. */\n        args: args\n      })\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | AbiParameters.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function format<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n): format.ReturnType<abiConstructor>\n/**\n * Formats an {@link ox#AbiConstructor.AbiConstructor} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const formatted = AbiConstructor.format({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiConstructor - The ABI Constructor to format.\n * @returns The formatted ABI Constructor.\n */\nexport function format(abiConstructor: AbiConstructor): string\n/** @internal */\nexport function format(abiConstructor: AbiConstructor): format.ReturnType {\n  return abitype.formatAbiItem(abiConstructor)\n}\n\nexport declare namespace format {\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    abitype.FormatAbiItem<abiConstructor>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<\n  const abiConstructor extends AbiConstructor | string | readonly string[],\n>(\n  abiConstructor: (abiConstructor | string | readonly string[]) &\n    (\n      | (abiConstructor extends string\n          ? internal.Signature<abiConstructor>\n          : never)\n      | (abiConstructor extends readonly string[]\n          ? internal.Signatures<abiConstructor>\n          : never)\n      | AbiConstructor\n    ),\n): from.ReturnType<abiConstructor>\n/**\n * Parses an arbitrary **JSON ABI Constructor** or **Human Readable ABI Constructor** into a typed {@link ox#AbiConstructor.AbiConstructor}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner)' // [!code hl]\n * )\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from([\n *   'struct Foo { address owner; uint256 amount; }', // [!code hl]\n *   'constructor(Foo foo)',\n * ])\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiConstructor - The ABI Constructor to parse.\n * @returns Typed ABI Constructor.\n */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): AbiConstructor\n/** @internal */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): from.ReturnType {\n  return AbiItem.from(abiConstructor as AbiConstructor)\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abiConstructor extends\n      | AbiConstructor\n      | string\n      | readonly string[] = AbiConstructor,\n  > = AbiItem.from.ReturnType<abiConstructor>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function fromAbi<const abi extends Abi.Abi | readonly unknown[]>(\n  abi: abi | Abi.Abi | readonly unknown[],\n): fromAbi.ReturnType<abi>\n/**\n * Extracts an {@link ox#AbiConstructor.AbiConstructor} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @returns The ABI constructor.\n */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): AbiConstructor\n/** @internal */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): fromAbi.ReturnType {\n  const item = (abi as Abi.Abi).find((item) => item.type === 'constructor')\n  if (!item) throw new AbiItem.NotFoundError({ name: 'constructor' })\n  return item\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> = Extract<\n    abi[number],\n    { type: 'constructor' }\n  >\n\n  type ErrorType = AbiItem.NotFoundError | Errors.GlobalErrorType\n}\n"],"mappings":";;;;;AAgDAA,OAAA,CAAAC,MAAA,GAAAA,MAAA;AAkFAD,OAAA,CAAAE,MAAA,GAAAA,MAAA;AAuEAF,OAAA,CAAAG,MAAA,GAAAA,MAAA;AA6HAH,OAAA,CAAAI,IAAA,GAAAA,IAAA;AAqDAJ,OAAA,CAAAK,OAAA,GAAAA,OAAA;AA3XA,MAAAC,OAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,aAAA,GAAAF,OAAA;AAEA,MAAAG,GAAA,GAAAH,OAAA;AA2CA,SAAgBN,MAAMA,CACpBU,cAA8B,EAC9BC,OAAuB;EAEvB,MAAM;IAAEC;EAAQ,CAAE,GAAGD,OAAO;EAC5B,IAAID,cAAc,CAACG,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE,OAAOC,SAAS;EACxD,MAAMC,IAAI,GAAGL,OAAO,CAACK,IAAI,CAACC,OAAO,CAACL,QAAQ,EAAE,IAAI,CAAY;EAC5D,OAAOJ,aAAa,CAACR,MAAM,CAACU,cAAc,CAACG,MAAM,EAAEG,IAAI,CAAC;AAC1D;AA0EA,SAAgBf,MAAMA,CACpBS,cAA8B,EAC9BC,OAAuC;EAEvC,MAAM;IAAEC,QAAQ;IAAEM;EAAI,CAAE,GAAGP,OAAO;EAClC,OAAOF,GAAG,CAACU,MAAM,CACfP,QAAQ,EACRF,cAAc,CAACG,MAAM,EAAEC,MAAM,IAAII,IAAI,EAAEJ,MAAM,GACzCN,aAAa,CAACP,MAAM,CAACS,cAAc,CAACG,MAAM,EAAEK,IAA0B,CAAC,GACvE,IAAI,CACT;AACH;AA4DA,SAAgBhB,MAAMA,CAACQ,cAA8B;EACnD,OAAOL,OAAO,CAACe,aAAa,CAACV,cAAc,CAAC;AAC9C;AA2HA,SAAgBP,IAAIA,CAClBO,cAA2D;EAE3D,OAAOH,OAAO,CAACJ,IAAI,CAACO,cAAgC,CAAC;AACvD;AAiDA,SAAgBN,OAAOA,CAACiB,GAAiC;EACvD,MAAMC,IAAI,GAAID,GAAe,CAACE,IAAI,CAAED,IAAI,IAAKA,IAAI,CAACE,IAAI,KAAK,aAAa,CAAC;EACzE,IAAI,CAACF,IAAI,EAAE,MAAM,IAAIf,OAAO,CAACkB,aAAa,CAAC;IAAEC,IAAI,EAAE;EAAa,CAAE,CAAC;EACnE,OAAOJ,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}