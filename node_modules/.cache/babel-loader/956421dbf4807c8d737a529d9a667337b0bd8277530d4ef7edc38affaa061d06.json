{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareEncodeFunctionData = prepareEncodeFunctionData;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst toFunctionSelector_js_1 = require(\"../hash/toFunctionSelector.js\");\nconst formatAbiItem_js_1 = require(\"./formatAbiItem.js\");\nconst getAbiItem_js_1 = require(\"./getAbiItem.js\");\nconst docsPath = '/docs/contract/encodeFunctionData';\nfunction prepareEncodeFunctionData(parameters) {\n  const {\n    abi,\n    args,\n    functionName\n  } = parameters;\n  let abiItem = abi[0];\n  if (functionName) {\n    const item = (0, getAbiItem_js_1.getAbiItem)({\n      abi,\n      args,\n      name: functionName\n    });\n    if (!item) throw new abi_js_1.AbiFunctionNotFoundError(functionName, {\n      docsPath\n    });\n    abiItem = item;\n  }\n  if (abiItem.type !== 'function') throw new abi_js_1.AbiFunctionNotFoundError(undefined, {\n    docsPath\n  });\n  return {\n    abi: [abiItem],\n    functionName: (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(abiItem))\n  };\n}","map":{"version":3,"names":["exports","prepareEncodeFunctionData","abi_js_1","require","toFunctionSelector_js_1","formatAbiItem_js_1","getAbiItem_js_1","docsPath","parameters","abi","args","functionName","abiItem","item","getAbiItem","name","AbiFunctionNotFoundError","type","undefined","toFunctionSelector","formatAbiItem"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/abi/prepareEncodeFunctionData.ts"],"sourcesContent":["import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n"],"mappings":";;;;;AAoFAA,OAAA,CAAAC,yBAAA,GAAAA,yBAAA;AA7EA,MAAAC,QAAA,GAAAC,OAAA;AASA,MAAAC,uBAAA,GAAAD,OAAA;AAQA,MAAAE,kBAAA,GAAAF,OAAA;AACA,MAAAG,eAAA,GAAAH,OAAA;AAEA,MAAMI,QAAQ,GAAG,mCAAmC;AAyDpD,SAAgBN,yBAAyBA,CAIvCO,UAAkE;EAElE,MAAM;IAAEC,GAAG;IAAEC,IAAI;IAAEC;EAAY,CAAE,GAC/BH,UAAiD;EAEnD,IAAII,OAAO,GAAGH,GAAG,CAAC,CAAC,CAAC;EACpB,IAAIE,YAAY,EAAE;IAChB,MAAME,IAAI,GAAG,IAAAP,eAAA,CAAAQ,UAAU,EAAC;MACtBL,GAAG;MACHC,IAAI;MACJK,IAAI,EAAEJ;KACP,CAAC;IACF,IAAI,CAACE,IAAI,EAAE,MAAM,IAAIX,QAAA,CAAAc,wBAAwB,CAACL,YAAY,EAAE;MAAEJ;IAAQ,CAAE,CAAC;IACzEK,OAAO,GAAGC,IAAI;EAChB;EAEA,IAAID,OAAO,CAACK,IAAI,KAAK,UAAU,EAC7B,MAAM,IAAIf,QAAA,CAAAc,wBAAwB,CAACE,SAAS,EAAE;IAAEX;EAAQ,CAAE,CAAC;EAE7D,OAAO;IACLE,GAAG,EAAE,CAACG,OAAO,CAAC;IACdD,YAAY,EAAE,IAAAP,uBAAA,CAAAe,kBAAkB,EAAC,IAAAd,kBAAA,CAAAe,aAAa,EAACR,OAAO,CAAC;GACa;AACxE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}