{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.watchContractEvent = watchContractEvent;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst rpc_js_1 = require(\"../../errors/rpc.js\");\nconst decodeEventLog_js_1 = require(\"../../utils/abi/decodeEventLog.js\");\nconst encodeEventTopics_js_1 = require(\"../../utils/abi/encodeEventTopics.js\");\nconst log_js_1 = require(\"../../utils/formatters/log.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst observe_js_1 = require(\"../../utils/observe.js\");\nconst poll_js_1 = require(\"../../utils/poll.js\");\nconst stringify_js_1 = require(\"../../utils/stringify.js\");\nconst createContractEventFilter_js_1 = require(\"./createContractEventFilter.js\");\nconst getBlockNumber_js_1 = require(\"./getBlockNumber.js\");\nconst getContractEvents_js_1 = require(\"./getContractEvents.js\");\nconst getFilterChanges_js_1 = require(\"./getFilterChanges.js\");\nconst uninstallFilter_js_1 = require(\"./uninstallFilter.js\");\nfunction watchContractEvent(client, parameters) {\n  const {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_\n  } = parameters;\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (typeof fromBlock === 'bigint') return true;\n    if (client.transport.type === 'webSocket' || client.transport.type === 'ipc') return false;\n    if (client.transport.type === 'fallback' && (client.transport.transports[0].config.type === 'webSocket' || client.transport.transports[0].config.type === 'ipc')) return false;\n    return true;\n  })();\n  const pollContractEvent = () => {\n    const strict = strict_ ?? false;\n    const observerId = (0, stringify_js_1.stringify)(['watchContractEvent', address, args, batch, client.uid, eventName, pollingInterval, strict, fromBlock]);\n    return (0, observe_js_1.observe)(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      let previousBlockNumber;\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n;\n      let filter;\n      let initialized = false;\n      const unwatch = (0, poll_js_1.poll)(async () => {\n        if (!initialized) {\n          try {\n            filter = await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, 'createContractEventFilter')({\n              abi,\n              address,\n              args: args,\n              eventName: eventName,\n              strict: strict,\n              fromBlock\n            });\n          } catch {}\n          initialized = true;\n          return;\n        }\n        try {\n          let logs;\n          if (filter) {\n            logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({\n              filter\n            });\n          } else {\n            const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});\n            if (previousBlockNumber && previousBlockNumber < blockNumber) {\n              logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, 'getContractEvents')({\n                abi,\n                address,\n                args,\n                eventName,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber,\n                strict\n              });\n            } else {\n              logs = [];\n            }\n            previousBlockNumber = blockNumber;\n          }\n          if (logs.length === 0) return;\n          if (batch) emit.onLogs(logs);else for (const log of logs) emit.onLogs([log]);\n        } catch (err) {\n          if (filter && err instanceof rpc_js_1.InvalidInputRpcError) initialized = false;\n          emit.onError?.(err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribeContractEvent = () => {\n    const strict = strict_ ?? false;\n    const observerId = (0, stringify_js_1.stringify)(['watchContractEvent', address, args, batch, client.uid, eventName, pollingInterval, strict]);\n    let active = true;\n    let unsubscribe = () => active = false;\n    return (0, observe_js_1.observe)(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      ;\n      (async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket' || transport.config.type === 'ipc');\n              if (!transport) return client.transport;\n              return transport.value;\n            }\n            return client.transport;\n          })();\n          const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({\n            abi: abi,\n            eventName: eventName,\n            args\n          }) : [];\n          const {\n            unsubscribe: unsubscribe_\n          } = await transport.subscribe({\n            params: ['logs', {\n              address,\n              topics\n            }],\n            onData(data) {\n              if (!active) return;\n              const log = data.result;\n              try {\n                const {\n                  eventName,\n                  args\n                } = (0, decodeEventLog_js_1.decodeEventLog)({\n                  abi: abi,\n                  data: log.data,\n                  topics: log.topics,\n                  strict: strict_\n                });\n                const formatted = (0, log_js_1.formatLog)(log, {\n                  args,\n                  eventName: eventName\n                });\n                emit.onLogs([formatted]);\n              } catch (err) {\n                let eventName;\n                let isUnnamed;\n                if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {\n                  if (strict_) return;\n                  eventName = err.abiItem.name;\n                  isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n                }\n                const formatted = (0, log_js_1.formatLog)(log, {\n                  args: isUnnamed ? [] : {},\n                  eventName\n                });\n                emit.onLogs([formatted]);\n              }\n            },\n            onError(error) {\n              emit.onError?.(error);\n            }\n          });\n          unsubscribe = unsubscribe_;\n          if (!active) unsubscribe();\n        } catch (err) {\n          onError?.(err);\n        }\n      })();\n      return () => unsubscribe();\n    });\n  };\n  return enablePolling ? pollContractEvent() : subscribeContractEvent();\n}","map":{"version":3,"names":["exports","watchContractEvent","abi_js_1","require","rpc_js_1","decodeEventLog_js_1","encodeEventTopics_js_1","log_js_1","getAction_js_1","observe_js_1","poll_js_1","stringify_js_1","createContractEventFilter_js_1","getBlockNumber_js_1","getContractEvents_js_1","getFilterChanges_js_1","uninstallFilter_js_1","client","parameters","abi","address","args","batch","eventName","fromBlock","onError","onLogs","poll","poll_","pollingInterval","strict","strict_","enablePolling","transport","type","transports","config","pollContractEvent","observerId","stringify","uid","observe","emit","previousBlockNumber","undefined","filter","initialized","unwatch","getAction","createContractEventFilter","logs","getFilterChanges","blockNumber","getBlockNumber","getContractEvents","toBlock","length","log","err","InvalidInputRpcError","emitOnBegin","interval","uninstallFilter","subscribeContractEvent","active","unsubscribe","find","value","topics","encodeEventTopics","unsubscribe_","subscribe","params","onData","data","result","decodeEventLog","formatted","formatLog","isUnnamed","DecodeLogDataMismatch","DecodeLogTopicsMismatch","abiItem","name","inputs","some","x","error"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/actions/public/watchContractEvent.ts"],"sourcesContent":["import type { Abi, Address, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\n\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n} from '../../types/contract.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport { createContractEventFilter } from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport {\n  type GetContractEventsParameters,\n  getContractEvents,\n} from './getContractEvents.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchContractEventOnLogsParameter<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = abi extends Abi\n  ? Abi extends abi\n    ? Log[]\n    : Log<bigint, number, false, ExtractAbiEvent<abi, eventName>, strict>[]\n  : Log[]\n\nexport type WatchContractEventOnLogsFn<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = (logs: WatchContractEventOnLogsParameter<abi, eventName, strict>) => void\n\nexport type WatchContractEventParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Contract ABI. */\n  abi: abi\n  args?:\n    | ContractEventArgs<\n        abi,\n        eventName extends ContractEventName<abi>\n          ? eventName\n          : ContractEventName<abi>\n      >\n    | undefined\n  /** Contract event. */\n  eventName?: eventName | ContractEventName<abi> | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchContractEventOnLogsFn<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    strict\n  >\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n} & GetPollOptions<transport>\n\nexport type WatchContractEventReturnType = () => void\n\nexport type WatchContractEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n>(\n  client: Client<transport, chain>,\n  parameters: WatchContractEventParameters<abi, eventName, strict, transport>,\n): WatchContractEventReturnType {\n  const {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  } = parameters\n\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n\n  const pollContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abi, eventName> | undefined\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createContractEventFilter,\n                'createContractEventFilter',\n              )({\n                abi,\n                address,\n                args: args as any,\n                eventName: eventName as any,\n                strict: strict as any,\n                fromBlock,\n              })) as Filter<'event', abi, eventName>\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber < blockNumber) {\n                logs = await getAction(\n                  client,\n                  getContractEvents,\n                  'getContractEvents',\n                )({\n                  abi,\n                  address,\n                  args,\n                  eventName,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                  strict,\n                } as {} as GetContractEventsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n    ])\n\n    let active = true\n    let unsubscribe = () => (active = false)\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      ;(async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(\n                (transport: ReturnType<Transport>) =>\n                  transport.config.type === 'webSocket' ||\n                  transport.config.type === 'ipc',\n              )\n              if (!transport) return client.transport\n              return transport.value\n            }\n            return client.transport\n          })()\n\n          const topics: LogTopic[] = eventName\n            ? encodeEventTopics({\n                abi: abi,\n                eventName: eventName,\n                args,\n              } as EncodeEventTopicsParameters)\n            : []\n\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n            params: ['logs', { address, topics }],\n            onData(data: any) {\n              if (!active) return\n              const log = data.result\n              try {\n                const { eventName, args } = decodeEventLog({\n                  abi: abi,\n                  data: log.data,\n                  topics: log.topics as any,\n                  strict: strict_,\n                })\n                const formatted = formatLog(log, {\n                  args,\n                  eventName: eventName as string,\n                })\n                emit.onLogs([formatted] as any)\n              } catch (err) {\n                let eventName: string | undefined\n                let isUnnamed: boolean | undefined\n                if (\n                  err instanceof DecodeLogDataMismatch ||\n                  err instanceof DecodeLogTopicsMismatch\n                ) {\n                  // If strict mode is on, and log data/topics do not match event definition, skip.\n                  if (strict_) return\n                  eventName = err.abiItem.name\n                  isUnnamed = err.abiItem.inputs?.some(\n                    (x) => !('name' in x && x.name),\n                  )\n                }\n\n                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                const formatted = formatLog(log, {\n                  args: isUnnamed ? [] : {},\n                  eventName,\n                })\n                emit.onLogs([formatted] as any)\n              }\n            },\n            onError(error: Error) {\n              emit.onError?.(error)\n            },\n          })\n          unsubscribe = unsubscribe_\n          if (!active) unsubscribe()\n        } catch (err) {\n          onError?.(err as Error)\n        }\n      })()\n      return () => unsubscribe()\n    })\n  }\n\n  return enablePolling ? pollContractEvent() : subscribeContractEvent()\n}\n"],"mappings":";;;;;AAoIAA,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AA5HA,MAAAC,QAAA,GAAAC,OAAA;AAIA,MAAAC,QAAA,GAAAD,OAAA;AASA,MAAAE,mBAAA,GAAAF,OAAA;AACA,MAAAG,sBAAA,GAAAH,OAAA;AAIA,MAAAI,QAAA,GAAAJ,OAAA;AACA,MAAAK,cAAA,GAAAL,OAAA;AACA,MAAAM,YAAA,GAAAN,OAAA;AACA,MAAAO,SAAA,GAAAP,OAAA;AACA,MAAAQ,cAAA,GAAAR,OAAA;AACA,MAAAS,8BAAA,GAAAT,OAAA;AACA,MAAAU,mBAAA,GAAAV,OAAA;AACA,MAAAW,sBAAA,GAAAX,OAAA;AAIA,MAAAY,qBAAA,GAAAZ,OAAA;AACA,MAAAa,oBAAA,GAAAb,OAAA;AA8FA,SAAgBF,kBAAkBA,CAOhCgB,MAAgC,EAChCC,UAA2E;EAE3E,MAAM;IACJC,GAAG;IACHC,OAAO;IACPC,IAAI;IACJC,KAAK,GAAG,IAAI;IACZC,SAAS;IACTC,SAAS;IACTC,OAAO;IACPC,MAAM;IACNC,IAAI,EAAEC,KAAK;IACXC,eAAe,GAAGZ,MAAM,CAACY,eAAe;IACxCC,MAAM,EAAEC;EAAO,CAChB,GAAGb,UAAU;EAEd,MAAMc,aAAa,GAAG,CAAC,MAAK;IAC1B,IAAI,OAAOJ,KAAK,KAAK,WAAW,EAAE,OAAOA,KAAK;IAC9C,IAAI,OAAOJ,SAAS,KAAK,QAAQ,EAAE,OAAO,IAAI;IAC9C,IACEP,MAAM,CAACgB,SAAS,CAACC,IAAI,KAAK,WAAW,IACrCjB,MAAM,CAACgB,SAAS,CAACC,IAAI,KAAK,KAAK,EAE/B,OAAO,KAAK;IACd,IACEjB,MAAM,CAACgB,SAAS,CAACC,IAAI,KAAK,UAAU,KACnCjB,MAAM,CAACgB,SAAS,CAACE,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,CAACF,IAAI,KAAK,WAAW,IACzDjB,MAAM,CAACgB,SAAS,CAACE,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,CAACF,IAAI,KAAK,KAAK,CAAC,EAEvD,OAAO,KAAK;IACd,OAAO,IAAI;EACb,CAAC,EAAC,CAAE;EAEJ,MAAMG,iBAAiB,GAAGA,CAAA,KAAK;IAC7B,MAAMP,MAAM,GAAGC,OAAO,IAAI,KAAK;IAC/B,MAAMO,UAAU,GAAG,IAAA3B,cAAA,CAAA4B,SAAS,EAAC,CAC3B,oBAAoB,EACpBnB,OAAO,EACPC,IAAI,EACJC,KAAK,EACLL,MAAM,CAACuB,GAAG,EACVjB,SAAS,EACTM,eAAe,EACfC,MAAM,EACNN,SAAS,CACV,CAAC;IAEF,OAAO,IAAAf,YAAA,CAAAgC,OAAO,EAACH,UAAU,EAAE;MAAEZ,MAAM;MAAED;IAAO,CAAE,EAAGiB,IAAI,IAAI;MACvD,IAAIC,mBAA2B;MAC/B,IAAInB,SAAS,KAAKoB,SAAS,EAAED,mBAAmB,GAAGnB,SAAS,GAAG,EAAE;MACjE,IAAIqB,MAAmD;MACvD,IAAIC,WAAW,GAAG,KAAK;MAEvB,MAAMC,OAAO,GAAG,IAAArC,SAAA,CAAAiB,IAAI,EAClB,YAAW;QACT,IAAI,CAACmB,WAAW,EAAE;UAChB,IAAI;YACFD,MAAM,GAAI,MAAM,IAAArC,cAAA,CAAAwC,SAAS,EACvB/B,MAAM,EACNL,8BAAA,CAAAqC,yBAAyB,EACzB,2BAA2B,CAC5B,CAAC;cACA9B,GAAG;cACHC,OAAO;cACPC,IAAI,EAAEA,IAAW;cACjBE,SAAS,EAAEA,SAAgB;cAC3BO,MAAM,EAAEA,MAAa;cACrBN;aACD,CAAqC;UACxC,CAAC,CAAC,MAAM,CAAC;UACTsB,WAAW,GAAG,IAAI;UAClB;QACF;QAEA,IAAI;UACF,IAAII,IAAW;UACf,IAAIL,MAAM,EAAE;YACVK,IAAI,GAAG,MAAM,IAAA1C,cAAA,CAAAwC,SAAS,EACpB/B,MAAM,EACNF,qBAAA,CAAAoC,gBAAgB,EAChB,kBAAkB,CACnB,CAAC;cAAEN;YAAM,CAAE,CAAC;UACf,CAAC,MAAM;YAKL,MAAMO,WAAW,GAAG,MAAM,IAAA5C,cAAA,CAAAwC,SAAS,EACjC/B,MAAM,EACNJ,mBAAA,CAAAwC,cAAc,EACd,gBAAgB,CACjB,CAAC,EAAE,CAAC;YAKL,IAAIV,mBAAmB,IAAIA,mBAAmB,GAAGS,WAAW,EAAE;cAC5DF,IAAI,GAAG,MAAM,IAAA1C,cAAA,CAAAwC,SAAS,EACpB/B,MAAM,EACNH,sBAAA,CAAAwC,iBAAiB,EACjB,mBAAmB,CACpB,CAAC;gBACAnC,GAAG;gBACHC,OAAO;gBACPC,IAAI;gBACJE,SAAS;gBACTC,SAAS,EAAEmB,mBAAmB,GAAG,EAAE;gBACnCY,OAAO,EAAEH,WAAW;gBACpBtB;eACoC,CAAC;YACzC,CAAC,MAAM;cACLoB,IAAI,GAAG,EAAE;YACX;YACAP,mBAAmB,GAAGS,WAAW;UACnC;UAEA,IAAIF,IAAI,CAACM,MAAM,KAAK,CAAC,EAAE;UACvB,IAAIlC,KAAK,EAAEoB,IAAI,CAAChB,MAAM,CAACwB,IAAW,CAAC,MAC9B,KAAK,MAAMO,GAAG,IAAIP,IAAI,EAAER,IAAI,CAAChB,MAAM,CAAC,CAAC+B,GAAG,CAAQ,CAAC;QACxD,CAAC,CAAC,OAAOC,GAAG,EAAE;UAGZ,IAAIb,MAAM,IAAIa,GAAG,YAAYtD,QAAA,CAAAuD,oBAAoB,EAC/Cb,WAAW,GAAG,KAAK;UACrBJ,IAAI,CAACjB,OAAO,GAAGiC,GAAY,CAAC;QAC9B;MACF,CAAC,EACD;QACEE,WAAW,EAAE,IAAI;QACjBC,QAAQ,EAAEhC;OACX,CACF;MAED,OAAO,YAAW;QAChB,IAAIgB,MAAM,EACR,MAAM,IAAArC,cAAA,CAAAwC,SAAS,EACb/B,MAAM,EACND,oBAAA,CAAA8C,eAAe,EACf,iBAAiB,CAClB,CAAC;UAAEjB;QAAM,CAAE,CAAC;QACfE,OAAO,EAAE;MACX,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EAED,MAAMgB,sBAAsB,GAAGA,CAAA,KAAK;IAClC,MAAMjC,MAAM,GAAGC,OAAO,IAAI,KAAK;IAC/B,MAAMO,UAAU,GAAG,IAAA3B,cAAA,CAAA4B,SAAS,EAAC,CAC3B,oBAAoB,EACpBnB,OAAO,EACPC,IAAI,EACJC,KAAK,EACLL,MAAM,CAACuB,GAAG,EACVjB,SAAS,EACTM,eAAe,EACfC,MAAM,CACP,CAAC;IAEF,IAAIkC,MAAM,GAAG,IAAI;IACjB,IAAIC,WAAW,GAAGA,CAAA,KAAOD,MAAM,GAAG,KAAM;IACxC,OAAO,IAAAvD,YAAA,CAAAgC,OAAO,EAACH,UAAU,EAAE;MAAEZ,MAAM;MAAED;IAAO,CAAE,EAAGiB,IAAI,IAAI;MACvD;MAAC,CAAC,YAAW;QACX,IAAI;UACF,MAAMT,SAAS,GAAG,CAAC,MAAK;YACtB,IAAIhB,MAAM,CAACgB,SAAS,CAACC,IAAI,KAAK,UAAU,EAAE;cACxC,MAAMD,SAAS,GAAGhB,MAAM,CAACgB,SAAS,CAACE,UAAU,CAAC+B,IAAI,CAC/CjC,SAAgC,IAC/BA,SAAS,CAACG,MAAM,CAACF,IAAI,KAAK,WAAW,IACrCD,SAAS,CAACG,MAAM,CAACF,IAAI,KAAK,KAAK,CAClC;cACD,IAAI,CAACD,SAAS,EAAE,OAAOhB,MAAM,CAACgB,SAAS;cACvC,OAAOA,SAAS,CAACkC,KAAK;YACxB;YACA,OAAOlD,MAAM,CAACgB,SAAS;UACzB,CAAC,EAAC,CAAE;UAEJ,MAAMmC,MAAM,GAAe7C,SAAS,GAChC,IAAAjB,sBAAA,CAAA+D,iBAAiB,EAAC;YAChBlD,GAAG,EAAEA,GAAG;YACRI,SAAS,EAAEA,SAAS;YACpBF;WAC8B,CAAC,GACjC,EAAE;UAEN,MAAM;YAAE4C,WAAW,EAAEK;UAAY,CAAE,GAAG,MAAMrC,SAAS,CAACsC,SAAS,CAAC;YAC9DC,MAAM,EAAE,CAAC,MAAM,EAAE;cAAEpD,OAAO;cAAEgD;YAAM,CAAE,CAAC;YACrCK,MAAMA,CAACC,IAAS;cACd,IAAI,CAACV,MAAM,EAAE;cACb,MAAMP,GAAG,GAAGiB,IAAI,CAACC,MAAM;cACvB,IAAI;gBACF,MAAM;kBAAEpD,SAAS;kBAAEF;gBAAI,CAAE,GAAG,IAAAhB,mBAAA,CAAAuE,cAAc,EAAC;kBACzCzD,GAAG,EAAEA,GAAG;kBACRuD,IAAI,EAAEjB,GAAG,CAACiB,IAAI;kBACdN,MAAM,EAAEX,GAAG,CAACW,MAAa;kBACzBtC,MAAM,EAAEC;iBACT,CAAC;gBACF,MAAM8C,SAAS,GAAG,IAAAtE,QAAA,CAAAuE,SAAS,EAACrB,GAAG,EAAE;kBAC/BpC,IAAI;kBACJE,SAAS,EAAEA;iBACZ,CAAC;gBACFmB,IAAI,CAAChB,MAAM,CAAC,CAACmD,SAAS,CAAQ,CAAC;cACjC,CAAC,CAAC,OAAOnB,GAAG,EAAE;gBACZ,IAAInC,SAA6B;gBACjC,IAAIwD,SAA8B;gBAClC,IACErB,GAAG,YAAYxD,QAAA,CAAA8E,qBAAqB,IACpCtB,GAAG,YAAYxD,QAAA,CAAA+E,uBAAuB,EACtC;kBAEA,IAAIlD,OAAO,EAAE;kBACbR,SAAS,GAAGmC,GAAG,CAACwB,OAAO,CAACC,IAAI;kBAC5BJ,SAAS,GAAGrB,GAAG,CAACwB,OAAO,CAACE,MAAM,EAAEC,IAAI,CACjCC,CAAC,IAAK,EAAE,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACH,IAAI,CAAC,CAChC;gBACH;gBAGA,MAAMN,SAAS,GAAG,IAAAtE,QAAA,CAAAuE,SAAS,EAACrB,GAAG,EAAE;kBAC/BpC,IAAI,EAAE0D,SAAS,GAAG,EAAE,GAAG,EAAE;kBACzBxD;iBACD,CAAC;gBACFmB,IAAI,CAAChB,MAAM,CAAC,CAACmD,SAAS,CAAQ,CAAC;cACjC;YACF,CAAC;YACDpD,OAAOA,CAAC8D,KAAY;cAClB7C,IAAI,CAACjB,OAAO,GAAG8D,KAAK,CAAC;YACvB;WACD,CAAC;UACFtB,WAAW,GAAGK,YAAY;UAC1B,IAAI,CAACN,MAAM,EAAEC,WAAW,EAAE;QAC5B,CAAC,CAAC,OAAOP,GAAG,EAAE;UACZjC,OAAO,GAAGiC,GAAY,CAAC;QACzB;MACF,CAAC,EAAC,CAAE;MACJ,OAAO,MAAMO,WAAW,EAAE;IAC5B,CAAC,CAAC;EACJ,CAAC;EAED,OAAOjC,aAAa,GAAGK,iBAAiB,EAAE,GAAG0B,sBAAsB,EAAE;AACvE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}