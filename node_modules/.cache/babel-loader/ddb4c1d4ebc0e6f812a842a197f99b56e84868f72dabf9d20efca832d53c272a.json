{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.slice = slice;\nexports.sliceBytes = sliceBytes;\nexports.sliceHex = sliceHex;\nconst data_js_1 = require(\"../../errors/data.js\");\nconst isHex_js_1 = require(\"./isHex.js\");\nconst size_js_1 = require(\"./size.js\");\nfunction slice(value, start, end, {\n  strict\n} = {}) {\n  if ((0, isHex_js_1.isHex)(value, {\n    strict: false\n  })) return sliceHex(value, start, end, {\n    strict\n  });\n  return sliceBytes(value, start, end, {\n    strict\n  });\n}\nfunction assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > (0, size_js_1.size)(value) - 1) throw new data_js_1.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: (0, size_js_1.size)(value)\n  });\n}\nfunction assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && (0, size_js_1.size)(value) !== end - start) {\n    throw new data_js_1.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: (0, size_js_1.size)(value)\n    });\n  }\n}\nfunction sliceBytes(value_, start, end, {\n  strict\n} = {}) {\n  assertStartOffset(value_, start);\n  const value = value_.slice(start, end);\n  if (strict) assertEndOffset(value, start, end);\n  return value;\n}\nfunction sliceHex(value_, start, end, {\n  strict\n} = {}) {\n  assertStartOffset(value_, start);\n  const value = `0x${value_.replace('0x', '').slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n  if (strict) assertEndOffset(value, start, end);\n  return value;\n}","map":{"version":3,"names":["exports","slice","sliceBytes","sliceHex","data_js_1","require","isHex_js_1","size_js_1","value","start","end","strict","isHex","assertStartOffset","size","SliceOffsetOutOfBoundsError","offset","position","assertEndOffset","value_","replace","length"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/data/slice.ts"],"sourcesContent":["import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n"],"mappings":";;;;;AA2BAA,OAAA,CAAAC,KAAA,GAAAA,KAAA;AAgEAD,OAAA,CAAAE,UAAA,GAAAA,UAAA;AAwBAF,OAAA,CAAAG,QAAA,GAAAA,QAAA;AAnHA,MAAAC,SAAA,GAAAC,OAAA;AAOA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,SAAA,GAAAF,OAAA;AAmBA,SAAgBJ,KAAKA,CACnBO,KAAY,EACZC,KAA0B,EAC1BC,GAAwB,EACxB;EAAEC;AAAM,IAAuC,EAAE;EAEjD,IAAI,IAAAL,UAAA,CAAAM,KAAK,EAACJ,KAAK,EAAE;IAAEG,MAAM,EAAE;EAAK,CAAE,CAAC,EACjC,OAAOR,QAAQ,CAACK,KAAY,EAAEC,KAAK,EAAEC,GAAG,EAAE;IACxCC;GACD,CAA2B;EAC9B,OAAOT,UAAU,CAACM,KAAkB,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAChDC;GACD,CAA2B;AAC9B;AAOA,SAASE,iBAAiBA,CAACL,KAAsB,EAAEC,KAA0B;EAC3E,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,IAAAF,SAAA,CAAAO,IAAI,EAACN,KAAK,CAAC,GAAG,CAAC,EACnE,MAAM,IAAIJ,SAAA,CAAAW,2BAA2B,CAAC;IACpCC,MAAM,EAAEP,KAAK;IACbQ,QAAQ,EAAE,OAAO;IACjBH,IAAI,EAAE,IAAAP,SAAA,CAAAO,IAAI,EAACN,KAAK;GACjB,CAAC;AACN;AAOA,SAASU,eAAeA,CACtBV,KAAsB,EACtBC,KAA0B,EAC1BC,GAAwB;EAExB,IACE,OAAOD,KAAK,KAAK,QAAQ,IACzB,OAAOC,GAAG,KAAK,QAAQ,IACvB,IAAAH,SAAA,CAAAO,IAAI,EAACN,KAAK,CAAC,KAAKE,GAAG,GAAGD,KAAK,EAC3B;IACA,MAAM,IAAIL,SAAA,CAAAW,2BAA2B,CAAC;MACpCC,MAAM,EAAEN,GAAG;MACXO,QAAQ,EAAE,KAAK;MACfH,IAAI,EAAE,IAAAP,SAAA,CAAAO,IAAI,EAACN,KAAK;KACjB,CAAC;EACJ;AACF;AAcA,SAAgBN,UAAUA,CACxBiB,MAAiB,EACjBV,KAA0B,EAC1BC,GAAwB,EACxB;EAAEC;AAAM,IAAuC,EAAE;EAEjDE,iBAAiB,CAACM,MAAM,EAAEV,KAAK,CAAC;EAChC,MAAMD,KAAK,GAAGW,MAAM,CAAClB,KAAK,CAACQ,KAAK,EAAEC,GAAG,CAAC;EACtC,IAAIC,MAAM,EAAEO,eAAe,CAACV,KAAK,EAAEC,KAAK,EAAEC,GAAG,CAAC;EAC9C,OAAOF,KAAK;AACd;AAcA,SAAgBL,QAAQA,CACtBgB,MAAW,EACXV,KAA0B,EAC1BC,GAAwB,EACxB;EAAEC;AAAM,IAAuC,EAAE;EAEjDE,iBAAiB,CAACM,MAAM,EAAEV,KAAK,CAAC;EAChC,MAAMD,KAAK,GAAG,KAAKW,MAAM,CACtBC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CACjBnB,KAAK,CAAC,CAACQ,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAACC,GAAG,IAAIS,MAAM,CAACE,MAAM,IAAI,CAAC,CAAC,EAAW;EACjE,IAAIV,MAAM,EAAEO,eAAe,CAACV,KAAK,EAAEC,KAAK,EAAEC,GAAG,CAAC;EAC9C,OAAOF,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}