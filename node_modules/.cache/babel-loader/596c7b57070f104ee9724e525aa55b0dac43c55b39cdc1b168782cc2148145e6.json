{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport * as Errors from './Errors.js';\nimport * as RpcResponse from './RpcResponse.js';\nexport class ProviderRpcError extends Error {\n  constructor(code, message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ProviderRpcError'\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"details\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.code = code;\n    this.details = message;\n  }\n}\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  constructor({\n    message = 'The user rejected the request.'\n  } = {}) {\n    super(4001, message);\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 4001\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.UserRejectedRequestError'\n    });\n  }\n}\nObject.defineProperty(UserRejectedRequestError, \"code\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 4001\n});\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.'\n  } = {}) {\n    super(4100, message);\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 4100\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.UnauthorizedError'\n    });\n  }\n}\nObject.defineProperty(UnauthorizedError, \"code\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 4100\n});\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  constructor({\n    message = 'The provider does not support the requested method.'\n  } = {}) {\n    super(4200, message);\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 4200\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.UnsupportedMethodError'\n    });\n  }\n}\nObject.defineProperty(UnsupportedMethodError, \"code\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 4200\n});\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  constructor({\n    message = 'The provider is disconnected from all chains.'\n  } = {}) {\n    super(4900, message);\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 4900\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.DisconnectedError'\n    });\n  }\n}\nObject.defineProperty(DisconnectedError, \"code\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 4900\n});\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  constructor({\n    message = 'The provider is not connected to the requested chain.'\n  } = {}) {\n    super(4901, message);\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 4901\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.ChainDisconnectedError'\n    });\n  }\n}\nObject.defineProperty(ChainDisconnectedError, \"code\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 4901\n});\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter() {\n  const emitter = new EventEmitter();\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter);\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter);\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter);\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter)\n  };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider, options = {}) {\n  const {\n    includeEvents = true\n  } = options;\n  if (!provider) throw new IsUndefinedError();\n  return {\n    ...(includeEvents ? {\n      on: provider.on?.bind(provider),\n      removeListener: provider.removeListener?.bind(provider)\n    } : {}),\n    async request(args) {\n      try {\n        const result = await provider.request(args);\n        if (result && typeof result === 'object' && 'jsonrpc' in result) return RpcResponse.parse(result);\n        return result;\n      } catch (error) {\n        throw parseError(error);\n      }\n    }\n  };\n}\n/**\n * Parses an error object into an error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param errorObject - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError(errorObject) {\n  const errorObject_ = errorObject;\n  const error = RpcResponse.parseError(errorObject_);\n  if (error instanceof RpcResponse.InternalError) {\n    if (!error.data) return error;\n    const {\n      code\n    } = error.data;\n    if (code === DisconnectedError.code) return new DisconnectedError(errorObject_);\n    if (code === ChainDisconnectedError.code) return new ChainDisconnectedError(errorObject_);\n    if (code === UserRejectedRequestError.code) return new UserRejectedRequestError(errorObject_);\n    if (code === UnauthorizedError.code) return new UnauthorizedError(errorObject_);\n    if (code === UnsupportedMethodError.code) return new UnsupportedMethodError(errorObject_);\n  }\n  return error;\n}\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  constructor() {\n    super('`provider` is undefined.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Provider.IsUndefinedError'\n    });\n  }\n}","map":{"version":3,"names":["EventEmitter","Errors","RpcResponse","ProviderRpcError","Error","constructor","code","message","Object","defineProperty","details","UserRejectedRequestError","UnauthorizedError","UnsupportedMethodError","DisconnectedError","ChainDisconnectedError","createEmitter","emitter","eventNames","bind","listenerCount","listeners","addListener","emit","off","on","once","removeAllListeners","removeListener","from","provider","options","includeEvents","IsUndefinedError","request","args","result","parse","error","parseError","errorObject","errorObject_","InternalError","data","BaseError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/Provider.ts"],"sourcesContent":["import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * Whether to include event functions (`on`, `removeListener`) on the Provider.\n   *\n   * @default true\n   */\n  includeEvents?: boolean | undefined\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (options extends { includeEvents: true } | undefined\n    ? {\n        on: EventListenerFn\n        removeListener: EventListenerFn\n      }\n    : {})\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter = Compute<EventEmitter<EventMap>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\n/** Type for an EIP-1193 Provider's event listener functions (`on`, `removeListener`, etc). */\nexport type EventListenerFn = <event extends keyof EventMap>(\n  event: event,\n  listener: EventMap[event],\n) => void\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n}\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter(): Emitter {\n  const emitter = new EventEmitter<EventMap>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  const provider extends Provider | unknown,\n  options extends Options | undefined = undefined,\n>(\n  provider: provider | Provider<{ schema: RpcSchema.Generic }>,\n  options?: options | Options,\n): Provider<options>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, options: Options = {}): Provider<Options> {\n  const { includeEvents = true } = options\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...(includeEvents\n      ? {\n          on: provider.on?.bind(provider),\n          removeListener: provider.removeListener?.bind(provider),\n        }\n      : {}),\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error object into an error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param errorObject - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const errorObject extends RpcResponse.ErrorObject | unknown,\n>(\n  errorObject: errorObject | RpcResponse.ErrorObject,\n): parseError.ReturnType<errorObject> {\n  const errorObject_ = errorObject as RpcResponse.ErrorObject\n  const error = RpcResponse.parseError(errorObject_)\n  if (error instanceof RpcResponse.InternalError) {\n    if (!error.data) return error as never\n\n    const { code } = error.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(errorObject_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(errorObject_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(errorObject_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(errorObject_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(errorObject_) as never\n  }\n  return error as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}