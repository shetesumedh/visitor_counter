{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidSelectorSizeError = exports.NotFoundError = exports.AmbiguityError = void 0;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nexports.getSelector = getSelector;\nexports.getSignature = getSignature;\nexports.getSignatureHash = getSignatureHash;\nconst abitype = require(\"abitype\");\nconst Errors = require(\"./Errors.js\");\nconst Hash = require(\"./Hash.js\");\nconst Hex = require(\"./Hex.js\");\nconst internal = require(\"./internal/abiItem.js\");\nfunction format(abiItem) {\n  return abitype.formatAbiItem(abiItem);\n}\nfunction from(abiItem, options = {}) {\n  const {\n    prepare = true\n  } = options;\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem);\n    if (typeof abiItem === 'string') return abitype.parseAbiItem(abiItem);\n    return abiItem;\n  })();\n  return {\n    ...item,\n    ...(prepare ? {\n      hash: getSignatureHash(item)\n    } : {})\n  };\n}\nfunction fromAbi(abi, name, options) {\n  const {\n    args = [],\n    prepare = true\n  } = options ?? {};\n  const isSelector = Hex.validate(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error') return getSelector(abiItem) === Hex.slice(name, 0, 4);\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) throw new NotFoundError({\n    name: name\n  });\n  if (abiItems.length === 1) return {\n    ...abiItems[0],\n    ...(prepare ? {\n      hash: getSignatureHash(abiItems[0])\n    } : {})\n  };\n  let matchedAbiItem = undefined;\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return {\n        ...abiItem,\n        ...(prepare ? {\n          hash: getSignatureHash(abiItem)\n        } : {})\n      };\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return internal.isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes) throw new AmbiguityError({\n          abiItem,\n          type: ambiguousTypes[0]\n        }, {\n          abiItem: matchedAbiItem,\n          type: ambiguousTypes[1]\n        });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem;\n    const [abiItem, ...overloads] = abiItems;\n    return {\n      ...abiItem,\n      overloads\n    };\n  })();\n  if (!abiItem) throw new NotFoundError({\n    name: name\n  });\n  return {\n    ...abiItem,\n    ...(prepare ? {\n      hash: getSignatureHash(abiItem)\n    } : {})\n  };\n}\nfunction getSelector(abiItem) {\n  return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\nfunction getSignature(abiItem) {\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem;\n    return abitype.formatAbiItem(abiItem);\n  })();\n  return internal.normalizeSignature(signature);\n}\nfunction getSignatureHash(abiItem) {\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash) return abiItem.hash;\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\nclass AmbiguityError extends Errors.BaseError {\n  constructor(x, y) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [`\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`, `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``, '', 'These types encode differently and cannot be distinguished at runtime.', 'Remove one of the ambiguous items in the ABI.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.AmbiguityError'\n    });\n  }\n}\nexports.AmbiguityError = AmbiguityError;\nclass NotFoundError extends Errors.BaseError {\n  constructor({\n    name,\n    data,\n    type = 'item'\n  }) {\n    const selector = (() => {\n      if (name) return ` with name \"${name}\"`;\n      if (data) return ` with data \"${data}\"`;\n      return '';\n    })();\n    super(`ABI ${type}${selector} not found.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.NotFoundError'\n    });\n  }\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidSelectorSizeError extends Errors.BaseError {\n  constructor({\n    data\n  }) {\n    super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.InvalidSelectorSizeError'\n    });\n  }\n}\nexports.InvalidSelectorSizeError = InvalidSelectorSizeError;","map":{"version":3,"names":["exports","format","from","fromAbi","getSelector","getSignature","getSignatureHash","abitype","require","Errors","Hash","Hex","internal","abiItem","formatAbiItem","options","prepare","item","Array","isArray","parseAbiItem","hash","abi","name","args","isSelector","validate","strict","abiItems","filter","type","slice","length","NotFoundError","matchedAbiItem","undefined","inputs","matched","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AmbiguityError","overloads","signature","normalizeSignature","keccak256","fromString","BaseError","constructor","x","y","metaMessages","Object","defineProperty","data","selector","InvalidSelectorSizeError","size"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/node_modules/ox/core/AbiItem.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiItem.js'\nimport type { UnionCompute } from './internal/types.js'\n\n/** Root type for an item on an {@link ox#Abi.Abi}. */\nexport type AbiItem = Abi.Abi[number]\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type Foo = AbiItem.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = Extract<abi[number], { name: name }>\n\n/**\n * Extracts the names of all {@link ox#AbiItem.AbiItem} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type names = AbiItem.Name<typeof abi>\n * //   ^?\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> = Extract<\n  abi[number],\n  { name: string }\n>['name']\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format<const abiItem extends AbiItem>(\n  abiItem: abiItem | AbiItem,\n): abitype.FormatAbiItem<abiItem> {\n  return abitype.formatAbiItem(abiItem) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from<\n  const abiItem extends AbiItem | string | readonly string[],\n>(\n  abiItem: (abiItem | AbiItem | string | readonly string[]) &\n    (\n      | (abiItem extends string ? internal.Signature<abiItem> : never)\n      | (abiItem extends readonly string[]\n          ? internal.Signatures<abiItem>\n          : never)\n      | AbiItem\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiItem> {\n  const { prepare = true } = options\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem)\n    if (typeof abiItem === 'string')\n      return abitype.parseAbiItem(abiItem as never)\n    return abiItem\n  })() as AbiItem\n  return {\n    ...item,\n    ...(prepare ? { hash: getSignatureHash(item) } : {}),\n  } as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiItem extends AbiItem | string | readonly string[]> =\n    abiItem extends string\n      ? abitype.ParseAbiItem<abiItem>\n      : abiItem extends readonly string[]\n        ? abitype.ParseAbiItem<abiItem>\n        : abiItem\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends internal.ExtractArgs<abi, name> | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: fromAbi.Options<abi, name, args>,\n): fromAbi.ReturnType<abi, name, args> {\n  const { args = [], prepare = true } = (options ??\n    {}) as unknown as fromAbi.Options\n\n  const isSelector = Hex.validate(name, { strict: false })\n  const abiItems = (abi as Abi.Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error')\n        return getSelector(abiItem) === Hex.slice(name, 0, 4)\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0) throw new NotFoundError({ name: name as string })\n  if (abiItems.length === 1)\n    return {\n      ...abiItems[0],\n      ...(prepare ? { hash: getSignatureHash(abiItems[0]!) } : {}),\n    } as never\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return {\n          ...abiItem,\n          ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n        } as never\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return internal.isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = internal.getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0]!,\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1]!,\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem\n    const [abiItem, ...overloads] = abiItems\n    return { ...abiItem!, overloads }\n  })()\n\n  if (!abiItem) throw new NotFoundError({ name: name as string })\n  return {\n    ...abiItem,\n    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n  } as never\n}\n\nexport declare namespace fromAbi {\n  type Options<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    ///\n    allArgs = internal.ExtractArgs<abi, name>,\n  > = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  } & UnionCompute<\n    readonly [] extends allArgs\n      ? {\n          args?:\n            | allArgs // show all options\n            // infer value, widen inferred value of `args` conditionally to match `allArgs`\n            | (abi extends Abi.Abi\n                ? args extends allArgs\n                  ? internal.Widen<args>\n                  : never\n                : never)\n            | undefined\n        }\n      : {\n          args?:\n            | allArgs // show all options\n            | (internal.Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n            | undefined\n        }\n  >\n\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    fallback = AbiItem,\n  > = abi extends Abi.Abi\n    ? Abi.Abi extends abi\n      ? fallback\n      : internal.ExtractForArgs<\n          abi,\n          name,\n          args extends internal.ExtractArgs<abi, name>\n            ? args\n            : internal.ExtractArgs<abi, name>\n        >\n    : fallback\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem: string | AbiItem): Hex.Hex {\n  return Hex.slice(getSignatureHash(abiItem), 0, 4)\n}\n\nexport declare namespace getSelector {\n  type ErrorType =\n    | getSignatureHash.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature(abiItem: string | AbiItem): string {\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem\n    return abitype.formatAbiItem(abiItem)\n  })()\n  return internal.normalizeSignature(signature)\n}\n\nexport declare namespace getSignature {\n  type ErrorType =\n    | internal.normalizeSignature.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash(abiItem: string | AbiItem): Hex.Hex {\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n    return abiItem.hash as Hex.Hex\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)))\n}\n\nexport declare namespace getSignatureHash {\n  type ErrorType =\n    | getSignature.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n  override readonly name = 'AbiItem.AmbiguityError'\n  constructor(\n    x: { abiItem: Abi.Abi[number]; type: string },\n    y: { abiItem: Abi.Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [\n        // TODO: abitype to add support for signature-formatted ABI items.\n        `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n        `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n  override readonly name = 'AbiItem.NotFoundError'\n  constructor({\n    name,\n    data,\n    type = 'item',\n  }: {\n    name?: string | undefined\n    data?: Hex.Hex | undefined\n    type?: string | undefined\n  }) {\n    const selector = (() => {\n      if (name) return ` with name \"${name}\"`\n      if (data) return ` with data \"${data}\"`\n      return ''\n    })()\n    super(`ABI ${type}${selector} not found.`)\n  }\n}\n\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n  override readonly name = 'AbiItem.InvalidSelectorSizeError'\n  constructor({ data }: { data: Hex.Hex }) {\n    super(\n      `Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}