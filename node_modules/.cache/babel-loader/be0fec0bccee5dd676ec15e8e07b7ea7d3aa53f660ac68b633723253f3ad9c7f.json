{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseBlockTracker = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\nconst blockTrackerEvents = ['sync', 'latest'];\nclass BaseBlockTracker extends safe_event_emitter_1.default {\n  constructor(opts) {\n    super();\n    // config\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n    this._usePastBlocks = opts.usePastBlocks || false;\n    // state\n    this._currentBlock = null;\n    this._isRunning = false;\n    // bind functions for internal use\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n    // listen for handler changes\n    this._setupInternalEvents();\n  }\n  async destroy() {\n    this._cancelBlockResetTimeout();\n    await this._maybeEnd();\n    super.removeAllListeners();\n  }\n  isRunning() {\n    return this._isRunning;\n  }\n  getCurrentBlock() {\n    return this._currentBlock;\n  }\n  async getLatestBlock() {\n    // return if available\n    if (this._currentBlock) {\n      return this._currentBlock;\n    }\n    // wait for a new latest block\n    const latestBlock = await new Promise(resolve => this.once('latest', resolve));\n    // return newly set current block\n    return latestBlock;\n  }\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners(eventName) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    }\n    // re-add internal events\n    this._setupInternalEvents();\n    // trigger stop check just in case\n    this._onRemoveListener();\n    return this;\n  }\n  _setupInternalEvents() {\n    // first remove listeners for idempotence\n    this.removeListener('newListener', this._onNewListener);\n    this.removeListener('removeListener', this._onRemoveListener);\n    // then add them\n    this.on('newListener', this._onNewListener);\n    this.on('removeListener', this._onRemoveListener);\n  }\n  _onNewListener(eventName) {\n    // `newListener` is called *before* the listener is added\n    if (blockTrackerEvents.includes(eventName)) {\n      this._maybeStart();\n    }\n  }\n  _onRemoveListener() {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n  async _maybeStart() {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout();\n    await this._start();\n    this.emit('_started');\n  }\n  async _maybeEnd() {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n    this._setupBlockResetTimeout();\n    await this._end();\n    this.emit('_ended');\n  }\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n  _shouldUseNewBlock(newBlock) {\n    const currentBlock = this._currentBlock;\n    if (!currentBlock) {\n      return true;\n    }\n    const newBlockInt = hexToInt(newBlock);\n    const currentBlockInt = hexToInt(currentBlock);\n    return this._usePastBlocks && newBlockInt < currentBlockInt || newBlockInt > currentBlockInt;\n  }\n  _newPotentialLatest(newBlock) {\n    if (!this._shouldUseNewBlock(newBlock)) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n  _setCurrentBlock(newBlock) {\n    const oldBlock = this._currentBlock;\n    this._currentBlock = newBlock;\n    this.emit('latest', newBlock);\n    this.emit('sync', {\n      oldBlock,\n      newBlock\n    });\n  }\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout();\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n  _cancelBlockResetTimeout() {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n  _resetCurrentBlock() {\n    this._currentBlock = null;\n  }\n}\nexports.BaseBlockTracker = BaseBlockTracker;\n/**\n * Converts a number represented as a string in hexadecimal format into a native\n * number.\n *\n * @param hexInt - The hex string.\n * @returns The number.\n */\nfunction hexToInt(hexInt) {\n  return Number.parseInt(hexInt, 16);\n}","map":{"version":3,"names":["safe_event_emitter_1","__importDefault","require","sec","calculateSum","accumulator","currentValue","blockTrackerEvents","BaseBlockTracker","default","constructor","opts","_blockResetDuration","blockResetDuration","_usePastBlocks","usePastBlocks","_currentBlock","_isRunning","_onNewListener","bind","_onRemoveListener","_resetCurrentBlock","_setupInternalEvents","destroy","_cancelBlockResetTimeout","_maybeEnd","removeAllListeners","isRunning","getCurrentBlock","getLatestBlock","latestBlock","Promise","resolve","once","eventName","removeListener","on","includes","_maybeStart","_getBlockTrackerEventCount","_start","emit","_setupBlockResetTimeout","_end","map","listenerCount","reduce","_shouldUseNewBlock","newBlock","currentBlock","newBlockInt","hexToInt","currentBlockInt","_newPotentialLatest","_setCurrentBlock","oldBlock","_blockResetTimeout","setTimeout","unref","clearTimeout","exports","hexInt","Number","parseInt"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/eth-block-tracker/src/BaseBlockTracker.ts"],"sourcesContent":["import SafeEventEmitter from '@metamask/safe-event-emitter';\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator: number, currentValue: number) =>\n  accumulator + currentValue;\nconst blockTrackerEvents: (string | symbol)[] = ['sync', 'latest'];\n\ninterface BaseBlockTrackerArgs {\n  blockResetDuration?: number;\n  usePastBlocks?: boolean;\n}\n\nexport abstract class BaseBlockTracker extends SafeEventEmitter {\n  protected _isRunning: boolean;\n\n  private _blockResetDuration: number;\n\n  private _usePastBlocks: boolean;\n\n  private _currentBlock: string | null;\n\n  private _blockResetTimeout?: ReturnType<typeof setTimeout>;\n\n  constructor(opts: BaseBlockTrackerArgs) {\n    super();\n\n    // config\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n    this._usePastBlocks = opts.usePastBlocks || false;\n    // state\n    this._currentBlock = null;\n    this._isRunning = false;\n\n    // bind functions for internal use\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n\n    // listen for handler changes\n    this._setupInternalEvents();\n  }\n\n  async destroy() {\n    this._cancelBlockResetTimeout();\n    await this._maybeEnd();\n    super.removeAllListeners();\n  }\n\n  isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  getCurrentBlock(): string | null {\n    return this._currentBlock;\n  }\n\n  async getLatestBlock(): Promise<string> {\n    // return if available\n    if (this._currentBlock) {\n      return this._currentBlock;\n    }\n    // wait for a new latest block\n    const latestBlock: string = await new Promise((resolve) =>\n      this.once('latest', resolve),\n    );\n    // return newly set current block\n    return latestBlock;\n  }\n\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners(eventName?: string | symbol) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    }\n\n    // re-add internal events\n    this._setupInternalEvents();\n    // trigger stop check just in case\n    this._onRemoveListener();\n\n    return this;\n  }\n\n  /**\n   * To be implemented in subclass.\n   */\n  protected abstract _start(): Promise<void>;\n\n  /**\n   * To be implemented in subclass.\n   */\n  protected abstract _end(): Promise<void>;\n\n  private _setupInternalEvents(): void {\n    // first remove listeners for idempotence\n    this.removeListener('newListener', this._onNewListener);\n    this.removeListener('removeListener', this._onRemoveListener);\n    // then add them\n    this.on('newListener', this._onNewListener);\n    this.on('removeListener', this._onRemoveListener);\n  }\n\n  private _onNewListener(eventName: string | symbol): void {\n    // `newListener` is called *before* the listener is added\n    if (blockTrackerEvents.includes(eventName)) {\n      this._maybeStart();\n    }\n  }\n\n  private _onRemoveListener(): void {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n\n  private async _maybeStart(): Promise<void> {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout();\n    await this._start();\n    this.emit('_started');\n  }\n\n  private async _maybeEnd(): Promise<void> {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n    this._setupBlockResetTimeout();\n    await this._end();\n    this.emit('_ended');\n  }\n\n  private _getBlockTrackerEventCount(): number {\n    return blockTrackerEvents\n      .map((eventName) => this.listenerCount(eventName))\n      .reduce(calculateSum);\n  }\n\n  protected _shouldUseNewBlock(newBlock: string) {\n    const currentBlock = this._currentBlock;\n    if (!currentBlock) {\n      return true;\n    }\n    const newBlockInt = hexToInt(newBlock);\n    const currentBlockInt = hexToInt(currentBlock);\n\n    return (\n      (this._usePastBlocks && newBlockInt < currentBlockInt) ||\n      newBlockInt > currentBlockInt\n    );\n  }\n\n  protected _newPotentialLatest(newBlock: string): void {\n    if (!this._shouldUseNewBlock(newBlock)) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n\n  private _setCurrentBlock(newBlock: string): void {\n    const oldBlock = this._currentBlock;\n    this._currentBlock = newBlock;\n    this.emit('latest', newBlock);\n    this.emit('sync', { oldBlock, newBlock });\n  }\n\n  private _setupBlockResetTimeout(): void {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout();\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(\n      this._resetCurrentBlock,\n      this._blockResetDuration,\n    );\n\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  private _cancelBlockResetTimeout(): void {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n\n  private _resetCurrentBlock(): void {\n    this._currentBlock = null;\n  }\n}\n\n/**\n * Converts a number represented as a string in hexadecimal format into a native\n * number.\n *\n * @param hexInt - The hex string.\n * @returns The number.\n */\nfunction hexToInt(hexInt: string): number {\n  return Number.parseInt(hexInt, 16);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}