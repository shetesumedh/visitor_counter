{"ast":null,"code":"import { p256 } from '@noble/curves/p256';\nimport * as Hex from '../Hex.js';\nimport * as PublicKey from '../PublicKey.js';\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js';\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes) {\n  const r_start = bytes[4] === 0 ? 5 : 4;\n  const r_end = r_start + 32;\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)));\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)));\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s\n  };\n}\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(response) {\n  try {\n    const publicKeyBuffer = response.getPublicKey();\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError();\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer);\n    const cryptoKey = await crypto.subtle.importKey('spki', new Uint8Array(publicKeyBytes), {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n      hash: 'SHA-256'\n    }, true, ['verify']);\n    const publicKey = new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKey));\n    return PublicKey.from(publicKey);\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if (error.message !== 'Permission denied to access object') throw error;\n    const data = new Uint8Array(response.attestationObject);\n    const coordinateLength = 0x20;\n    const cborPrefix = 0x58;\n    const findStart = key => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);\n      for (let i = 0; i < data.length - coordinate.length; i++) if (coordinate.every((byte, j) => data[i + j] === byte)) return i + coordinate.length;\n      throw new CredentialCreationFailedError();\n    };\n    const xStart = findStart(0x21);\n    const yStart = findStart(0x22);\n    return PublicKey.from(new Uint8Array([0x04, ...data.slice(xStart, xStart + coordinateLength), ...data.slice(yStart, yStart + coordinateLength)]));\n  }\n}","map":{"version":3,"names":["p256","Hex","PublicKey","CredentialCreationFailedError","parseAsn1Signature","bytes","r_start","r_end","s_start","r","BigInt","fromBytes","slice","s","CURVE","n","parseCredentialPublicKey","response","publicKeyBuffer","getPublicKey","publicKeyBytes","Uint8Array","cryptoKey","crypto","subtle","importKey","name","namedCurve","hash","publicKey","exportKey","from","error","message","data","attestationObject","coordinateLength","cborPrefix","findStart","key","coordinate","i","length","every","byte","j","xStart","yStart"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/internal/webauthn.ts"],"sourcesContent":["import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}