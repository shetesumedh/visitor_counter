{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\n/**\n * Checks if an input is matched in the bloom filter.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.contains(\n *   '0x00000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020000000000000000000000000000000000000000000008000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n *   '0xef2d6d194084c2de36e0dabfce45d046b37d1106',\n * )\n * // @log: true\n * ```\n *\n * @param bloom - Bloom filter value.\n * @param input - Input to check.\n * @returns Whether the input is matched in the bloom filter.\n */\nexport function contains(bloom, input) {\n  const filter = Bytes.fromHex(bloom);\n  const hash = Hash.keccak256(input, {\n    as: 'Bytes'\n  });\n  for (const i of [0, 2, 4]) {\n    const bit = hash[i + 1] + (hash[i] << 8) & 0x7ff;\n    if ((filter[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0) return false;\n  }\n  return true;\n}\n/**\n * Checks if a string is a valid bloom filter value.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.validate('0x')\n * // @log: false\n *\n * Bloom.validate('0x00000000000000000000008000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000044000200000000000000000002000000000000000000000040000000000000000000000000000020000000000000000000800000000000800000000000800000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000808002000000000400000000000000000000000060000000000000000000000000000000000000000000000100000000000002000000')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid bloom filter.\n */\nexport function validate(value) {\n  return Hex.validate(value) && Hex.size(value) === 256;\n}","map":{"version":3,"names":["Bytes","Hash","Hex","contains","bloom","input","filter","fromHex","hash","keccak256","as","i","bit","Math","floor","validate","value","size"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/Bloom.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Checks if an input is matched in the bloom filter.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.contains(\n *   '0x00000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020000000000000000000000000000000000000000000008000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n *   '0xef2d6d194084c2de36e0dabfce45d046b37d1106',\n * )\n * // @log: true\n * ```\n *\n * @param bloom - Bloom filter value.\n * @param input - Input to check.\n * @returns Whether the input is matched in the bloom filter.\n */\nexport function contains(\n  bloom: Hex.Hex,\n  input: Hex.Hex | Bytes.Bytes,\n): boolean {\n  const filter = Bytes.fromHex(bloom)\n  const hash = Hash.keccak256(input, { as: 'Bytes' })\n\n  for (const i of [0, 2, 4]) {\n    const bit = (hash[i + 1]! + (hash[i]! << 8)) & 0x7ff\n    if ((filter[256 - 1 - Math.floor(bit / 8)]! & (1 << (bit % 8))) === 0)\n      return false\n  }\n\n  return true\n}\n\nexport declare namespace contains {\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid bloom filter value.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.validate('0x')\n * // @log: false\n *\n * Bloom.validate('0x00000000000000000000008000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000044000200000000000000000002000000000000000000000040000000000000000000000000000020000000000000000000800000000000800000000000800000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000808002000000000400000000000000000000000060000000000000000000000000000000000000000000000100000000000002000000')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid bloom filter.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 256\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAE/B;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,QAAQA,CACtBC,KAAc,EACdC,KAA4B;EAE5B,MAAMC,MAAM,GAAGN,KAAK,CAACO,OAAO,CAACH,KAAK,CAAC;EACnC,MAAMI,IAAI,GAAGP,IAAI,CAACQ,SAAS,CAACJ,KAAK,EAAE;IAAEK,EAAE,EAAE;EAAO,CAAE,CAAC;EAEnD,KAAK,MAAMC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;IACzB,MAAMC,GAAG,GAAIJ,IAAI,CAACG,CAAC,GAAG,CAAC,CAAE,IAAIH,IAAI,CAACG,CAAC,CAAE,IAAI,CAAC,CAAC,GAAI,KAAK;IACpD,IAAI,CAACL,MAAM,CAAC,GAAG,GAAG,CAAC,GAAGO,IAAI,CAACC,KAAK,CAACF,GAAG,GAAG,CAAC,CAAC,CAAE,GAAI,CAAC,IAAKA,GAAG,GAAG,CAAG,MAAM,CAAC,EACnE,OAAO,KAAK;EAChB;EAEA,OAAO,IAAI;AACb;AASA;;;;;;;;;;;;;;;;;AAiBA,OAAM,SAAUG,QAAQA,CAACC,KAAa;EACpC,OAAOd,GAAG,CAACa,QAAQ,CAACC,KAAK,CAAC,IAAId,GAAG,CAACe,IAAI,CAACD,KAAK,CAAC,KAAK,GAAG;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}