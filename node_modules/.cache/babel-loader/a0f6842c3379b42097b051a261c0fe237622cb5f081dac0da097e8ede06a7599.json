{"ast":null,"code":"import { bls12_381 as bls } from '@noble/curves/bls12-381';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/** Re-export of noble/curves BLS12-381 utilities. */\nexport const noble = bls;\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function aggregate(points) {\n  const group = typeof points[0]?.x === 'bigint' ? bls.G1 : bls.G2;\n  const point = points.reduce((acc, point) => acc.add(new group.ProjectivePoint(point.x, point.y, point.z)), group.ProjectivePoint.ZERO);\n  return {\n    x: point.px,\n    y: point.py,\n    z: point.pz\n  };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getPublicKey(options) {\n  const {\n    privateKey,\n    size = 'short-key:long-sig'\n  } = options;\n  const group = size === 'short-key:long-sig' ? bls.G1 : bls.G2;\n  const {\n    px,\n    py,\n    pz\n  } = group.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n  return {\n    x: px,\n    y: py,\n    z: pz\n  };\n}\n/**\n * Generates a random BLS12-381 private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = bls.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function sign(options) {\n  const {\n    payload,\n    privateKey,\n    suite,\n    size = 'short-key:long-sig'\n  } = options;\n  const payloadGroup = size === 'short-key:long-sig' ? bls.G2 : bls.G1;\n  const payloadPoint = payloadGroup.hashToCurve(Bytes.from(payload), suite ? {\n    DST: Bytes.fromString(suite)\n  } : undefined);\n  const privateKeyGroup = size === 'short-key:long-sig' ? bls.G1 : bls.G2;\n  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));\n  return {\n    x: signature.px,\n    y: signature.py,\n    z: signature.pz\n  };\n}\n/**\n * Verifies a payload was signed by the provided public key(s).\n *\n * @example\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKey = Bls.randomPrivateKey()\n *\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload, privateKey })\n *\n * const verified = Bls.verify({ // [!code focus]\n *   payload, // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @param options - Verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options) {\n  const {\n    payload,\n    suite\n  } = options;\n  const publicKey = options.publicKey;\n  const signature = options.signature;\n  const isShortSig = typeof signature.x === 'bigint';\n  const group = isShortSig ? bls.G1 : bls.G2;\n  const payloadPoint = group.hashToCurve(Bytes.from(payload), suite ? {\n    DST: Bytes.fromString(suite)\n  } : undefined);\n  const shortSigPairing = () => bls.pairingBatch([{\n    g1: payloadPoint,\n    g2: new bls.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)\n  }, {\n    g1: new bls.G1.ProjectivePoint(signature.x, signature.y, signature.z),\n    g2: bls.G2.ProjectivePoint.BASE.negate()\n  }]);\n  const longSigPairing = () => bls.pairingBatch([{\n    g1: new bls.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),\n    g2: payloadPoint\n  }, {\n    g1: bls.G1.ProjectivePoint.BASE,\n    g2: new bls.G2.ProjectivePoint(signature.x, signature.y, signature.z)\n  }]);\n  return bls.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls.fields.Fp12.ONE);\n}","map":{"version":3,"names":["bls12_381","bls","Bytes","Hex","noble","aggregate","points","group","x","G1","G2","point","reduce","acc","add","ProjectivePoint","y","z","ZERO","px","py","pz","getPublicKey","options","privateKey","size","fromPrivateKey","from","slice","randomPrivateKey","as","bytes","utils","fromBytes","sign","payload","suite","payloadGroup","payloadPoint","hashToCurve","DST","fromString","undefined","privateKeyGroup","signature","multiply","normPrivateKeyToScalar","verify","publicKey","isShortSig","shortSigPairing","pairingBatch","g1","g2","BASE","negate","longSigPairing","fields","Fp12","eql","ONE"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/Bls.ts"],"sourcesContent":["import type { ProjPointType } from '@noble/curves/abstract/weierstrass'\nimport { bls12_381 as bls } from '@noble/curves/bls12-381'\n\nimport type * as BlsPoint from './BlsPoint.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { OneOf } from './internal/types.js'\n\nexport type Size = 'short-key:long-sig' | 'long-key:short-sig'\n\n/** Re-export of noble/curves BLS12-381 utilities. */\nexport const noble = bls\n\n/**\n * Aggregates a set of BLS points that are either on the G1 or G2 curves (ie. public keys or signatures).\n *\n * @example\n * ### Aggregating Signatures\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n *\n * const signatures = [\n *   Bls.sign({ payload, privateKey: '0x...' }),\n *   Bls.sign({ payload, privateKey: '0x...' }),\n * ]\n * const signature = Bls.aggregate(signatures)\n * ```\n *\n * @example\n * ### Aggregating Public Keys\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKeys = [\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n * ]\n * const publicKey = Bls.aggregate(publicKeys)\n * ```\n *\n * @param points - The points to aggregate.\n * @returns The aggregated point.\n */\nexport function aggregate<const points extends readonly BlsPoint.BlsPoint[]>(\n  points: points,\n): points extends readonly BlsPoint.G1[] ? BlsPoint.G1 : BlsPoint.G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function aggregate(\n  points: readonly BlsPoint.BlsPoint[],\n): BlsPoint.BlsPoint {\n  const group = typeof points[0]?.x === 'bigint' ? bls.G1 : bls.G2\n  const point = points.reduce(\n    (acc, point) =>\n      acc.add(new (group as any).ProjectivePoint(point.x, point.y, point.z)),\n    group.ProjectivePoint.ZERO,\n  )\n  return {\n    x: point.px,\n    y: point.py,\n    z: point.pz,\n  }\n}\n\nexport declare namespace aggregate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the BLS12-381 public key from a provided private key.\n *\n * Public Keys can be derived as a point on one of the BLS12-381 groups:\n *\n * - G1 Point (Default):\n *   - short (48 bytes)\n *   - computes longer G2 Signatures (96 bytes)\n * - G2 Point:\n *   - long (96 bytes)\n *   - computes short G1 Signatures (48 bytes)\n *\n * @example\n * ### Short G1 Public Keys (Default)\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Long G2 Public Keys\n *\n * A G2 Public Key can be derived as a G2 point (96 bytes) using `size: 'long-key:short-sig'`.\n *\n * This will allow you to compute G1 Signatures (48 bytes) with {@link ox#Bls.(sign:function)}.\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({\n *   privateKey: '0x...',\n *   size: 'long-key:short-sig',\n * })\n *\n * publicKey\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * ### Serializing\n *\n * Public Keys can be serialized to hex or bytes using {@link ox#BlsPoint.(toHex:function)} or {@link ox#BlsPoint.(toBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n *\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * //    ^?\n *\n *\n * const publicKeyBytes = BlsPoint.toBytes(publicKey)\n * //    ^?\n *\n * ```\n *\n * They can also be deserialized from hex or bytes using {@link ox#BlsPoint.(fromHex:function)} or {@link ox#BlsPoint.(fromBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKeyHex = '0x...'\n *\n * const publicKey = BlsPoint.fromHex(publicKeyHex, 'G1')\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<size extends Size = 'short-key:long-sig'>(\n  options: getPublicKey.Options<size>,\n): size extends 'short-key:long-sig' ? BlsPoint.G1 : BlsPoint.G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getPublicKey(options: getPublicKey.Options): BlsPoint.BlsPoint {\n  const { privateKey, size = 'short-key:long-sig' } = options\n  const group = size === 'short-key:long-sig' ? bls.G1 : bls.G2\n  const { px, py, pz } = group.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return { x: px, y: py, z: pz }\n}\n\nexport declare namespace getPublicKey {\n  type Options<size extends Size = 'short-key:long-sig'> = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Size of the public key to compute.\n     *\n     * - `'short-key:long-sig'`: 48 bytes; computes long signatures (96 bytes)\n     * - `'long-key:short-sig'`: 96 bytes; computes short signatures (48 bytes)\n     *\n     * @default 'short-key:long-sig'\n     */\n    size?: size | Size | undefined\n  }\n\n  type ErrorType = Hex.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random BLS12-381 private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = bls.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const signature = Bls.sign({ // [!code focus]\n *   payload: Hex.random(32), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Serializing\n *\n * Signatures can be serialized to hex or bytes using {@link ox#BlsPoint.(toHex:function)} or {@link ox#BlsPoint.(toBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint, Hex } from 'ox'\n *\n * const signature = Bls.sign({ payload: Hex.random(32), privateKey: '0x...' })\n *\n * const signatureHex = BlsPoint.toHex(signature)\n * //    ^?\n *\n *\n *\n * const signatureBytes = BlsPoint.toBytes(signature)\n * //    ^?\n *\n *\n * ```\n *\n * They can also be deserialized from hex or bytes using {@link ox#BlsPoint.(fromHex:function)} or {@link ox#BlsPoint.(fromBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const signatureHex = '0x...'\n *\n * const signature = BlsPoint.fromHex(signatureHex, 'G2')\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param options - The signing options.\n * @returns BLS Point.\n */\nexport function sign<size extends Size = 'short-key:long-sig'>(\n  options: sign.Options<size>,\n): size extends 'short-key:long-sig' ? BlsPoint.G2 : BlsPoint.G1\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function sign(options: sign.Options): BlsPoint.BlsPoint {\n  const { payload, privateKey, suite, size = 'short-key:long-sig' } = options\n\n  const payloadGroup = size === 'short-key:long-sig' ? bls.G2 : bls.G1\n  const payloadPoint = payloadGroup.hashToCurve(\n    Bytes.from(payload),\n    suite ? { DST: Bytes.fromString(suite) } : undefined,\n  )\n\n  const privateKeyGroup = size === 'short-key:long-sig' ? bls.G1 : bls.G2\n  const signature = payloadPoint.multiply(\n    privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)),\n  ) as ProjPointType<any>\n\n  return {\n    x: signature.px,\n    y: signature.py,\n    z: signature.pz,\n  }\n}\n\nexport declare namespace sign {\n  type Options<size extends Size = 'short-key:long-sig'> = {\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * BLS private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Ciphersuite to use for signing. Defaults to \"Basic\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#section-4\n     * @default 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_'\n     */\n    suite?: string | undefined\n    /**\n     * Size of the signature to compute.\n     *\n     * - `'long-key:short-sig'`: 48 bytes\n     * - `'short-key:long-sig'`: 96 bytes\n     *\n     * @default 'short-key:long-sig'\n     */\n    size?: size | Size | undefined\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key(s).\n *\n * @example\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKey = Bls.randomPrivateKey()\n *\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload, privateKey })\n *\n * const verified = Bls.verify({ // [!code focus]\n *   payload, // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @param options - Verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { payload, suite } = options\n\n  const publicKey = options.publicKey as unknown as BlsPoint.BlsPoint<any>\n  const signature = options.signature as unknown as BlsPoint.BlsPoint<any>\n\n  const isShortSig = typeof signature.x === 'bigint'\n\n  const group = isShortSig ? bls.G1 : bls.G2\n  const payloadPoint = group.hashToCurve(\n    Bytes.from(payload),\n    suite ? { DST: Bytes.fromString(suite) } : undefined,\n  ) as ProjPointType<any>\n\n  const shortSigPairing = () =>\n    bls.pairingBatch([\n      {\n        g1: payloadPoint,\n        g2: new bls.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z),\n      },\n      {\n        g1: new bls.G1.ProjectivePoint(signature.x, signature.y, signature.z),\n        g2: bls.G2.ProjectivePoint.BASE.negate(),\n      },\n    ])\n\n  const longSigPairing = () =>\n    bls.pairingBatch([\n      {\n        g1: new bls.G1.ProjectivePoint(\n          publicKey.x,\n          publicKey.y,\n          publicKey.z,\n        ).negate(),\n        g2: payloadPoint,\n      },\n      {\n        g1: bls.G1.ProjectivePoint.BASE,\n        g2: new bls.G2.ProjectivePoint(signature.x, signature.y, signature.z),\n      },\n    ])\n\n  return bls.fields.Fp12.eql(\n    isShortSig ? shortSigPairing() : longSigPairing(),\n    bls.fields.Fp12.ONE,\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /**\n     * Payload that was signed.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * Ciphersuite to use for verification. Defaults to \"Basic\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#section-4\n     * @default 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_'\n     */\n    suite?: string | undefined\n  } & OneOf<\n    | {\n        publicKey: BlsPoint.G1\n        signature: BlsPoint.G2\n      }\n    | {\n        publicKey: BlsPoint.G2\n        signature: BlsPoint.G1\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}