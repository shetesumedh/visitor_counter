{"ast":null,"code":"import { createClient, custom } from 'viem';\nimport { getAddress, parseAccount } from 'viem/utils';\nimport { ConnectorAccountNotFoundError, ConnectorChainMismatchError, ConnectorNotConnectedError, ConnectorUnavailableReconnectingError } from '../errors/config.js';\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient(config, parameters = {}) {\n  // Get connection\n  let connection;\n  if (parameters.connector) {\n    const {\n      connector\n    } = parameters;\n    if (config.state.status === 'reconnecting' && !connector.getAccounts && !connector.getChainId) throw new ConnectorUnavailableReconnectingError({\n      connector\n    });\n    const [accounts, chainId] = await Promise.all([connector.getAccounts().catch(e => {\n      if (parameters.account === null) return [];\n      throw e;\n    }), connector.getChainId()]);\n    connection = {\n      accounts: accounts,\n      chainId,\n      connector\n    };\n  } else connection = config.state.connections.get(config.state.current);\n  if (!connection) throw new ConnectorNotConnectedError();\n  const chainId = parameters.chainId ?? connection.chainId;\n  // Check connector using same chainId as connection\n  const connectorChainId = await connection.connector.getChainId();\n  if (connectorChainId !== connection.chainId) throw new ConnectorChainMismatchError({\n    connectionChainId: connection.chainId,\n    connectorChainId\n  });\n  const connector = connection.connector;\n  if (connector.getClient) return connector.getClient({\n    chainId\n  });\n  // Default using `custom` transport\n  const account = parseAccount(parameters.account ?? connection.accounts[0]);\n  if (account) account.address = getAddress(account.address); // TODO: Checksum address as part of `parseAccount`?\n  // If account was provided, check that it exists on the connector\n  if (parameters.account && !connection.accounts.some(x => x.toLowerCase() === account.address.toLowerCase())) throw new ConnectorAccountNotFoundError({\n    address: account.address,\n    connector\n  });\n  const chain = config.chains.find(chain => chain.id === chainId);\n  const provider = await connection.connector.getProvider({\n    chainId\n  });\n  return createClient({\n    account,\n    chain,\n    name: 'Connector Client',\n    transport: opts => custom(provider)({\n      ...opts,\n      retryCount: 0\n    })\n  });\n}","map":{"version":3,"names":["createClient","custom","getAddress","parseAccount","ConnectorAccountNotFoundError","ConnectorChainMismatchError","ConnectorNotConnectedError","ConnectorUnavailableReconnectingError","getConnectorClient","config","parameters","connection","connector","state","status","getAccounts","getChainId","accounts","chainId","Promise","all","catch","e","account","connections","get","current","connectorChainId","connectionChainId","getClient","address","some","x","toLowerCase","chain","chains","find","id","provider","getProvider","name","transport","opts","retryCount"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/@wagmi/core/src/actions/getConnectorClient.ts"],"sourcesContent":["import {\n  type Account,\n  type Address,\n  type BaseErrorType,\n  type Client,\n  createClient,\n  custom,\n} from 'viem'\nimport { getAddress, parseAccount } from 'viem/utils'\n\nimport type { Config, Connection } from '../createConfig.js'\nimport type { ErrorType } from '../errors/base.js'\nimport {\n  ConnectorAccountNotFoundError,\n  type ConnectorAccountNotFoundErrorType,\n  ConnectorChainMismatchError,\n  type ConnectorChainMismatchErrorType,\n  ConnectorNotConnectedError,\n  type ConnectorNotConnectedErrorType,\n  ConnectorUnavailableReconnectingError,\n  type ConnectorUnavailableReconnectingErrorType,\n} from '../errors/config.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type GetConnectorClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  ChainIdParameter<config, chainId> &\n    ConnectorParameter & {\n      /**\n       * Account to use for the client.\n       *\n       * - `Account | Address`: An Account MUST exist on the connector.\n       * - `null`: Account MAY NOT exist on the connector. This is useful for\n       *   actions that can infer the account from the connector (e.g. sending a\n       *   call without a connected account â€“ the user will be prompted to select\n       *   an account within the wallet).\n       */\n      account?: Address | Account | null | undefined\n    }\n>\n\nexport type GetConnectorClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  Client<\n    config['_internal']['transports'][chainId],\n    Extract<config['chains'][number], { id: chainId }>,\n    Account\n  >\n>\n\nexport type GetConnectorClientErrorType =\n  | ConnectorAccountNotFoundErrorType\n  | ConnectorChainMismatchErrorType\n  | ConnectorNotConnectedErrorType\n  | ConnectorUnavailableReconnectingErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/getConnectorClient */\nexport async function getConnectorClient<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: GetConnectorClientParameters<config, chainId> = {},\n): Promise<GetConnectorClientReturnType<config, chainId>> {\n  // Get connection\n  let connection: Connection | undefined\n  if (parameters.connector) {\n    const { connector } = parameters\n    if (\n      config.state.status === 'reconnecting' &&\n      !connector.getAccounts &&\n      !connector.getChainId\n    )\n      throw new ConnectorUnavailableReconnectingError({ connector })\n\n    const [accounts, chainId] = await Promise.all([\n      connector.getAccounts().catch((e) => {\n        if (parameters.account === null) return []\n        throw e\n      }),\n      connector.getChainId(),\n    ])\n    connection = {\n      accounts: accounts as readonly [Address, ...Address[]],\n      chainId,\n      connector,\n    }\n  } else connection = config.state.connections.get(config.state.current!)\n  if (!connection) throw new ConnectorNotConnectedError()\n\n  const chainId = parameters.chainId ?? connection.chainId\n\n  // Check connector using same chainId as connection\n  const connectorChainId = await connection.connector.getChainId()\n  if (connectorChainId !== connection.chainId)\n    throw new ConnectorChainMismatchError({\n      connectionChainId: connection.chainId,\n      connectorChainId,\n    })\n\n  // If connector has custom `getClient` implementation\n  type Return = GetConnectorClientReturnType<config, chainId>\n  const connector = connection.connector\n  if (connector.getClient)\n    return connector.getClient({ chainId }) as unknown as Return\n\n  // Default using `custom` transport\n  const account = parseAccount(parameters.account ?? connection.accounts[0]!)\n  if (account) account.address = getAddress(account.address) // TODO: Checksum address as part of `parseAccount`?\n\n  // If account was provided, check that it exists on the connector\n  if (\n    parameters.account &&\n    !connection.accounts.some(\n      (x) => x.toLowerCase() === account.address.toLowerCase(),\n    )\n  )\n    throw new ConnectorAccountNotFoundError({\n      address: account.address,\n      connector,\n    })\n\n  const chain = config.chains.find((chain) => chain.id === chainId)\n  const provider = (await connection.connector.getProvider({ chainId })) as {\n    request(...args: any): Promise<any>\n  }\n\n  return createClient({\n    account,\n    chain,\n    name: 'Connector Client',\n    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n  }) as Return\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}