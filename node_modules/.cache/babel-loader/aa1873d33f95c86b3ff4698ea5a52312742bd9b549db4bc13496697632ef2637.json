{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiParameters = decodeAbiParameters;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst getAddress_js_1 = require(\"../address/getAddress.js\");\nconst cursor_js_1 = require(\"../cursor.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst slice_js_1 = require(\"../data/slice.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst fromBytes_js_1 = require(\"../encoding/fromBytes.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst toHex_js_1 = require(\"../encoding/toHex.js\");\nconst encodeAbiParameters_js_1 = require(\"./encodeAbiParameters.js\");\nfunction decodeAbiParameters(params, data) {\n  const bytes = typeof data === 'string' ? (0, toBytes_js_1.hexToBytes)(data) : data;\n  const cursor = (0, cursor_js_1.createCursor)(bytes);\n  if ((0, size_js_1.size)(bytes) === 0 && params.length > 0) throw new abi_js_1.AbiDecodingZeroDataError();\n  if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32) throw new abi_js_1.AbiDecodingDataSizeTooSmallError({\n    data: typeof data === 'string' ? data : (0, toHex_js_1.bytesToHex)(data),\n    params: params,\n    size: (0, size_js_1.size)(data)\n  });\n  let consumed = 0;\n  const values = [];\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i];\n    cursor.setPosition(consumed);\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0\n    });\n    consumed += consumed_;\n    values.push(data);\n  }\n  return values;\n}\nfunction decodeParameter(cursor, param, {\n  staticPosition\n}) {\n  const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor);\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor) {\n  const value = cursor.readBytes(32);\n  return [(0, getAddress_js_1.checksumAddress)((0, toHex_js_1.bytesToHex)((0, slice_js_1.sliceBytes)(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, {\n  length,\n  staticPosition\n}) {\n  if (!length) {\n    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    cursor.setPosition(start);\n    const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfLength));\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  if (hasDynamicChild(param)) {\n    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\nfunction decodeBool(cursor) {\n  return [(0, fromBytes_js_1.bytesToBool)(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\nfunction decodeBytes(cursor, param, {\n  staticPosition\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));\n    cursor.setPosition(staticPosition + offset);\n    const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));\n    if (length === 0) {\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    cursor.setPosition(staticPosition + 32);\n    return [(0, toHex_js_1.bytesToHex)(data), 32];\n  }\n  const value = (0, toHex_js_1.bytesToHex)(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? (0, fromBytes_js_1.bytesToBigInt)(value, {\n    signed\n  }) : (0, fromBytes_js_1.bytesToNumber)(value, {\n    signed\n  }), 32];\n}\nfunction decodeTuple(cursor, param, {\n  staticPosition\n}) {\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  if (hasDynamicChild(param)) {\n    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\nfunction decodeString(cursor, {\n  staticPosition\n}) {\n  const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = (0, fromBytes_js_1.bytesToString)((0, trim_js_1.trim)(data));\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["exports","decodeAbiParameters","abi_js_1","require","getAddress_js_1","cursor_js_1","size_js_1","slice_js_1","trim_js_1","fromBytes_js_1","toBytes_js_1","toHex_js_1","encodeAbiParameters_js_1","params","data","bytes","hexToBytes","cursor","createCursor","size","length","AbiDecodingZeroDataError","AbiDecodingDataSizeTooSmallError","bytesToHex","consumed","values","i","param","setPosition","consumed_","decodeParameter","staticPosition","push","arrayComponents","getArrayComponents","type","decodeArray","decodeTuple","decodeAddress","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","InvalidAbiDecodingTypeError","docsPath","sizeOfLength","sizeOfOffset","value","readBytes","checksumAddress","sliceBytes","offset","bytesToNumber","start","startOfData","dynamicChild","hasDynamicChild","bytesToBool","_","split","Number","parseInt","signed","bytesToBigInt","hasUnnamedChild","components","some","name","component","bytesToString","trim","endsWith"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/abi/decodeAbiParameters.ts"],"sourcesContent":["import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}