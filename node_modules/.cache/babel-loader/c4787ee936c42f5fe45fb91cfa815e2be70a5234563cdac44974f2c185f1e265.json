{"ast":null,"code":"import { ChainNotConfiguredError, ProviderNotFoundError, createConnector, extractRpcUrls } from '@wagmi/core';\nimport { SwitchChainError, UserRejectedRequestError, getAddress, numberToHex } from 'viem';\nwalletConnect.type = 'walletConnect';\nexport function walletConnect(parameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true;\n  let provider_;\n  let providerPromise;\n  const NAMESPACE = 'eip155';\n  let accountsChanged;\n  let chainChanged;\n  let connect;\n  let displayUri;\n  let sessionDelete;\n  let disconnect;\n  return createConnector(config => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null);\n      if (!provider) return;\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n      if (!sessionDelete) {\n        sessionDelete = this.onSessionDelete.bind(this);\n        provider.on('session_delete', sessionDelete);\n      }\n    },\n    async connect({\n      chainId,\n      ...rest\n    } = {}) {\n      try {\n        const provider = await this.getProvider();\n        if (!provider) throw new ProviderNotFoundError();\n        if (!displayUri) {\n          displayUri = this.onDisplayUri;\n          provider.on('display_uri', displayUri);\n        }\n        let targetChainId = chainId;\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {};\n          const isChainSupported = config.chains.some(x => x.id === state.chainId);\n          if (isChainSupported) targetChainId = state.chainId;else targetChainId = config.chains[0]?.id;\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.');\n        const isChainsStale = await this.isChainsStale();\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect();\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains.filter(chain => chain.id !== targetChainId).map(optionalChain => optionalChain.id);\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest ? {\n              pairingTopic: rest.pairingTopic\n            } : {})\n          });\n          this.setRequestedChainsIds(config.chains.map(x => x.id));\n        }\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map(x => getAddress(x));\n        const currentChainId = await this.getChainId();\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri);\n          displayUri = undefined;\n        }\n        if (connect) {\n          provider.removeListener('connect', connect);\n          connect = undefined;\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this);\n          provider.on('accountsChanged', accountsChanged);\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this);\n          provider.on('chainChanged', chainChanged);\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this);\n          provider.on('disconnect', disconnect);\n        }\n        if (!sessionDelete) {\n          sessionDelete = this.onSessionDelete.bind(this);\n          provider.on('session_delete', sessionDelete);\n        }\n        return {\n          accounts,\n          chainId: currentChainId\n        };\n      } catch (error) {\n        if (/(user rejected|connection request reset)/i.test(error?.message)) {\n          throw new UserRejectedRequestError(error);\n        }\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      try {\n        await provider?.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test(error.message)) throw error;\n      } finally {\n        if (chainChanged) {\n          provider?.removeListener('chainChanged', chainChanged);\n          chainChanged = undefined;\n        }\n        if (disconnect) {\n          provider?.removeListener('disconnect', disconnect);\n          disconnect = undefined;\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this);\n          provider?.on('connect', connect);\n        }\n        if (accountsChanged) {\n          provider?.removeListener('accountsChanged', accountsChanged);\n          accountsChanged = undefined;\n        }\n        if (sessionDelete) {\n          provider?.removeListener('session_delete', sessionDelete);\n          sessionDelete = undefined;\n        }\n        this.setRequestedChainsIds([]);\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      return provider.accounts.map(x => getAddress(x));\n    },\n    async getProvider({\n      chainId\n    } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map(x => x.id);\n        if (!optionalChains.length) return;\n        const {\n          EthereumProvider\n        } = await import('@walletconnect/ethereum-provider');\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(config.chains.map(chain => {\n            const [url] = extractRpcUrls({\n              chain,\n              transports: config.transports\n            });\n            return [chain.id, url];\n          })),\n          showQrModal: parameters.showQrModal ?? true\n        });\n      }\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider();\n        provider_ = await providerPromise;\n        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);\n      }\n      if (chainId) await this.switchChain?.({\n        chainId\n      });\n      return provider_;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      return provider.chainId;\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false;\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale();\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {});\n          return false;\n        }\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({\n      addEthereumChainParameter,\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      try {\n        await Promise.all([new Promise(resolve => {\n          const listener = ({\n            chainId: currentChainId\n          }) => {\n            if (currentChainId === chainId) {\n              config.emitter.off('change', listener);\n              resolve();\n            }\n          };\n          config.emitter.on('change', listener);\n        }), provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: numberToHex(chainId)\n          }]\n        })]);\n        const requestedChains = await this.getRequestedChainsIds();\n        this.setRequestedChainsIds([...requestedChains, chainId]);\n        return chain;\n      } catch (err) {\n        const error = err;\n        if (/(user rejected)/i.test(error.message)) throw new UserRejectedRequestError(error);\n        // Indicates chain is not added to provider\n        try {\n          let blockExplorerUrls;\n          if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;else blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];\n          let rpcUrls;\n          if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;else rpcUrls = [...chain.rpcUrls.default.http];\n          const addEthereumChain = {\n            blockExplorerUrls,\n            chainId: numberToHex(chainId),\n            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n            iconUrls: addEthereumChainParameter?.iconUrls,\n            nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n            rpcUrls\n          };\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [addEthereumChain]\n          });\n          const requestedChains = await this.getRequestedChainsIds();\n          this.setRequestedChainsIds([...requestedChains, chainId]);\n          return chain;\n        } catch (error) {\n          throw new UserRejectedRequestError(error);\n        }\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId);\n      const accounts = await this.getAccounts();\n      config.emitter.emit('connect', {\n        accounts,\n        chainId\n      });\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([]);\n      config.emitter.emit('disconnect');\n      const provider = await this.getProvider();\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged);\n        accountsChanged = undefined;\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged);\n        chainChanged = undefined;\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      if (sessionDelete) {\n        provider.removeListener('session_delete', sessionDelete);\n        sessionDelete = undefined;\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this);\n        provider.on('connect', connect);\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    },\n    onSessionDelete() {\n      this.onDisconnect();\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return [];\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(account => Number.parseInt(account.split(':')[1] || ''));\n      return chainIds ?? [];\n    },\n    async getRequestedChainsIds() {\n      return (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? [];\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     */\n    async isChainsStale() {\n      if (!isNewChainsStale) return false;\n      const connectorChains = config.chains.map(x => x.id);\n      const namespaceChains = this.getNamespaceChainsIds();\n      if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) return false;\n      const requestedChains = await this.getRequestedChainsIds();\n      return !connectorChains.every(id => requestedChains.includes(id));\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains);\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains`;\n    }\n  }));\n}","map":{"version":3,"names":["ChainNotConfiguredError","ProviderNotFoundError","createConnector","extractRpcUrls","SwitchChainError","UserRejectedRequestError","getAddress","numberToHex","walletConnect","type","parameters","isNewChainsStale","provider_","providerPromise","NAMESPACE","accountsChanged","chainChanged","connect","displayUri","sessionDelete","disconnect","config","id","name","setup","provider","getProvider","catch","onConnect","bind","on","onSessionDelete","chainId","rest","onDisplayUri","targetChainId","state","storage","getItem","isChainSupported","chains","some","x","Error","isChainsStale","session","optionalChains","filter","chain","map","optionalChain","pairingTopic","setRequestedChainsIds","accounts","enable","currentChainId","getChainId","removeListener","undefined","onAccountsChanged","onChainChanged","onDisconnect","error","test","message","getAccounts","initProvider","length","EthereumProvider","init","disableProviderPing","projectId","rpcMap","Object","fromEntries","url","transports","showQrModal","events","setMaxListeners","Number","POSITIVE_INFINITY","switchChain","isAuthorized","Promise","all","addEthereumChainParameter","find","resolve","listener","emitter","off","request","method","params","requestedChains","getRequestedChainsIds","err","blockExplorerUrls","blockExplorers","default","rpcUrls","http","addEthereumChain","chainName","iconUrls","nativeCurrency","emit","connectInfo","_error","uri","data","getNamespaceChainsIds","chainIds","namespaces","account","parseInt","split","requestedChainsStorageKey","connectorChains","namespaceChains","includes","every","setItem"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/connectors/src/walletConnect.ts"],"sourcesContent":["import {\n  ChainNotConfiguredError,\n  type Connector,\n  ProviderNotFoundError,\n  createConnector,\n  extractRpcUrls,\n} from '@wagmi/core'\nimport type { Compute, ExactPartial, Omit } from '@wagmi/core/internal'\nimport type { EthereumProvider } from '@walletconnect/ethereum-provider'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\ntype WalletConnectConnector = Connector & {\n  onDisplayUri(uri: string): void\n  onSessionDelete(data: { topic: string }): void\n}\n\ntype EthereumProviderOptions = Parameters<(typeof EthereumProvider)['init']>[0]\n\nexport type WalletConnectParameters = Compute<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a potentially valid chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain if the wallet does not support dynamic session updates.\n     * This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>\n\nwalletConnect.type = 'walletConnect' as const\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true\n\n  type Provider = Awaited<ReturnType<(typeof EthereumProvider)['init']>>\n  type Properties = {\n    connect(parameters?: {\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      pairingTopic?: string | undefined\n    }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n    getNamespaceChainsIds(): number[]\n    getRequestedChainsIds(): Promise<number[]>\n    isChainsStale(): Promise<boolean>\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n    onSessionDelete(data: { topic: string }): void\n    setRequestedChainsIds(chains: number[]): void\n    requestedChainsStorageKey: `${string}.requestedChains`\n  }\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[]\n  }\n\n  let provider_: Provider | undefined\n  let providerPromise: Promise<typeof provider_>\n  const NAMESPACE = 'eip155'\n\n  let accountsChanged: WalletConnectConnector['onAccountsChanged'] | undefined\n  let chainChanged: WalletConnectConnector['onChainChanged'] | undefined\n  let connect: WalletConnectConnector['onConnect'] | undefined\n  let displayUri: WalletConnectConnector['onDisplayUri'] | undefined\n  let sessionDelete: WalletConnectConnector['onSessionDelete'] | undefined\n  let disconnect: WalletConnectConnector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null)\n      if (!provider) return\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n      if (!sessionDelete) {\n        sessionDelete = this.onSessionDelete.bind(this)\n        provider.on('session_delete', sessionDelete)\n      }\n    },\n    async connect({ chainId, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        if (!provider) throw new ProviderNotFoundError()\n        if (!displayUri) {\n          displayUri = this.onDisplayUri\n          provider.on('display_uri', displayUri)\n        }\n\n        let targetChainId = chainId\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {}\n          const isChainSupported = config.chains.some(\n            (x) => x.id === state.chainId,\n          )\n          if (isChainSupported) targetChainId = state.chainId\n          else targetChainId = config.chains[0]?.id\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.')\n\n        const isChainsStale = await this.isChainsStale()\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect()\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id)\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest\n              ? { pairingTopic: rest.pairingTopic }\n              : {}),\n          })\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id))\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map((x) => getAddress(x))\n        const currentChainId = await this.getChainId()\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri)\n          displayUri = undefined\n        }\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n        if (!sessionDelete) {\n          sessionDelete = this.onSessionDelete.bind(this)\n          provider.on('session_delete', sessionDelete)\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user rejected|connection request reset)/i.test(\n            (error as ProviderRpcError)?.message,\n          )\n        ) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      try {\n        await provider?.disconnect()\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error\n      } finally {\n        if (chainChanged) {\n          provider?.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider?.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider?.on('connect', connect)\n        }\n        if (accountsChanged) {\n          provider?.removeListener('accountsChanged', accountsChanged)\n          accountsChanged = undefined\n        }\n        if (sessionDelete) {\n          provider?.removeListener('session_delete', sessionDelete)\n          sessionDelete = undefined\n        }\n\n        this.setRequestedChainsIds([])\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return provider.accounts.map((x) => getAddress(x))\n    },\n    async getProvider({ chainId } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number]\n        if (!optionalChains.length) return\n        const { EthereumProvider } = await import(\n          '@walletconnect/ethereum-provider'\n        )\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(\n            config.chains.map((chain) => {\n              const [url] = extractRpcUrls({\n                chain,\n                transports: config.transports,\n              })\n              return [chain.id, url]\n            }),\n          ),\n          showQrModal: parameters.showQrModal ?? true,\n        })\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider_ = await providerPromise\n        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY)\n      }\n      if (chainId) await this.switchChain?.({ chainId })\n      return provider_!\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      return provider.chainId\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([\n          this.getAccounts(),\n          this.getProvider(),\n        ])\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale()\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {})\n          return false\n        }\n        return true\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await Promise.all([\n          new Promise<void>((resolve) => {\n            const listener = ({\n              chainId: currentChainId,\n            }: { chainId?: number | undefined }) => {\n              if (currentChainId === chainId) {\n                config.emitter.off('change', listener)\n                resolve()\n              }\n            }\n            config.emitter.on('change', listener)\n          }),\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n        ])\n\n        const requestedChains = await this.getRequestedChainsIds()\n        this.setRequestedChainsIds([...requestedChains, chainId])\n\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        if (/(user rejected)/i.test(error.message))\n          throw new UserRejectedRequestError(error)\n\n        // Indicates chain is not added to provider\n        try {\n          let blockExplorerUrls: string[] | undefined\n          if (addEthereumChainParameter?.blockExplorerUrls)\n            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n          else\n            blockExplorerUrls = chain.blockExplorers?.default.url\n              ? [chain.blockExplorers?.default.url]\n              : []\n\n          let rpcUrls: readonly string[]\n          if (addEthereumChainParameter?.rpcUrls?.length)\n            rpcUrls = addEthereumChainParameter.rpcUrls\n          else rpcUrls = [...chain.rpcUrls.default.http]\n\n          const addEthereumChain = {\n            blockExplorerUrls,\n            chainId: numberToHex(chainId),\n            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n            iconUrls: addEthereumChainParameter?.iconUrls,\n            nativeCurrency:\n              addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n            rpcUrls,\n          } satisfies AddEthereumChainParameter\n\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [addEthereumChain],\n          })\n\n          const requestedChains = await this.getRequestedChainsIds()\n          this.setRequestedChainsIds([...requestedChains, chainId])\n          return chain\n        } catch (error) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId)\n      const accounts = await this.getAccounts()\n      config.emitter.emit('connect', { accounts, chainId })\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([])\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (sessionDelete) {\n        provider.removeListener('session_delete', sessionDelete)\n        sessionDelete = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n    onSessionDelete() {\n      this.onDisconnect()\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return []\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(\n        (account) => Number.parseInt(account.split(':')[1] || ''),\n      )\n      return chainIds ?? []\n    },\n    async getRequestedChainsIds() {\n      return (\n        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []\n      )\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     */\n    async isChainsStale() {\n      if (!isNewChainsStale) return false\n\n      const connectorChains = config.chains.map((x) => x.id)\n      const namespaceChains = this.getNamespaceChainsIds()\n      if (\n        namespaceChains.length &&\n        !namespaceChains.some((id) => connectorChains.includes(id))\n      )\n        return false\n\n      const requestedChains = await this.getRequestedChainsIds()\n      return !connectorChains.every((id) => requestedChains.includes(id))\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains)\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}