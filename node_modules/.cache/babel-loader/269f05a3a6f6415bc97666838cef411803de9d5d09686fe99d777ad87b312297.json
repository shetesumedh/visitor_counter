{"ast":null,"code":"import { RpcRequestError, SwitchChainError, UserRejectedRequestError, custom, fromHex, getAddress, keccak256, numberToHex, stringToHex } from 'viem';\nimport { rpc } from 'viem/utils';\nimport { ChainNotConfiguredError, ConnectorNotConnectedError } from '../errors/config.js';\nimport { createConnector } from './createConnector.js';\nmock.type = 'mock';\nexport function mock(parameters) {\n  const transactionCache = new Map();\n  const features = parameters.features ?? {\n    defaultConnected: false\n  };\n  let connected = features.defaultConnected;\n  let connectedChainId;\n  return createConnector(config => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id;\n    },\n    async connect({\n      chainId\n    } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to connect.'));\n        throw features.connectError;\n      }\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts'\n      });\n      let currentChainId = await this.getChainId();\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain({\n          chainId\n        });\n        currentChainId = chain.id;\n      }\n      connected = true;\n      return {\n        accounts: accounts.map(x => getAddress(x)),\n        chainId: currentChainId\n      };\n    },\n    async disconnect() {\n      connected = false;\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError();\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const hexChainId = await provider.request({\n        method: 'eth_chainId'\n      });\n      return fromHex(hexChainId, 'number');\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false;\n      if (!connected) return false;\n      const accounts = await this.getAccounts();\n      return !!accounts.length;\n    },\n    async switchChain({\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: numberToHex(chainId)\n        }]\n      });\n      return chain;\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect');\n      connected = false;\n    },\n    async getProvider({\n      chainId\n    } = {}) {\n      const chain = config.chains.find(x => x.id === chainId) ?? config.chains[0];\n      const url = chain.rpcUrls.default.http[0];\n      const request = async ({\n        method,\n        params\n      }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId);\n        if (method === 'eth_requestAccounts') return parameters.accounts;\n        if (method === 'eth_signTypedData_v4') if (features.signTypedDataError) {\n          if (typeof features.signTypedDataError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign typed data.'));\n          throw features.signTypedDataError;\n        }\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to switch chain.'));\n            throw features.switchChainError;\n          }\n          connectedChainId = fromHex(params[0].chainId, 'number');\n          this.onChainChanged(connectedChainId.toString());\n          return;\n        }\n        if (method === 'wallet_watchAsset') {\n          if (features.watchAssetError) {\n            if (typeof features.watchAssetError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to switch chain.'));\n            throw features.watchAssetError;\n          }\n          return connected;\n        }\n        if (method === 'wallet_getCapabilities') return {\n          '0x2105': {\n            paymasterService: {\n              supported: params[0] === '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n            },\n            sessionKeys: {\n              supported: true\n            }\n          },\n          '0x14A34': {\n            paymasterService: {\n              supported: params[0] === '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n            }\n          }\n        };\n        if (method === 'wallet_sendCalls') {\n          const hashes = [];\n          const calls = params[0].calls;\n          for (const call of calls) {\n            const {\n              result,\n              error\n            } = await rpc.http(url, {\n              body: {\n                method: 'eth_sendTransaction',\n                params: [call]\n              }\n            });\n            if (error) throw new RpcRequestError({\n              body: {\n                method,\n                params\n              },\n              error,\n              url\n            });\n            hashes.push(result);\n          }\n          const id = keccak256(stringToHex(JSON.stringify(calls)));\n          transactionCache.set(id, hashes);\n          return {\n            id\n          };\n        }\n        if (method === 'wallet_getCallsStatus') {\n          const hashes = transactionCache.get(params[0]);\n          if (!hashes) return {\n            atomic: false,\n            chainId: '0x1',\n            id: params[0],\n            status: 100,\n            receipts: [],\n            version: '2.0.0'\n          };\n          const receipts = await Promise.all(hashes.map(async hash => {\n            const {\n              result,\n              error\n            } = await rpc.http(url, {\n              body: {\n                method: 'eth_getTransactionReceipt',\n                params: [hash],\n                id: 0\n              }\n            });\n            if (error) throw new RpcRequestError({\n              body: {\n                method,\n                params\n              },\n              error,\n              url\n            });\n            if (!result) return null;\n            return {\n              blockHash: result.blockHash,\n              blockNumber: result.blockNumber,\n              gasUsed: result.gasUsed,\n              logs: result.logs,\n              status: result.status,\n              transactionHash: result.transactionHash\n            };\n          }));\n          const receipts_ = receipts.filter(x => x !== null);\n          if (receipts_.length === 0) return {\n            atomic: false,\n            chainId: '0x1',\n            id: params[0],\n            status: 100,\n            receipts: [],\n            version: '2.0.0'\n          };\n          return {\n            atomic: false,\n            chainId: '0x1',\n            id: params[0],\n            status: 200,\n            receipts: receipts_,\n            version: '2.0.0'\n          };\n        }\n        if (method === 'wallet_showCallsStatus') return;\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign message.'));\n            throw features.signMessageError;\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign';\n          params = [params[1], params[0]];\n        }\n        const body = {\n          method,\n          params\n        };\n        const {\n          error,\n          result\n        } = await rpc.http(url, {\n          body\n        });\n        if (error) throw new RpcRequestError({\n          body,\n          error,\n          url\n        });\n        return result;\n      };\n      return custom({\n        request\n      })({\n        retryCount: 0\n      });\n    }\n  }));\n}","map":{"version":3,"names":["RpcRequestError","SwitchChainError","UserRejectedRequestError","custom","fromHex","getAddress","keccak256","numberToHex","stringToHex","rpc","ChainNotConfiguredError","ConnectorNotConnectedError","createConnector","mock","type","parameters","transactionCache","Map","features","defaultConnected","connected","connectedChainId","config","id","name","setup","chains","connect","chainId","connectError","Error","provider","getProvider","accounts","request","method","currentChainId","getChainId","chain","switchChain","map","x","disconnect","getAccounts","hexChainId","isAuthorized","reconnect","length","find","params","onAccountsChanged","onDisconnect","emitter","emit","onChainChanged","Number","_error","url","rpcUrls","default","http","signTypedDataError","switchChainError","toString","watchAssetError","paymasterService","supported","sessionKeys","hashes","calls","call","result","error","body","push","JSON","stringify","set","get","atomic","status","receipts","version","Promise","all","hash","blockHash","blockNumber","gasUsed","logs","transactionHash","receipts_","filter","signMessageError","retryCount"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/core/src/connectors/mock.ts"],"sourcesContent":["import {\n  type Address,\n  type EIP1193RequestFn,\n  type Hex,\n  RpcRequestError,\n  SwitchChainError,\n  type Transport,\n  UserRejectedRequestError,\n  type WalletCallReceipt,\n  type WalletGetCallsStatusReturnType,\n  type WalletRpcSchema,\n  custom,\n  fromHex,\n  getAddress,\n  keccak256,\n  numberToHex,\n  stringToHex,\n} from 'viem'\nimport { rpc } from 'viem/utils'\n\nimport {\n  ChainNotConfiguredError,\n  ConnectorNotConnectedError,\n} from '../errors/config.js'\nimport { createConnector } from './createConnector.js'\n\nexport type MockParameters = {\n  accounts: readonly [Address, ...Address[]]\n  features?:\n    | {\n        defaultConnected?: boolean | undefined\n        connectError?: boolean | Error | undefined\n        switchChainError?: boolean | Error | undefined\n        signMessageError?: boolean | Error | undefined\n        signTypedDataError?: boolean | Error | undefined\n        reconnect?: boolean | undefined\n        watchAssetError?: boolean | Error | undefined\n      }\n    | undefined\n}\n\nmock.type = 'mock' as const\nexport function mock(parameters: MockParameters) {\n  const transactionCache = new Map<Hex, Hex[]>()\n  const features =\n    parameters.features ??\n    ({ defaultConnected: false } satisfies MockParameters['features'])\n\n  type Provider = ReturnType<\n    Transport<'custom', unknown, EIP1193RequestFn<WalletRpcSchema>>\n  >\n  type Properties = {\n    connect(parameters?: {\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      foo?: string | undefined\n    }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n  }\n  let connected = features.defaultConnected\n  let connectedChainId: number\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id\n    },\n    async connect({ chainId } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean')\n          throw new UserRejectedRequestError(new Error('Failed to connect.'))\n        throw features.connectError\n      }\n\n      const provider = await this.getProvider()\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts',\n      })\n\n      let currentChainId = await this.getChainId()\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain!({ chainId })\n        currentChainId = chain.id\n      }\n\n      connected = true\n\n      return {\n        accounts: accounts.map((x) => getAddress(x)),\n        chainId: currentChainId,\n      }\n    },\n    async disconnect() {\n      connected = false\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError()\n      const provider = await this.getProvider()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return fromHex(hexChainId, 'number')\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false\n      if (!connected) return false\n      const accounts = await this.getAccounts()\n      return !!accounts.length\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: numberToHex(chainId) }],\n      })\n      return chain\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n      connected = false\n    },\n    async getProvider({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      const url = chain.rpcUrls.default.http[0]!\n\n      const request: EIP1193RequestFn = async ({ method, params }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId)\n        if (method === 'eth_requestAccounts') return parameters.accounts\n        if (method === 'eth_signTypedData_v4')\n          if (features.signTypedDataError) {\n            if (typeof features.signTypedDataError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign typed data.'),\n              )\n            throw features.signTypedDataError\n          }\n\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.switchChainError\n          }\n          type Params = [{ chainId: Hex }]\n          connectedChainId = fromHex((params as Params)[0].chainId, 'number')\n          this.onChainChanged(connectedChainId.toString())\n          return\n        }\n\n        if (method === 'wallet_watchAsset') {\n          if (features.watchAssetError) {\n            if (typeof features.watchAssetError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.watchAssetError\n          }\n          return connected\n        }\n\n        if (method === 'wallet_getCapabilities')\n          return {\n            '0x2105': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n              },\n              sessionKeys: {\n                supported: true,\n              },\n            },\n            '0x14A34': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n              },\n            },\n          }\n\n        if (method === 'wallet_sendCalls') {\n          const hashes = []\n          const calls = (params as any)[0].calls\n          for (const call of calls) {\n            const { result, error } = await rpc.http(url, {\n              body: {\n                method: 'eth_sendTransaction',\n                params: [call],\n              },\n            })\n            if (error)\n              throw new RpcRequestError({\n                body: { method, params },\n                error,\n                url,\n              })\n            hashes.push(result)\n          }\n          const id = keccak256(stringToHex(JSON.stringify(calls)))\n          transactionCache.set(id, hashes)\n          return { id }\n        }\n\n        if (method === 'wallet_getCallsStatus') {\n          const hashes = transactionCache.get((params as any)[0])\n          if (!hashes)\n            return {\n              atomic: false,\n              chainId: '0x1',\n              id: (params as any)[0],\n              status: 100,\n              receipts: [],\n              version: '2.0.0',\n            } satisfies WalletGetCallsStatusReturnType\n\n          const receipts = await Promise.all(\n            hashes.map(async (hash) => {\n              const { result, error } = await rpc.http(url, {\n                body: {\n                  method: 'eth_getTransactionReceipt',\n                  params: [hash],\n                  id: 0,\n                },\n              })\n              if (error)\n                throw new RpcRequestError({\n                  body: { method, params },\n                  error,\n                  url,\n                })\n              if (!result) return null\n              return {\n                blockHash: result.blockHash,\n                blockNumber: result.blockNumber,\n                gasUsed: result.gasUsed,\n                logs: result.logs,\n                status: result.status,\n                transactionHash: result.transactionHash,\n              } satisfies WalletCallReceipt\n            }),\n          )\n          const receipts_ = receipts.filter((x) => x !== null)\n          if (receipts_.length === 0)\n            return {\n              atomic: false,\n              chainId: '0x1',\n              id: (params as any)[0],\n              status: 100,\n              receipts: [],\n              version: '2.0.0',\n            } satisfies WalletGetCallsStatusReturnType\n          return {\n            atomic: false,\n            chainId: '0x1',\n            id: (params as any)[0],\n            status: 200,\n            receipts: receipts_,\n            version: '2.0.0',\n          } satisfies WalletGetCallsStatusReturnType\n        }\n\n        if (method === 'wallet_showCallsStatus') return\n\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign message.'),\n              )\n            throw features.signMessageError\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign'\n          type Params = [data: Hex, address: Address]\n          params = [(params as Params)[1], (params as Params)[0]]\n        }\n\n        const body = { method, params }\n        const { error, result } = await rpc.http(url, { body })\n        if (error) throw new RpcRequestError({ body, error, url })\n\n        return result\n      }\n      return custom({ request })({ retryCount: 0 })\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}