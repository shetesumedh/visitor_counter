{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidLengthError = exports.InvalidHexValueError = exports.InvalidHexTypeError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromBoolean = fromBoolean;\nexports.fromBytes = fromBytes;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.slice = slice;\nexports.size = size;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toBytes = toBytes;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.validate = validate;\nconst utils_1 = require(\"@noble/curves/abstract/utils\");\nconst Bytes = require(\"./Bytes.js\");\nconst Errors = require(\"./Errors.js\");\nconst Json = require(\"./Json.js\");\nconst internal_bytes = require(\"./internal/bytes.js\");\nconst internal = require(\"./internal/hex.js\");\nconst encoder = new TextEncoder();\nconst hexes = Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction assert(value, options = {}) {\n  const {\n    strict = false\n  } = options;\n  if (!value) throw new InvalidHexTypeError(value);\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value);\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value);\n}\nfunction concat(...values) {\n  return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\nfunction from(value) {\n  if (value instanceof Uint8Array) return fromBytes(value);\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n  return value;\n}\nfunction fromBoolean(value, options = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padLeft(hex, options.size);\n  }\n  return hex;\n}\nfunction fromBytes(value, options = {}) {\n  let string = '';\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]];\n  const hex = `0x${string}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padRight(hex, options.size);\n  }\n  return hex;\n}\nfunction fromNumber(value, options = {}) {\n  const {\n    signed,\n    size\n  } = options;\n  const value_ = BigInt(value);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value_ > maxValue || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`\n    });\n  }\n  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n  const hex = `0x${stringValue}`;\n  if (size) return padLeft(hex, size);\n  return hex;\n}\nfunction fromString(value, options = {}) {\n  return fromBytes(encoder.encode(value), options);\n}\nfunction isEqual(hexA, hexB) {\n  return (0, utils_1.equalBytes)(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\nfunction padLeft(value, size) {\n  return internal.pad(value, {\n    dir: 'left',\n    size\n  });\n}\nfunction padRight(value, size) {\n  return internal.pad(value, {\n    dir: 'right',\n    size\n  });\n}\nfunction random(length) {\n  return fromBytes(Bytes.random(length));\n}\nfunction slice(value, start, end, options = {}) {\n  const {\n    strict\n  } = options;\n  internal.assertStartOffset(value, start);\n  const value_ = `0x${value.replace('0x', '').slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n  if (strict) internal.assertEndOffset(value_, start, end);\n  return value_;\n}\nfunction size(value) {\n  return Math.ceil((value.length - 2) / 2);\n}\nfunction trimLeft(value) {\n  return internal.trim(value, {\n    dir: 'left'\n  });\n}\nfunction trimRight(value) {\n  return internal.trim(value, {\n    dir: 'right'\n  });\n}\nfunction toBigInt(hex, options = {}) {\n  const {\n    signed\n  } = options;\n  if (options.size) internal.assertSize(hex, options.size);\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n  const max_signed = max_unsigned >> 1n;\n  if (value <= max_signed) return value;\n  return value - max_unsigned - 1n;\n}\nfunction toBoolean(hex, options = {}) {\n  if (options.size) internal.assertSize(hex, options.size);\n  const hex_ = trimLeft(hex);\n  if (hex_ === '0x') return false;\n  if (hex_ === '0x1') return true;\n  throw new InvalidHexBooleanError(hex);\n}\nfunction toBytes(hex, options = {}) {\n  return Bytes.fromHex(hex, options);\n}\nfunction toNumber(hex, options = {}) {\n  const {\n    signed,\n    size\n  } = options;\n  if (!signed && !size) return Number(hex);\n  return Number(toBigInt(hex, options));\n}\nfunction toString(hex, options = {}) {\n  const {\n    size\n  } = options;\n  let bytes = Bytes.fromHex(hex);\n  if (size) {\n    internal_bytes.assertSize(bytes, size);\n    bytes = Bytes.trimRight(bytes);\n  }\n  return new TextDecoder().decode(bytes);\n}\nfunction validate(value, options = {}) {\n  const {\n    strict = false\n  } = options;\n  try {\n    assert(value, {\n      strict\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass IntegerOutOfRangeError extends Errors.BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value\n  }) {\n    super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.IntegerOutOfRangeError'\n    });\n  }\n}\nexports.IntegerOutOfRangeError = IntegerOutOfRangeError;\nclass InvalidHexBooleanError extends Errors.BaseError {\n  constructor(hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: ['The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexBooleanError'\n    });\n  }\n}\nexports.InvalidHexBooleanError = InvalidHexBooleanError;\nclass InvalidHexTypeError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n      metaMessages: ['Hex types must be represented as `\"0x${string}\"`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexTypeError'\n    });\n  }\n}\nexports.InvalidHexTypeError = InvalidHexTypeError;\nclass InvalidHexValueError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: ['Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexValueError'\n    });\n  }\n}\nexports.InvalidHexValueError = InvalidHexValueError;\nclass InvalidLengthError extends Errors.BaseError {\n  constructor(value) {\n    super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n      metaMessages: ['It must be an even length.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidLengthError'\n    });\n  }\n}\nexports.InvalidLengthError = InvalidLengthError;\nclass SizeOverflowError extends Errors.BaseError {\n  constructor({\n    givenSize,\n    maxSize\n  }) {\n    super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeOverflowError'\n    });\n  }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  constructor({\n    offset,\n    position,\n    size\n  }) {\n    super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SliceOffsetOutOfBoundsError'\n    });\n  }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n  constructor({\n    size,\n    targetSize,\n    type\n  }) {\n    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeExceedsPaddingSizeError'\n    });\n  }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;","map":{"version":3,"names":["exports","assert","concat","from","fromBoolean","fromBytes","fromNumber","fromString","isEqual","padLeft","padRight","random","slice","size","trimLeft","trimRight","toBigInt","toBoolean","toBytes","toNumber","toString","validate","utils_1","require","Bytes","Errors","Json","internal_bytes","internal","encoder","TextEncoder","hexes","Array","length","_v","i","padStart","value","options","strict","InvalidHexTypeError","test","InvalidHexValueError","startsWith","values","reduce","acc","x","replace","Uint8Array","isArray","hex","Number","assertSize","string","signed","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","undefined","min","stringValue","encode","hexA","hexB","equalBytes","fromHex","pad","dir","start","end","assertStartOffset","assertEndOffset","Math","ceil","trim","max_unsigned","max_signed","hex_","InvalidHexBooleanError","bytes","TextDecoder","decode","BaseError","constructor","Object","defineProperty","metaMessages","stringify","InvalidLengthError","SizeOverflowError","givenSize","maxSize","SliceOffsetOutOfBoundsError","offset","position","SizeExceedsPaddingSizeError","targetSize","type","charAt","toUpperCase","toLowerCase"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/Hex.ts"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Json from './Json.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}