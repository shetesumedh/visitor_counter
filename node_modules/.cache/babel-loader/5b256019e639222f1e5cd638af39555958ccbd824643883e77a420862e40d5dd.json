{"ast":null,"code":"import { getAction } from '../../../utils/getAction.js';\nimport { observe } from '../../../utils/observe.js';\nimport { poll } from '../../../utils/poll.js';\nimport { stringify } from '../../../utils/stringify.js';\nimport { WaitForUserOperationReceiptTimeoutError } from '../../errors/userOperation.js';\nimport { getUserOperationReceipt } from './getUserOperationReceipt.js';\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(client, parameters) {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000\n  } = parameters;\n  let count = 0;\n  const observerId = stringify(['waitForUserOperationReceipt', client.uid, hash]);\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, {\n      resolve,\n      reject\n    }, emit => {\n      const done = fn => {\n        unpoll();\n        fn();\n        unobserve();\n      };\n      const unpoll = poll(async () => {\n        if (retryCount && count >= retryCount) done(() => emit.reject(new WaitForUserOperationReceiptTimeoutError({\n          hash\n        })));\n        try {\n          const receipt = await getAction(client, getUserOperationReceipt, 'getUserOperationReceipt')({\n            hash\n          });\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          const error = err;\n          if (error.name !== 'UserOperationReceiptNotFoundError') done(() => emit.reject(error));\n        }\n        count++;\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      if (timeout) setTimeout(() => done(() => emit.reject(new WaitForUserOperationReceiptTimeoutError({\n        hash\n      }))), timeout);\n      return unpoll;\n    });\n  });\n}","map":{"version":3,"names":["getAction","observe","poll","stringify","WaitForUserOperationReceiptTimeoutError","getUserOperationReceipt","waitForUserOperationReceipt","client","parameters","hash","pollingInterval","retryCount","timeout","count","observerId","uid","Promise","resolve","reject","unobserve","emit","done","fn","unpoll","receipt","err","error","name","emitOnBegin","interval","setTimeout"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/account-abstraction/actions/bundler/waitForUserOperationReceipt.ts"],"sourcesContent":["import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../../utils/poll.js'\nimport { stringify } from '../../../utils/stringify.js'\nimport {\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport {\n  type GetUserOperationReceiptErrorType,\n  getUserOperationReceipt,\n} from './getUserOperationReceipt.js'\n\nexport type WaitForUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The number of times to retry.\n   * @default 6\n   */\n  retryCount?: number | undefined\n  /** Optional timeout (in ms) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForUserOperationReceiptReturnType =\n  Prettify<UserOperationReceipt>\n\nexport type WaitForUserOperationReceiptErrorType =\n  | WaitForUserOperationReceiptTimeoutErrorType\n  | PollErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(\n  client: Client<Transport>,\n  parameters: WaitForUserOperationReceiptParameters,\n): Promise<WaitForUserOperationReceiptReturnType> {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000,\n  } = parameters\n\n  let count = 0\n  const observerId = stringify([\n    'waitForUserOperationReceipt',\n    client.uid,\n    hash,\n  ])\n\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n      const done = (fn: () => void) => {\n        unpoll()\n        fn()\n        unobserve()\n      }\n\n      const unpoll = poll(\n        async () => {\n          if (retryCount && count >= retryCount)\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            )\n\n          try {\n            const receipt = await getAction(\n              client,\n              getUserOperationReceipt,\n              'getUserOperationReceipt',\n            )({ hash })\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            const error = err as GetUserOperationReceiptErrorType\n            if (error.name !== 'UserOperationReceiptNotFoundError')\n              done(() => emit.reject(error))\n          }\n\n          count++\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      if (timeout)\n        setTimeout(\n          () =>\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            ),\n          timeout,\n        )\n\n      return unpoll\n    })\n  })\n}\n"],"mappings":"AAKA,SAASA,SAAS,QAAQ,6BAA6B;AACvD,SAAgCC,OAAO,QAAQ,2BAA2B;AAC1E,SAA6BC,IAAI,QAAQ,wBAAwB;AACjE,SAASC,SAAS,QAAQ,6BAA6B;AACvD,SACEC,uCAAuC,QAElC,+BAA+B;AAEtC,SAEEC,uBAAuB,QAClB,8BAA8B;AA4BrC;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUC,2BAA2BA,CACzCC,MAAyB,EACzBC,UAAiD;EAEjD,MAAM;IACJC,IAAI;IACJC,eAAe,GAAGH,MAAM,CAACG,eAAe;IACxCC,UAAU;IACVC,OAAO,GAAG;EAAO,CAClB,GAAGJ,UAAU;EAEd,IAAIK,KAAK,GAAG,CAAC;EACb,MAAMC,UAAU,GAAGX,SAAS,CAAC,CAC3B,6BAA6B,EAC7BI,MAAM,CAACQ,GAAG,EACVN,IAAI,CACL,CAAC;EAEF,OAAO,IAAIO,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACrC,MAAMC,SAAS,GAAGlB,OAAO,CAACa,UAAU,EAAE;MAAEG,OAAO;MAAEC;IAAM,CAAE,EAAGE,IAAI,IAAI;MAClE,MAAMC,IAAI,GAAIC,EAAc,IAAI;QAC9BC,MAAM,EAAE;QACRD,EAAE,EAAE;QACJH,SAAS,EAAE;MACb,CAAC;MAED,MAAMI,MAAM,GAAGrB,IAAI,CACjB,YAAW;QACT,IAAIS,UAAU,IAAIE,KAAK,IAAIF,UAAU,EACnCU,IAAI,CAAC,MACHD,IAAI,CAACF,MAAM,CACT,IAAId,uCAAuC,CAAC;UAAEK;QAAI,CAAE,CAAC,CACtD,CACF;QAEH,IAAI;UACF,MAAMe,OAAO,GAAG,MAAMxB,SAAS,CAC7BO,MAAM,EACNF,uBAAuB,EACvB,yBAAyB,CAC1B,CAAC;YAAEI;UAAI,CAAE,CAAC;UACXY,IAAI,CAAC,MAAMD,IAAI,CAACH,OAAO,CAACO,OAAO,CAAC,CAAC;QACnC,CAAC,CAAC,OAAOC,GAAG,EAAE;UACZ,MAAMC,KAAK,GAAGD,GAAuC;UACrD,IAAIC,KAAK,CAACC,IAAI,KAAK,mCAAmC,EACpDN,IAAI,CAAC,MAAMD,IAAI,CAACF,MAAM,CAACQ,KAAK,CAAC,CAAC;QAClC;QAEAb,KAAK,EAAE;MACT,CAAC,EACD;QACEe,WAAW,EAAE,IAAI;QACjBC,QAAQ,EAAEnB;OACX,CACF;MAED,IAAIE,OAAO,EACTkB,UAAU,CACR,MACET,IAAI,CAAC,MACHD,IAAI,CAACF,MAAM,CACT,IAAId,uCAAuC,CAAC;QAAEK;MAAI,CAAE,CAAC,CACtD,CACF,EACHG,OAAO,CACR;MAEH,OAAOW,MAAM;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}