{"ast":null,"code":"/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac.js';\nimport { _validateObject, abool, abytes, aInRange, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToHexUnpadded, randomBytes } from \"../utils.js\";\nimport { _createCurveFields, mulEndoUnsafe, negateCt, normalizeZ, pippenger, wNAF } from \"./curve.js\";\nimport { Field, FpInvertBatch, getMinHashLength, mapHashToField, validateField } from \"./modular.js\";\nfunction validateSigVerOpts(opts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag, data) => {\n      const {\n        Err: E\n      } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag, data) {\n      const {\n        Err: E\n      } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 127;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = length << 8 | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return {\n        v,\n        l: data.subarray(pos + length)\n      };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num) {\n      const {\n        Err: E\n      } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data) {\n      const {\n        Err: E\n      } = DER;\n      if (data[0] & 128) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    }\n  },\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E,\n      _int: int,\n      _tlv: tlv\n    } = DER;\n    const data = ensureBytes('signature', hex);\n    const {\n      v: seqBytes,\n      l: seqLeftBytes\n    } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const {\n      v: rBytes,\n      l: rLeftBytes\n    } = tlv.decode(0x02, seqBytes);\n    const {\n      v: sBytes,\n      l: sLeftBytes\n    } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return {\n      r: int.decode(rBytes),\n      s: int.decode(sBytes)\n    };\n  },\n  hexFromSig(sig) {\n    const {\n      _tlv: tlv,\n      _int: int\n    } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3),\n  _4n = BigInt(4);\n// TODO: remove\nexport function _legacyHelperEquat(Fp, a, b) {\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n   * @returns y²\n   */\n  function weierstrassEquation(x) {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n  }\n  return weierstrassEquation;\n}\nexport function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {\n  const {\n    BYTES: expected\n  } = Fn;\n  // Validates if priv key is valid and converts it to bigint.\n  function normPrivateKeyToScalar(key) {\n    let num;\n    if (typeof key === 'bigint') {\n      num = key;\n    } else {\n      let bytes = ensureBytes('private key', key);\n      if (allowedPrivateKeyLengths) {\n        if (!allowedPrivateKeyLengths.includes(bytes.length * 2)) throw new Error('invalid private key');\n        const padded = new Uint8Array(expected);\n        padded.set(bytes, padded.length - bytes.length);\n        bytes = padded;\n      }\n      try {\n        num = Fn.fromBytes(bytes);\n      } catch (error) {\n        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n      }\n    }\n    if (wrapPrivateKey) num = Fn.create(num); // disabled by default, enabled for BLS\n    if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n  }\n  return normPrivateKeyToScalar;\n}\nexport function weierstrassN(CURVE, curveOpts = {}) {\n  const {\n    Fp,\n    Fn\n  } = _createCurveFields('weierstrass', CURVE, curveOpts);\n  const {\n    h: cofactor,\n    n: CURVE_ORDER\n  } = CURVE;\n  _validateObject(curveOpts, {}, {\n    allowInfinityPoint: 'boolean',\n    clearCofactor: 'function',\n    isTorsionFree: 'function',\n    fromBytes: 'function',\n    toBytes: 'function',\n    endo: 'object',\n    wrapPrivateKey: 'boolean'\n  });\n  const {\n    endo\n  } = curveOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n    }\n  }\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(_c, point, isCompressed) {\n    const {\n      x,\n      y\n    } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool('isCompressed', isCompressed);\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes) {\n    abytes(bytes);\n    const L = Fp.BYTES;\n    const LC = L + 1; // length compressed, e.g. 33 for 32-byte field\n    const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === LC && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n      let y;\n      try {\n        y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return {\n        x,\n        y\n      };\n    } else if (length === LU && head === 0x04) {\n      // TODO: more checks\n      const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));\n      const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return {\n        x,\n        y\n      };\n    } else {\n      throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);\n    }\n  }\n  const toBytes = curveOpts.toBytes || pointToBytes;\n  const fromBytes = curveOpts.fromBytes || pointFromBytes;\n  const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y² == x³ + ax + b */\n  function isValidXY(x, y) {\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    return Fp.eql(left, right);\n  }\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y² = x³ + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n  // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title, n, banZero = false) {\n    if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n  function aprjpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      px: x,\n      py: y,\n      pz: z\n    } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return {\n      x,\n      y\n    };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return {\n      x: Fp.ZERO,\n      y: Fp.ZERO\n    };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized(p => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (curveOpts.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const {\n      x,\n      y\n    } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n    k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point {\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(px, py, pz) {\n      this.px = acoord('x', px);\n      this.py = acoord('y', py, true);\n      this.pz = acoord('z', pz);\n      Object.freeze(this);\n    }\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(points) {\n      return normalizeZ(Point, 'pz', points);\n    }\n    static fromBytes(bytes) {\n      abytes(bytes);\n      return Point.fromHex(bytes);\n    }\n    /** Converts hash string or Uint8Array to Point. */\n    static fromHex(hex) {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n    /** Multiplies generator point by privateKey. */\n    static fromPrivateKey(privateKey) {\n      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n    /** Multiscalar Multiplication */\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize = 8, isLazy = true) {\n      wnaf.setWindowSize(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n    /** \"Private method\", don't use it directly */\n    _setWindowSize(windowSize) {\n      this.precompute(windowSize);\n    }\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n    /** Compare one point to another. */\n    equals(other) {\n      aprjpoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate() {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other) {\n      aprjpoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar) {\n      const {\n        endo\n      } = curveOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point, fake; // Fake point is used to const-time mult\n      const mul = n => wnaf.wNAFCached(this, n, Point.normalizeZ);\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(scalar);\n        const {\n          p: k1p,\n          f: k1f\n        } = mul(k1);\n        const {\n          p: k2p,\n          f: k2f\n        } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const {\n          p,\n          f\n        } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc) {\n      const {\n        endo\n      } = curveOpts;\n      const p = this;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasPrecomputes(this)) return this.multiply(sc);\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(sc);\n        // `wNAFCachedUnsafe` is 30% slower\n        const {\n          p1,\n          p2\n        } = mulEndoUnsafe(Point, p, k1, k2);\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.wNAFCachedUnsafe(p, sc);\n      }\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ) {\n      return toAffineMemo(this, invertedZ);\n    }\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree() {\n      const {\n        isTorsionFree\n      } = curveOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n    }\n    clearCofactor() {\n      const {\n        clearCofactor\n      } = curveOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(cofactor);\n    }\n    toBytes(isCompressed = true) {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes(isCompressed = true) {\n      return this.toBytes(isCompressed);\n    }\n    toHex(isCompressed = true) {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  // base / generator point\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  // zero / infinity / identity point\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n  // fields\n  Point.Fp = Fp;\n  Point.Fn = Fn;\n  const bits = Fn.BITS;\n  const wnaf = wNAF(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);\n  return Point;\n}\n// _legacyWeierstrass\n/** @deprecated use `weierstrassN` */\nexport function weierstrassPoints(c) {\n  const {\n    CURVE,\n    curveOpts\n  } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\nexport function ecdsa(Point, ecdsaOpts, curveOpts = {}) {\n  _validateObject(ecdsaOpts, {\n    hash: 'function'\n  }, {\n    hmac: 'function',\n    lowS: 'boolean',\n    randomBytes: 'function',\n    bits2int: 'function',\n    bits2int_modN: 'function'\n  });\n  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;\n  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs)));\n  const {\n    Fp,\n    Fn\n  } = Point;\n  const {\n    ORDER: CURVE_ORDER,\n    BITS: fnBits\n  } = Fn;\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function normalizeS(s) {\n    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;\n  }\n  function aValidRS(title, num) {\n    if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);\n  }\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature {\n    constructor(r, s, recovery) {\n      aValidRS('r', r); // r in [1..N-1]\n      aValidRS('s', s); // s in [1..N-1]\n      this.r = r;\n      this.s = s;\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex) {\n      const L = Fn.BYTES;\n      const b = ensureBytes('compactSignature', hex, L * 2);\n      return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));\n    }\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex) {\n      const {\n        r,\n        s\n      } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n    /**\n     * @todo remove\n     * @deprecated\n     */\n    assertValidity() {}\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n    // ProjPointType<bigint>\n    recoverPublicKey(msgHash) {\n      const FIELD_ORDER = Fp.ORDER;\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromHex(concatBytes(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n    toBytes(format) {\n      if (format === 'compact') return concatBytes(Fn.toBytes(this.r), Fn.toBytes(this.s));\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      throw new Error('invalid format');\n    }\n    // DER-encoded\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return bytesToHex(this.toBytes('der'));\n    }\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return bytesToHex(this.toBytes('compact'));\n    }\n  }\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);\n  const utils = {\n    isValidPrivateKey(privateKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: () => {\n      const n = CURVE_ORDER;\n      return mapHashToField(randomBytes_(getMinHashLength(n)), n);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n      return point.precompute(windowSize, false);\n    }\n  };\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey, isCompressed = true) {\n    return Point.fromPrivateKey(privateKey).toBytes(isCompressed);\n  }\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item) {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const arr = ensureBytes('key', item);\n    const length = arr.length;\n    const L = Fp.BYTES;\n    const LC = L + 1; // e.g. 33 for 32\n    const LU = 2 * L + 1; // e.g. 65 for 32\n    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {\n      return undefined;\n    } else {\n      return length === LC || length === LU;\n    }\n  }\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA, publicB, isCompressed = true) {\n    if (isProbPub(privateA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicB) === false) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);\n  }\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int = ecdsaOpts.bits2int || function (bytes) {\n    // Our custom check \"just in case\", for protection against DoS\n    if (bytes.length > 8192) throw new Error('input is too large');\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = bytesToNumberBE(bytes); // check for == u8 done here\n    const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n  const bits2int_modN = ecdsaOpts.bits2int_modN || function (bytes) {\n    return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n  };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num) {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      hash\n    } = ecdsaOpts;\n    let {\n      lowS,\n      prehash,\n      extraEntropy: ent\n    } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n    return {\n      seed,\n      k2sig\n    };\n  }\n  const defaultSigOpts = {\n    lowS: ecdsaOpts.lowS,\n    prehash: false\n  };\n  const defaultVerOpts = {\n    lowS: ecdsaOpts.lowS,\n    prehash: false\n  };\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash, privKey, opts = defaultSigOpts) {\n    const {\n      seed,\n      k2sig\n    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE.precompute(8);\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    // Verify opts\n    validateSigVerOpts(opts);\n    const {\n      lowS,\n      prehash,\n      format\n    } = opts;\n    // TODO: remove\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    if (format !== undefined && !['compact', 'der', 'js'].includes(format)) throw new Error('format must be \"compact\", \"der\" or \"js\"');\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj = !isHex && !format && typeof sg === 'object' && sg !== null && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';\n    if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    let _sig = undefined;\n    let P;\n    // deduce signature format\n    try {\n      // if (format === 'js') {\n      //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);\n      // } else if (format === 'compact') {\n      //   _sig = Signature.fromCompact(sg);\n      // } else if (format === 'der') {\n      //   _sig = Signature.fromDER(sg);\n      // } else {\n      //   throw new Error('invalid format');\n      // }\n      if (isObj) {\n        if (format === undefined || format === 'js') {\n          _sig = new Signature(sg.r, sg.s);\n        } else {\n          throw new Error('invalid format');\n        }\n      }\n      if (isHex) {\n        // TODO: remove this malleable check\n        // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).\n        // Since DER can also be 2*Fn.BYTES bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    // todo: optional.hash => hash\n    if (prehash) msgHash = ecdsaOpts.hash(msgHash);\n    const {\n      r,\n      s\n    } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = Fn.inv(s); // s^-1\n    const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n    const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\n    if (R.is0()) return false;\n    const v = Fn.create(R.x); // v = r.x mod n\n    return v === r;\n  }\n  // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?\n  // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);\n  return Object.freeze({\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    utils,\n    Point,\n    Signature\n  });\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n  const CURVE = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength);\n  const curveOpts = {\n    Fp,\n    Fn,\n    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    wrapPrivateKey: c.wrapPrivateKey,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes\n  };\n  return {\n    CURVE,\n    curveOpts\n  };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n  const {\n    CURVE,\n    curveOpts\n  } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts = {\n    hash: c.hash,\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN\n  };\n  return {\n    CURVE,\n    curveOpts,\n    ecdsaOpts\n  };\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n  const {\n    Fp,\n    Fn\n  } = Point;\n  // TODO: remove\n  function isWithinCurveOrder(num) {\n    return inRange(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);\n  return Object.assign({}, {\n    CURVE: c,\n    Point: Point,\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  });\n}\nfunction _ecdsa_new_output_to_legacy(c, ecdsa) {\n  return Object.assign({}, ecdsa, {\n    ProjectivePoint: ecdsa.Point,\n    CURVE: c\n  });\n}\n// _ecdsa_legacy\nexport function weierstrass(c) {\n  const {\n    CURVE,\n    curveOpts,\n    ecdsaOpts\n  } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, ecdsaOpts, curveOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n  validateField(Fp);\n  const {\n    A,\n    B,\n    Z\n  } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return {\n      x,\n      y\n    };\n  };\n}","map":{"version":3,"names":["hmac","_validateObject","abool","abytes","aInRange","bitMask","bytesToHex","bytesToNumberBE","concatBytes","createHmacDrbg","ensureBytes","hexToBytes","inRange","isBytes","memoized","numberToHexUnpadded","randomBytes","_createCurveFields","mulEndoUnsafe","negateCt","normalizeZ","pippenger","wNAF","Field","FpInvertBatch","getMinHashLength","mapHashToField","validateField","validateSigVerOpts","opts","lowS","undefined","prehash","DERErr","Error","constructor","m","DER","Err","_tlv","encode","tag","data","E","length","dataLen","len","lenLen","t","decode","pos","first","isLong","lengthBytes","subarray","b","v","l","_int","num","_0n","hex","Number","parseInt","toSig","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","r","s","hexFromSig","sig","rs","ss","seq","BigInt","_1n","_2n","_3n","_4n","_legacyHelperEquat","Fp","a","weierstrassEquation","x","x2","sqr","x3","mul","add","_legacyHelperNormPriv","Fn","allowedPrivateKeyLengths","wrapPrivateKey","BYTES","expected","normPrivateKeyToScalar","key","bytes","includes","padded","Uint8Array","set","fromBytes","error","create","isValidNot0","weierstrassN","CURVE","curveOpts","h","cofactor","n","CURVE_ORDER","allowInfinityPoint","clearCofactor","isTorsionFree","toBytes","endo","is0","beta","splitScalar","assertCompressionIsSupported","isOdd","pointToBytes","_c","point","isCompressed","y","toAffine","bx","hasEvenY","pprefix","of","pointFromBytes","L","LC","LU","head","tail","isValid","y2","sqrt","sqrtError","err","message","isYOdd","isHeadOdd","neg","isValidXY","left","right","eql","Gx","Gy","_4a3","pow","_27b2","acoord","title","banZero","aprjpoint","other","Point","toAffineMemo","p","iz","px","py","pz","z","ONE","inv","ax","ay","zz","ZERO","assertValidMemo","finishEndo","endoBeta","k1p","k2p","k1neg","k2neg","Object","freeze","fromAffine","points","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","msm","scalars","precompute","windowSize","isLazy","wnaf","setWindowSize","_setWindowSize","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","scalar","fake","wNAFCached","k1","k2","f","k1f","k2f","multiplyUnsafe","sc","hasPrecomputes","p1","p2","wNAFCachedUnsafe","multiplyAndAddUnsafe","Q","sum","invertedZ","toRawBytes","toHex","toString","bits","BITS","Math","ceil","weierstrassPoints","c","_weierstrass_legacy_opts_to_new","_weierstrass_new_output_to_legacy","ecdsa","ecdsaOpts","hash","bits2int","bits2int_modN","randomBytes_","hmac_","msgs","ORDER","fnBits","isBiggerThanHalfOrder","number","HALF","normalizeS","aValidRS","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","FIELD_ORDER","rec","hasCofactor","radj","R","ir","u1","u2","hasHighS","format","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","getPublicKey","isProbPub","item","arr","getSharedSecret","privateA","publicB","delta","ORDER_MASK","int2octets","prepSig","defaultSigOpts","some","k","extraEntropy","ent","h1int","d","seedArgs","e","push","seed","k2sig","kBytes","ik","q","normS","defaultVerOpts","sign","privKey","drbg","outputLen","verify","signature","publicKey","sg","isHex","isObj","_sig","derError","is","nBitLength","_ecdsa_legacy_opts_to_new","isWithinCurveOrder","assign","ProjectivePoint","_ecdsa_new_output_to_legacy","weierstrass","signs","SWUFpSqrtRatio","Z","o","c1","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c5","c6","c7","sqrtRatio","u","tv1","tv2","tv3","tv5","tv4","isQR","cmov","i","tvv5","e1","value","y1","mapToCurveSimpleSWU","A","B","tv6","tv4_inv"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/@noble/curves/src/abstract/weierstrass.ts"],"sourcesContent":["/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac.js';\nimport {\n  _validateObject,\n  abool,\n  abytes,\n  aInRange,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  ensureBytes,\n  hexToBytes,\n  inRange,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  randomBytes,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n} from './curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  validateField,\n  type IField,\n  type NLength,\n} from './modular.ts';\n\nexport type { AffinePoint };\nexport type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism ψ**.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism ψ transforms a point: `P = (x, y) ↦ ψ(P) = (β·x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k ≡ k₁ + k₂·λ (mod n)`\n * 3. Then these are combined: `k·P = k₁·P + k₂·ψ(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta: β ∈ Fₚ with β³ = 1, β ≠ 1\n * * lambda: λ ∈ Fₙ with λ³ = 1, λ ≠ 1\n * * splitScalar decomposes k ↦ k₁, k₂, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-λ, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts;\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\nexport type Entropy = Hex | boolean;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = {\n  lowS?: boolean;\n  prehash?: boolean;\n  format?: 'compact' | 'der' | 'js' | undefined;\n};\n\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\n\n/** Instance methods for 3D XYZ points. */\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  /** projective x coordinate. Note: different from .x */\n  readonly px: T;\n  /** projective y coordinate. Note: different from .y */\n  readonly py: T;\n  /** projective z coordinate */\n  readonly pz: T;\n  /** affine x coordinate */\n  get x(): T;\n  /** affine y coordinate */\n  get y(): T;\n  assertValidity(): void;\n  clearCofactor(): ProjPointType<T>;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  /**\n   * Massively speeds up `p.multiply(n)` by using wnaf precompute tables (caching).\n   * Table generation takes 30MB of ram and 10ms on high-end CPU, but may take\n   * much longer on slow devices.\n   * Actual generation will happen on first call of `.multiply()`.\n   * By default, BASE point is precomputed.\n   * @param windowSize - table window size\n   * @param isLazy - (default true) allows to defer generation\n   */\n  precompute(windowSize?: number, isLazy?: boolean): ProjPointType<T>;\n\n  /** Converts 3D XYZ projective point to 2D xy affine coordinates */\n  toAffine(invertedZ?: T): AffinePoint<T>;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  /** @deprecated use `multiplyUnsafe` */\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  /** @deprecated use `p.y % 2n === 0n` */\n  hasEvenY(): boolean;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n\n/** Static methods for 3D XYZ points. */\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromBytes(encodedPoint: Uint8Array): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\n// LegacyWeierstrassOpts\nexport type CurvePointsTypeWithLength<T> = Readonly<CurvePointsType<T> & Partial<NLength>>;\n\n// LegacyWeierstrass\nexport type CurvePointsRes<T> = {\n  /** @deprecated import individual CURVE params */\n  CURVE: CurvePointsType<T>;\n  Point: ProjConstructor<T>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: ProjConstructor<T>;\n  /** @deprecated */\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  /** @deprecated */\n  weierstrassEquation: (x: T) => T;\n  /** @deprecated use `Point.Fn.isValidNot0(num)` */\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// Aliases to legacy types\n// export type CurveType = LegacyECDSAOpts;\n// export type CurveFn = LegacyECDSA;\n// export type CurvePointsRes<T> = LegacyWeierstrass<T>;\n// export type CurvePointsType<T> = LegacyWeierstrassOpts<T>;\n// export type CurvePointsTypeWithLength<T> = LegacyWeierstrassOpts<T>;\n// export type BasicWCurve<T> = LegacyWeierstrassOpts<T>;\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\n// wrapPrivateKey: bls12-381 requires mod(n) instead of rejecting keys >= n\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  // TODO: remove\n  allowedPrivateKeyLengths: readonly number[]; // for P521\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  wrapPrivateKey: boolean;\n  isTorsionFree: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  clearCofactor: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n */\nexport type ECDSAOpts = {\n  hash: CHash;\n  hmac?: HmacFnSync;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\n/** ECDSA is only supported for prime fields, not Fp2 (extension fields). */\nexport interface ECDSA {\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  Point: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    // TODO: deprecate those two\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    /** @deprecated */\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = ensureBytes('signature', hex);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// TODO: remove\nexport function _legacyHelperEquat<T>(Fp: IField<T>, a: T, b: T): (x: T) => T {\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n  }\n  return weierstrassEquation;\n}\nexport function _legacyHelperNormPriv(\n  Fn: IField<bigint>,\n  allowedPrivateKeyLengths?: readonly number[],\n  wrapPrivateKey?: boolean\n): (key: PrivKey) => bigint {\n  const { BYTES: expected } = Fn;\n  // Validates if priv key is valid and converts it to bigint.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    let num: bigint;\n    if (typeof key === 'bigint') {\n      num = key;\n    } else {\n      let bytes = ensureBytes('private key', key);\n      if (allowedPrivateKeyLengths) {\n        if (!allowedPrivateKeyLengths.includes(bytes.length * 2))\n          throw new Error('invalid private key');\n        const padded = new Uint8Array(expected);\n        padded.set(bytes, padded.length - bytes.length);\n        bytes = padded;\n      }\n      try {\n        num = Fn.fromBytes(bytes);\n      } catch (error) {\n        throw new Error(\n          `invalid private key: expected ui8a of size ${expected}, got ${typeof key}`\n        );\n      }\n    }\n    if (wrapPrivateKey) num = Fn.create(num); // disabled by default, enabled for BLS\n    if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n  }\n  return normPrivateKeyToScalar;\n}\n\nexport function weierstrassN<T>(\n  CURVE: WeierstrassOpts<T>,\n  curveOpts: WeierstrassExtraOpts<T> = {}\n): ProjConstructor<T> {\n  const { Fp, Fn } = _createCurveFields('weierstrass', CURVE, curveOpts);\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(\n    curveOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n      wrapPrivateKey: 'boolean',\n    }\n  );\n\n  const { endo } = curveOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (\n      !Fp.is0(CURVE.a) ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n    }\n  }\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: ProjConstructor<T>,\n    point: ProjPointType<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool('isCompressed', isCompressed);\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes);\n    const L = Fp.BYTES;\n    const LC = L + 1; // length compressed, e.g. 33 for 32-byte field\n    const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === LC && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd!(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === LU && head === 0x04) {\n      // TODO: more checks\n      const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));\n      const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`\n      );\n    }\n  }\n\n  const toBytes = curveOpts.toBytes || pointToBytes;\n  const fromBytes = curveOpts.fromBytes || pointFromBytes;\n  const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y² == x³ + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y² = x³ + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { px: x, py: y, pz: z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (curveOpts.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // fields\n    static readonly Fp = Fp;\n    static readonly Fn = Fn;\n\n    readonly px: T;\n    readonly py: T;\n    readonly pz: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(px: T, py: T, pz: T) {\n      this.px = acoord('x', px);\n      this.py = acoord('y', py, true);\n      this.pz = acoord('z', pz);\n      Object.freeze(this);\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, 'pz', points);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      abytes(bytes);\n      return Point.fromHex(bytes);\n    }\n\n    /** Converts hash string or Uint8Array to Point. */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    /** Multiplies generator point by privateKey. */\n    static fromPrivateKey(privateKey: PrivKey) {\n      const normPrivateKeyToScalar = _legacyHelperNormPriv(\n        Fn,\n        curveOpts.allowedPrivateKeyLengths,\n        curveOpts.wrapPrivateKey\n      );\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    /** Multiscalar Multiplication */\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.setWindowSize(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    /** \"Private method\", don't use it directly */\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = curveOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.wNAFCached(this, n, Point.normalizeZ);\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = curveOpts;\n      const p = this;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasPrecomputes(this)) return this.multiply(sc);\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n        // `wNAFCachedUnsafe` is 30% slower\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.wNAFCachedUnsafe(p, sc);\n      }\n    }\n\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = curveOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = curveOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    /** @deprecated use `toBytes` */\n    toRawBytes(isCompressed = true): Uint8Array {\n      return this.toBytes(isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = wNAF(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);\n  return Point;\n}\n\n// _legacyWeierstrass\n/** @deprecated use `weierstrassN` */\nexport function weierstrassPoints<T>(c: CurvePointsTypeWithLength<T>): CurvePointsRes<T> {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  toDERRawBytes(): Uint8Array;\n  toDERHex(): string;\n  // toBytes(format?: string): Uint8Array;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint, recovery?: number): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\nexport type SignatureLike = { r: bigint; s: bigint };\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac?: HmacFnSync;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\nexport type CurveFn = {\n  CURVE: CurvePointsType<bigint>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  Point: ProjConstructor<bigint>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function ecdsa(\n  Point: ProjConstructor<bigint>,\n  ecdsaOpts: ECDSAOpts,\n  curveOpts: WeierstrassExtraOpts<bigint> = {}\n): ECDSA {\n  _validateObject(\n    ecdsaOpts,\n    { hash: 'function' },\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n\n  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;\n  const hmac_: HmacFnSync =\n    ecdsaOpts.hmac ||\n    (((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs))) satisfies HmacFnSync);\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;\n  }\n  function aValidRS(title: string, num: bigint) {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      aValidRS('r', r); // r in [1..N-1]\n      aValidRS('s', s); // s in [1..N-1]\n      this.r = r;\n      this.s = s;\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const L = Fn.BYTES;\n      const b = ensureBytes('compactSignature', hex, L * 2);\n      return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    /**\n     * @todo remove\n     * @deprecated\n     */\n    assertValidity(): void {}\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    // ProjPointType<bigint>\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const FIELD_ORDER = Fp.ORDER;\n      const { r, s, recovery: rec } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromHex(concatBytes(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n\n    toBytes(format: 'compact' | 'der') {\n      if (format === 'compact') return concatBytes(Fn.toBytes(this.r), Fn.toBytes(this.s));\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      throw new Error('invalid format');\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return bytesToHex(this.toBytes('der'));\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return bytesToHex(this.toBytes('compact'));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(\n    Fn,\n    curveOpts.allowedPrivateKeyLengths,\n    curveOpts.wrapPrivateKey\n  );\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const n = CURVE_ORDER;\n      return mapHashToField(randomBytes_(getMinHashLength(n)), n);\n    },\n\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const arr = ensureBytes('key', item);\n    const length = arr.length;\n    const L = Fp.BYTES;\n    const LC = L + 1; // e.g. 33 for 32\n    const LU = 2 * L + 1; // e.g. 65 for 32\n    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {\n      return undefined;\n    } else {\n      return length === LC || length === LU;\n    }\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicB) === false) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash } = ecdsaOpts;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: ecdsaOpts.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: ecdsaOpts.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<RecoveredSignature>(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE.precompute(8);\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n\n    // Verify opts\n    validateSigVerOpts(opts);\n    const { lowS, prehash, format } = opts;\n\n    // TODO: remove\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n\n    if (format !== undefined && !['compact', 'der', 'js'].includes(format))\n      throw new Error('format must be \"compact\", \"der\" or \"js\"');\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj =\n      !isHex &&\n      !format &&\n      typeof sg === 'object' &&\n      sg !== null &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n\n    // deduce signature format\n    try {\n      // if (format === 'js') {\n      //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);\n      // } else if (format === 'compact') {\n      //   _sig = Signature.fromCompact(sg);\n      // } else if (format === 'der') {\n      //   _sig = Signature.fromDER(sg);\n      // } else {\n      //   throw new Error('invalid format');\n      // }\n      if (isObj) {\n        if (format === undefined || format === 'js') {\n          _sig = new Signature(sg.r, sg.s);\n        } else {\n          throw new Error('invalid format');\n        }\n      }\n      if (isHex) {\n        // TODO: remove this malleable check\n        // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).\n        // Since DER can also be 2*Fn.BYTES bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    // todo: optional.hash => hash\n    if (prehash) msgHash = ecdsaOpts.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = Fn.inv(s); // s^-1\n    const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n    const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\n    if (R.is0()) return false;\n    const v = Fn.create(R.x); // v = r.x mod n\n    return v === r;\n  }\n  // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?\n  // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);\n  return Object.freeze({\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    utils,\n    Point,\n    Signature,\n  });\n}\n\nexport type WsPointComposed<T> = {\n  CURVE: WeierstrassOpts<T>;\n  curveOpts: WeierstrassExtraOpts<T>;\n};\nexport type WsComposed = {\n  CURVE: WeierstrassOpts<bigint>;\n  curveOpts: WeierstrassExtraOpts<bigint>;\n  ecdsaOpts: ECDSAOpts;\n};\nfunction _weierstrass_legacy_opts_to_new<T>(c: CurvePointsType<T>): WsPointComposed<T> {\n  const CURVE: WeierstrassOpts<T> = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength);\n  const curveOpts: WeierstrassExtraOpts<T> = {\n    Fp,\n    Fn,\n    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    wrapPrivateKey: c.wrapPrivateKey,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes,\n  };\n  return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c: CurveType): WsComposed {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts: ECDSAOpts = {\n    hash: c.hash,\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN,\n  };\n  return { CURVE, curveOpts, ecdsaOpts };\n}\nfunction _weierstrass_new_output_to_legacy<T>(\n  c: CurvePointsType<T>,\n  Point: ProjConstructor<T>\n): CurvePointsRes<T> {\n  const { Fp, Fn } = Point;\n  // TODO: remove\n  function isWithinCurveOrder(num: bigint): boolean {\n    return inRange(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(\n    Fn,\n    c.allowedPrivateKeyLengths,\n    c.wrapPrivateKey\n  );\n  return Object.assign(\n    {},\n    {\n      CURVE: c,\n      Point: Point,\n      ProjectivePoint: Point,\n      normPrivateKeyToScalar,\n      weierstrassEquation,\n      isWithinCurveOrder,\n    }\n  );\n}\nfunction _ecdsa_new_output_to_legacy(c: CurveType, ecdsa: ECDSA): CurveFn {\n  return Object.assign({}, ecdsa, {\n    ProjectivePoint: ecdsa.Point,\n    CURVE: c,\n  });\n}\n\n// _ecdsa_legacy\nexport function weierstrass(c: CurveType): CurveFn {\n  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, ecdsaOpts, curveOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}