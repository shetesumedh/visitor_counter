{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendTransaction = sendTransaction;\nconst parseAccount_js_1 = require(\"../../accounts/utils/parseAccount.js\");\nconst account_js_1 = require(\"../../errors/account.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst recoverAuthorizationAddress_js_1 = require(\"../../utils/authorization/recoverAuthorizationAddress.js\");\nconst assertCurrentChain_js_1 = require(\"../../utils/chain/assertCurrentChain.js\");\nconst getTransactionError_js_1 = require(\"../../utils/errors/getTransactionError.js\");\nconst extract_js_1 = require(\"../../utils/formatters/extract.js\");\nconst transactionRequest_js_1 = require(\"../../utils/formatters/transactionRequest.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst lru_js_1 = require(\"../../utils/lru.js\");\nconst assertRequest_js_1 = require(\"../../utils/transaction/assertRequest.js\");\nconst getChainId_js_1 = require(\"../public/getChainId.js\");\nconst prepareTransactionRequest_js_1 = require(\"./prepareTransactionRequest.js\");\nconst sendRawTransaction_js_1 = require(\"./sendRawTransaction.js\");\nconst supportsWalletNamespace = new lru_js_1.LruMap(128);\nasync function sendTransaction(client, parameters) {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    type,\n    value,\n    ...rest\n  } = parameters;\n  if (typeof account_ === 'undefined') throw new account_js_1.AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : null;\n  try {\n    (0, assertRequest_js_1.assertRequest)(parameters);\n    const to = await (async () => {\n      if (parameters.to) return parameters.to;\n      if (parameters.to === null) return undefined;\n      if (authorizationList && authorizationList.length > 0) return await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({\n        authorization: authorizationList[0]\n      }).catch(() => {\n        throw new base_js_1.BaseError('`to` is required. Could not infer from `authorizationList`.');\n      });\n      return undefined;\n    })();\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId;\n      if (chain !== null) {\n        chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});\n        (0, assertCurrentChain_js_1.assertCurrentChain)({\n          currentChainId: chainId,\n          chain\n        });\n      }\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;\n      const request = format({\n        ...(0, extract_js_1.extract)(rest, {\n          format: chainFormat\n        }),\n        accessList,\n        authorizationList,\n        blobs,\n        chainId,\n        data,\n        from: account?.address,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        type,\n        value\n      });\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\n      const method = isWalletNamespaceSupported ? 'wallet_sendTransaction' : 'eth_sendTransaction';\n      try {\n        return await client.request({\n          method,\n          params: [request]\n        }, {\n          retryCount: 0\n        });\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e;\n        const error = e;\n        if (error.name === 'InvalidInputRpcError' || error.name === 'InvalidParamsRpcError' || error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError') {\n          return await client.request({\n            method: 'wallet_sendTransaction',\n            params: [request]\n          }, {\n            retryCount: 0\n          }).then(hash => {\n            supportsWalletNamespace.set(client.uid, true);\n            return hash;\n          }).catch(e => {\n            const walletNamespaceError = e;\n            if (walletNamespaceError.name === 'MethodNotFoundRpcError' || walletNamespaceError.name === 'MethodNotSupportedRpcError') {\n              supportsWalletNamespace.set(client.uid, false);\n              throw error;\n            }\n            throw walletNamespaceError;\n          });\n        }\n        throw error;\n      }\n    }\n    if (account?.type === 'local') {\n      const request = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, 'prepareTransactionRequest')({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...prepareTransactionRequest_js_1.defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to\n      });\n      const serializer = chain?.serializers?.transaction;\n      const serializedTransaction = await account.signTransaction(request, {\n        serializer\n      });\n      return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, 'sendRawTransaction')({\n        serializedTransaction\n      });\n    }\n    if (account?.type === 'smart') throw new account_js_1.AccountTypeNotSupportedError({\n      metaMessages: ['Consider using the `sendUserOperation` Action instead.'],\n      docsPath: '/docs/actions/bundler/sendUserOperation',\n      type: 'smart'\n    });\n    throw new account_js_1.AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: account?.type\n    });\n  } catch (err) {\n    if (err instanceof account_js_1.AccountTypeNotSupportedError) throw err;\n    throw (0, getTransactionError_js_1.getTransactionError)(err, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined\n    });\n  }\n}","map":{"version":3,"names":["exports","sendTransaction","parseAccount_js_1","require","account_js_1","base_js_1","recoverAuthorizationAddress_js_1","assertCurrentChain_js_1","getTransactionError_js_1","extract_js_1","transactionRequest_js_1","getAction_js_1","lru_js_1","assertRequest_js_1","getChainId_js_1","prepareTransactionRequest_js_1","sendRawTransaction_js_1","supportsWalletNamespace","LruMap","client","parameters","account","account_","chain","accessList","authorizationList","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","type","value","rest","AccountNotFoundError","docsPath","parseAccount","assertRequest","to","undefined","length","recoverAuthorizationAddress","authorization","catch","BaseError","chainId","getAction","getChainId","assertCurrentChain","currentChainId","chainFormat","formatters","transactionRequest","format","formatTransactionRequest","request","extract","from","address","isWalletNamespaceSupported","get","uid","method","params","retryCount","e","error","name","then","hash","set","walletNamespaceError","prepareTransactionRequest","nonceManager","defaultParameters","serializer","serializers","transaction","serializedTransaction","signTransaction","sendRawTransaction","AccountTypeNotSupportedError","metaMessages","err","getTransactionError"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/actions/wallet/sendTransaction.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  defaultParameters,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionErrorType,\n  sendRawTransaction,\n} from './sendRawTransaction.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SendTransactionReturnType = Hash\n\nexport type SendTransactionErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | RequestErrorType\n    >\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0xâ€¦'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format({\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        accessList,\n        authorizationList,\n        blobs,\n        chainId,\n        data,\n        from: account?.address,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        type,\n        value,\n      } as TransactionRequest)\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      try {\n        return await client.request(\n          {\n            method,\n            params: [request],\n          },\n          { retryCount: 0 },\n        )\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e\n\n        const error = e as BaseError\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (\n          error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError'\n        ) {\n          return await client\n            .request(\n              {\n                method: 'wallet_sendTransaction',\n                params: [request],\n              },\n              { retryCount: 0 },\n            )\n            .then((hash) => {\n              supportsWalletNamespace.set(client.uid, true)\n              return hash\n            })\n            .catch((e) => {\n              const walletNamespaceError = e as BaseError\n              if (\n                walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                walletNamespaceError.name === 'MethodNotSupportedRpcError'\n              ) {\n                supportsWalletNamespace.set(client.uid, false)\n                throw error\n              }\n\n              throw walletNamespaceError\n            })\n        }\n\n        throw error\n      }\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return await getAction(\n        client,\n        sendRawTransaction,\n        'sendRawTransaction',\n      )({\n        serializedTransaction,\n      })\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}