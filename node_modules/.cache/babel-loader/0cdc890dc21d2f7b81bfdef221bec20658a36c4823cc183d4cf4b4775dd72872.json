{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar isArray = require('isarray');\nvar typedArrayBuffer = require('typed-array-buffer');\nvar isView = ArrayBuffer.isView || function isView(obj) {\n  try {\n    typedArrayBuffer(obj);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar useUint8Array = typeof Uint8Array !== 'undefined';\nvar useArrayBuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';\nvar useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\nmodule.exports = function toBuffer(data, encoding) {\n  /*\n   * No need to do anything for exact instance\n   * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed\n   */\n  if (data instanceof Buffer) {\n    return data;\n  }\n  if (typeof data === 'string') {\n    return Buffer.from(data, encoding);\n  }\n\n  /*\n   * Wrap any TypedArray instances and DataViews\n   * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n   */\n  if (useArrayBuffer && isView(data)) {\n    // Bug in Node.js <6.3.1, which treats this as out-of-bounds\n    if (data.byteLength === 0) {\n      return Buffer.alloc(0);\n    }\n\n    // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer\n    if (useFromArrayBuffer) {\n      var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n      /*\n       * Recheck result size, as offset/length doesn't work on Node.js <5.10\n       * We just go to Uint8Array case if this fails\n       */\n      if (res.byteLength === data.byteLength) {\n        return res;\n      }\n    }\n\n    // Convert to Uint8Array bytes and then to Buffer\n    var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    var result = Buffer.from(uint8);\n\n    /*\n     * Let's recheck that conversion succeeded\n     * We have .length but not .byteLength when useFromArrayBuffer is false\n     */\n    if (result.length === data.byteLength) {\n      return result;\n    }\n  }\n\n  /*\n   * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n   * Doesn't make sense with other TypedArray instances\n   */\n  if (useUint8Array && data instanceof Uint8Array) {\n    return Buffer.from(data);\n  }\n  var isArr = isArray(data);\n  if (isArr) {\n    for (var i = 0; i < data.length; i += 1) {\n      var x = data[i];\n      if (typeof x !== 'number' || x < 0 || x > 255 || ~~x !== x // NaN and integer check\n      ) {\n        throw new RangeError('Array items must be numbers in the range 0-255.');\n      }\n    }\n  }\n\n  /*\n   * Old Buffer polyfill on an engine that doesn't have TypedArray support\n   * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n   * Convert to our current Buffer implementation\n   */\n  if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === 'function' && data.constructor.isBuffer(data)) {\n    return Buffer.from(data);\n  }\n  throw new TypeError('The \"data\" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');\n};","map":{"version":3,"names":["Buffer","require","isArray","typedArrayBuffer","isView","ArrayBuffer","obj","e","useUint8Array","Uint8Array","useArrayBuffer","useFromArrayBuffer","prototype","TYPED_ARRAY_SUPPORT","module","exports","toBuffer","data","encoding","from","byteLength","alloc","res","buffer","byteOffset","uint8","result","length","isArr","i","x","RangeError","isBuffer","constructor","TypeError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/to-buffer/index.js"],"sourcesContent":["'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar isArray = require('isarray');\nvar typedArrayBuffer = require('typed-array-buffer');\n\nvar isView = ArrayBuffer.isView || function isView(obj) {\n\ttry {\n\t\ttypedArrayBuffer(obj);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar useUint8Array = typeof Uint8Array !== 'undefined';\nvar useArrayBuffer = typeof ArrayBuffer !== 'undefined'\n\t&& typeof Uint8Array !== 'undefined';\nvar useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\n\nmodule.exports = function toBuffer(data, encoding) {\n\t/*\n\t * No need to do anything for exact instance\n\t * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed\n\t */\n\tif (data instanceof Buffer) {\n\t\treturn data;\n\t}\n\n\tif (typeof data === 'string') {\n\t\treturn Buffer.from(data, encoding);\n\t}\n\n\t/*\n\t * Wrap any TypedArray instances and DataViews\n\t * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n\t */\n\tif (useArrayBuffer && isView(data)) {\n\t\t// Bug in Node.js <6.3.1, which treats this as out-of-bounds\n\t\tif (data.byteLength === 0) {\n\t\t\treturn Buffer.alloc(0);\n\t\t}\n\n\t\t// When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer\n\t\tif (useFromArrayBuffer) {\n\t\t\tvar res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n\t\t\t/*\n\t\t\t * Recheck result size, as offset/length doesn't work on Node.js <5.10\n\t\t\t * We just go to Uint8Array case if this fails\n\t\t\t */\n\t\t\tif (res.byteLength === data.byteLength) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t// Convert to Uint8Array bytes and then to Buffer\n\t\tvar uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n\t\tvar result = Buffer.from(uint8);\n\n\t\t/*\n\t\t * Let's recheck that conversion succeeded\n\t\t * We have .length but not .byteLength when useFromArrayBuffer is false\n\t\t */\n\t\tif (result.length === data.byteLength) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/*\n\t * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n\t * Doesn't make sense with other TypedArray instances\n\t */\n\tif (useUint8Array && data instanceof Uint8Array) {\n\t\treturn Buffer.from(data);\n\t}\n\n\tvar isArr = isArray(data);\n\tif (isArr) {\n\t\tfor (var i = 0; i < data.length; i += 1) {\n\t\t\tvar x = data[i];\n\t\t\tif (\n\t\t\t\ttypeof x !== 'number'\n\t\t\t\t|| x < 0\n\t\t\t\t|| x > 255\n\t\t\t\t|| ~~x !== x // NaN and integer check\n\t\t\t) {\n\t\t\t\tthrow new RangeError('Array items must be numbers in the range 0-255.');\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Old Buffer polyfill on an engine that doesn't have TypedArray support\n\t * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n\t * Convert to our current Buffer implementation\n\t */\n\tif (\n\t\tisArr || (\n\t\t\tBuffer.isBuffer(data)\n\t\t\t\t&& data.constructor\n\t\t\t\t&& typeof data.constructor.isBuffer === 'function'\n\t\t\t\t&& data.constructor.isBuffer(data)\n\t\t)\n\t) {\n\t\treturn Buffer.from(data);\n\t}\n\n\tthrow new TypeError('The \"data\" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}