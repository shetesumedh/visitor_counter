{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSignature = parseSignature;\nexports.parseFunctionSignature = parseFunctionSignature;\nexports.parseEventSignature = parseEventSignature;\nexports.parseErrorSignature = parseErrorSignature;\nexports.parseConstructorSignature = parseConstructorSignature;\nexports.parseFallbackSignature = parseFallbackSignature;\nexports.parseAbiParameter = parseAbiParameter;\nexports.splitParameters = splitParameters;\nexports.isSolidityType = isSolidityType;\nexports.isSolidityKeyword = isSolidityKeyword;\nexports.isValidDataLocation = isValidDataLocation;\nconst regex_js_1 = require(\"../../regex.js\");\nconst abiItem_js_1 = require(\"../errors/abiItem.js\");\nconst abiParameter_js_1 = require(\"../errors/abiParameter.js\");\nconst signature_js_1 = require(\"../errors/signature.js\");\nconst splitParameters_js_1 = require(\"../errors/splitParameters.js\");\nconst cache_js_1 = require(\"./cache.js\");\nconst signatures_js_1 = require(\"./signatures.js\");\nfunction parseSignature(signature, structs = {}) {\n  if ((0, signatures_js_1.isFunctionSignature)(signature)) return parseFunctionSignature(signature, structs);\n  if ((0, signatures_js_1.isEventSignature)(signature)) return parseEventSignature(signature, structs);\n  if ((0, signatures_js_1.isErrorSignature)(signature)) return parseErrorSignature(signature, structs);\n  if ((0, signatures_js_1.isConstructorSignature)(signature)) return parseConstructorSignature(signature, structs);\n  if ((0, signatures_js_1.isFallbackSignature)(signature)) return parseFallbackSignature(signature);\n  if ((0, signatures_js_1.isReceiveSignature)(signature)) return {\n    type: 'receive',\n    stateMutability: 'payable'\n  };\n  throw new signature_js_1.UnknownSignatureError({\n    signature\n  });\n}\nfunction parseFunctionSignature(signature, structs = {}) {\n  const match = (0, signatures_js_1.execFunctionSignature)(signature);\n  if (!match) throw new signature_js_1.InvalidSignatureError({\n    signature,\n    type: 'function'\n  });\n  const inputParams = splitParameters(match.parameters);\n  const inputs = [];\n  const inputLength = inputParams.length;\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(parseAbiParameter(inputParams[i], {\n      modifiers: signatures_js_1.functionModifiers,\n      structs,\n      type: 'function'\n    }));\n  }\n  const outputs = [];\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns);\n    const outputLength = outputParams.length;\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(parseAbiParameter(outputParams[i], {\n        modifiers: signatures_js_1.functionModifiers,\n        structs,\n        type: 'function'\n      }));\n    }\n  }\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs\n  };\n}\nfunction parseEventSignature(signature, structs = {}) {\n  const match = (0, signatures_js_1.execEventSignature)(signature);\n  if (!match) throw new signature_js_1.InvalidSignatureError({\n    signature,\n    type: 'event'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    modifiers: signatures_js_1.eventModifiers,\n    structs,\n    type: 'event'\n  }));\n  return {\n    name: match.name,\n    type: 'event',\n    inputs: abiParameters\n  };\n}\nfunction parseErrorSignature(signature, structs = {}) {\n  const match = (0, signatures_js_1.execErrorSignature)(signature);\n  if (!match) throw new signature_js_1.InvalidSignatureError({\n    signature,\n    type: 'error'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'error'\n  }));\n  return {\n    name: match.name,\n    type: 'error',\n    inputs: abiParameters\n  };\n}\nfunction parseConstructorSignature(signature, structs = {}) {\n  const match = (0, signatures_js_1.execConstructorSignature)(signature);\n  if (!match) throw new signature_js_1.InvalidSignatureError({\n    signature,\n    type: 'constructor'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'constructor'\n  }));\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters\n  };\n}\nfunction parseFallbackSignature(signature) {\n  const match = (0, signatures_js_1.execFallbackSignature)(signature);\n  if (!match) throw new signature_js_1.InvalidSignatureError({\n    signature,\n    type: 'fallback'\n  });\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable'\n  };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type, options?.structs);\n  if (cache_js_1.parameterCache.has(parameterCacheKey)) return cache_js_1.parameterCache.get(parameterCacheKey);\n  const isTuple = regex_js_1.isTupleRegex.test(param);\n  const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new abiParameter_js_1.InvalidParameterError({\n    param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new abiParameter_js_1.SolidityProtectedKeywordError({\n    param,\n    name: match.name\n  });\n  const name = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === 'indexed' ? {\n    indexed: true\n  } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = 'tuple';\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = 'tuple';\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === 'struct') && !isSolidityType(type)) throw new abiItem_js_1.UnknownSolidityTypeError({\n      type\n    });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier)) throw new abiParameter_js_1.InvalidModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n    if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new abiParameter_js_1.InvalidFunctionModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components\n  };\n  cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = '', depth = 0) {\n  const length = params.trim().length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case ',':\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  if (current === '') return result;\n  if (depth !== 0) throw new splitParameters_js_1.InvalidParenthesisError({\n    current,\n    depth\n  });\n  result.push(current.trim());\n  return result;\n}\nfunction isSolidityType(type) {\n  return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name) {\n  return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}","map":{"version":3,"names":["exports","parseSignature","parseFunctionSignature","parseEventSignature","parseErrorSignature","parseConstructorSignature","parseFallbackSignature","parseAbiParameter","splitParameters","isSolidityType","isSolidityKeyword","isValidDataLocation","regex_js_1","require","abiItem_js_1","abiParameter_js_1","signature_js_1","splitParameters_js_1","cache_js_1","signatures_js_1","signature","structs","isFunctionSignature","isEventSignature","isErrorSignature","isConstructorSignature","isFallbackSignature","isReceiveSignature","type","stateMutability","UnknownSignatureError","match","execFunctionSignature","InvalidSignatureError","inputParams","parameters","inputs","inputLength","length","i","push","modifiers","functionModifiers","outputs","returns","outputParams","outputLength","name","execEventSignature","params","abiParameters","eventModifiers","execErrorSignature","execConstructorSignature","execFallbackSignature","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","param","options","parameterCacheKey","getParameterCacheKey","parameterCache","has","get","isTuple","isTupleRegex","test","execTyped","InvalidParameterError","SolidityProtectedKeywordError","indexed","modifier","components","components_","UnknownSolidityTypeError","InvalidModifierError","array","InvalidFunctionModifierError","abiParameter","set","result","current","depth","trim","char","tail","slice","InvalidParenthesisError","bytesRegex","integerRegex","protectedKeywordsRegex","isArray"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/abitype/src/human-readable/runtime/utils.ts"],"sourcesContent":["import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFallbackSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature))\n    return parseFunctionSignature(signature, structs)\n\n  if (isEventSignature(signature))\n    return parseEventSignature(signature, structs)\n\n  if (isErrorSignature(signature))\n    return parseErrorSignature(signature, structs)\n\n  if (isConstructorSignature(signature))\n    return parseConstructorSignature(signature, structs)\n\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\n\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nexport function parseFunctionSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execFunctionSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n  const inputParams = splitParameters(match.parameters)\n  const inputs = []\n  const inputLength = inputParams.length\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(\n      parseAbiParameter(inputParams[i]!, {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function',\n      }),\n    )\n  }\n\n  const outputs = []\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns)\n    const outputLength = outputParams.length\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(\n        parseAbiParameter(outputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n  }\n\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs,\n  }\n}\n\nexport function parseEventSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execEventSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, {\n        modifiers: eventModifiers,\n        structs,\n        type: 'event',\n      }),\n    )\n  return { name: match.name, type: 'event', inputs: abiParameters }\n}\n\nexport function parseErrorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execErrorSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\n    )\n  return { name: match.name, type: 'error', inputs: abiParameters }\n}\n\nexport function parseConstructorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execConstructorSignature(signature)\n  if (!match)\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n    )\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters,\n  }\n}\n\nexport function parseFallbackSignature(signature: string) {\n  const match = execFallbackSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\n\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n  }\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}