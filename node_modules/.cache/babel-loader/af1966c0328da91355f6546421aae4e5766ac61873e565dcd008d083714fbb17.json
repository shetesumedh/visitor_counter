{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\nconst type_1 = require(\"../../../core/type\");\nconst Cipher_1 = require(\"../../../lib/Cipher\");\nconst DiagnosticLogger_1 = require(\"../../../provider/DiagnosticLogger\");\nconst RelayAbstract_1 = require(\"../../RelayAbstract\");\nconst Session_1 = require(\"../../Session\");\nconst WalletLinkHTTP_1 = require(\"./WalletLinkHTTP\");\nconst WalletLinkWebSocket_1 = require(\"./WalletLinkWebSocket\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param session Session\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param listener WalletLinkConnectionUpdateListener\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor({\n    session,\n    linkAPIUrl,\n    listener,\n    diagnostic,\n    WebSocketClass = WebSocket\n  }) {\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, type_1.IntNumber)(1);\n    /**\n     * true if connected and authenticated, else false\n     * runs listener when connected status changes\n     */\n    this._connected = false;\n    /**\n     * true if linked (a guest has joined before)\n     * runs listener when linked status changes\n     */\n    this._linked = false;\n    this.shouldFetchUnseenEventsOnConnect = false;\n    this.requestResolutions = new Map();\n    this.handleSessionMetadataUpdated = metadata => {\n      if (!metadata) return;\n      // Map of metadata key to handler function\n      const handlers = new Map([['__destroyed', this.handleDestroyed], ['EthereumAddress', this.handleAccountUpdated], ['WalletUsername', this.handleWalletUsernameUpdated], ['AppVersion', this.handleAppVersionUpdated], ['ChainId', v => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl)]]);\n      // call handler for each metadata key if value is defined\n      handlers.forEach((handler, key) => {\n        const value = metadata[key];\n        if (value === undefined) return;\n        handler(value);\n      });\n    };\n    this.handleDestroyed = __destroyed => {\n      var _a, _b;\n      if (__destroyed !== '1') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n      (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {\n        alreadyDestroyed: this.isDestroyed,\n        sessionIdHash: Session_1.Session.hash(this.session.id)\n      });\n    };\n    this.handleAccountUpdated = async encryptedEthereumAddress => {\n      var _a, _b;\n      try {\n        const address = await this.cipher.decrypt(encryptedEthereumAddress);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n      } catch (_c) {\n        (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: 'Had error decrypting',\n          value: 'selectedAddress'\n        });\n      }\n    };\n    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n      var _a, _b;\n      try {\n        const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n      } catch (_c) {\n        (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: 'Had error decrypting',\n          value: key\n        });\n      }\n    };\n    this.handleWalletUsernameUpdated = async walletUsername => {\n      this.handleMetadataUpdated(RelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n    };\n    this.handleAppVersionUpdated = async appVersion => {\n      this.handleMetadataUpdated(RelayAbstract_1.APP_VERSION_KEY, appVersion);\n    };\n    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n      var _a, _b;\n      try {\n        const chainId = await this.cipher.decrypt(encryptedChainId);\n        const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n      } catch (_c) {\n        (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: 'Had error decrypting',\n          value: 'chainId|jsonRpcUrl'\n        });\n      }\n    };\n    this.session = session;\n    this.cipher = new Cipher_1.Cipher(session.secret);\n    this.diagnostic = diagnostic;\n    this.listener = listener;\n    const ws = new WalletLinkWebSocket_1.WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocketClass);\n    ws.setConnectionStateListener(async state => {\n      var _a;\n      // attempt to reconnect every 5 seconds when disconnected\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state,\n        sessionIdHash: Session_1.Session.hash(session.id)\n      });\n      let connected = false;\n      switch (state) {\n        case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:\n          // if DISCONNECTED and not destroyed\n          if (!this.destroyed) {\n            const connect = async () => {\n              // wait 5 seconds\n              await new Promise(resolve => setTimeout(resolve, 5000));\n              // check whether it's destroyed again\n              if (!this.destroyed) {\n                // reconnect\n                ws.connect().catch(() => {\n                  connect();\n                });\n              }\n            };\n            connect();\n          }\n          break;\n        case WalletLinkWebSocket_1.ConnectionState.CONNECTED:\n          // perform authentication upon connection\n          try {\n            // if CONNECTED, authenticate, and then check link status\n            await this.authenticate();\n            this.sendIsLinked();\n            this.sendGetSessionConfig();\n            connected = true;\n          } catch (_b) {\n            /* empty */\n          }\n          // send heartbeat every n seconds while connected\n          // if CONNECTED, start the heartbeat timer\n          // first timer event updates lastHeartbeat timestamp\n          // subsequent calls send heartbeat message\n          this.updateLastHeartbeat();\n          setInterval(() => {\n            this.heartbeat();\n          }, HEARTBEAT_INTERVAL);\n          // check for unseen events\n          if (this.shouldFetchUnseenEventsOnConnect) {\n            this.fetchUnseenEventsAPI();\n          }\n          break;\n        case WalletLinkWebSocket_1.ConnectionState.CONNECTING:\n          break;\n      }\n      // distinctUntilChanged\n      if (this.connected !== connected) {\n        this.connected = connected;\n      }\n    });\n    ws.setIncomingDataListener(m => {\n      var _a, _b, _c;\n      switch (m.type) {\n        // handle server's heartbeat responses\n        case 'Heartbeat':\n          this.updateLastHeartbeat();\n          return;\n        // handle link status updates\n        case 'IsLinkedOK':\n        case 'Linked':\n          {\n            const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n              sessionIdHash: Session_1.Session.hash(session.id),\n              linked,\n              type: m.type,\n              onlineGuests: m.onlineGuests\n            });\n            this.linked = linked || m.onlineGuests > 0;\n            break;\n          }\n        // handle session config updates\n        case 'GetSessionConfigOK':\n        case 'SessionConfigUpdated':\n          {\n            (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n              sessionIdHash: Session_1.Session.hash(session.id),\n              metadata_keys: m && m.metadata ? Object.keys(m.metadata) : undefined\n            });\n            this.handleSessionMetadataUpdated(m.metadata);\n            break;\n          }\n        case 'Event':\n          {\n            this.handleIncomingEvent(m);\n            break;\n          }\n      }\n      // resolve request promises\n      if (m.id !== undefined) {\n        (_c = this.requestResolutions.get(m.id)) === null || _c === void 0 ? void 0 : _c(m);\n      }\n    });\n    this.ws = ws;\n    this.http = new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    var _a;\n    if (this.destroyed) {\n      throw new Error('instance is destroyed');\n    }\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.session.id)\n    });\n    this.ws.connect();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  destroy() {\n    var _a;\n    this.destroyed = true;\n    this.ws.disconnect();\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.session.id)\n    });\n    this.listener = undefined;\n  }\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  get connected() {\n    return this._connected;\n  }\n  set connected(connected) {\n    var _a, _b;\n    this._connected = connected;\n    if (connected) (_a = this.onceConnected) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.connectedUpdated(connected);\n  }\n  setOnceConnected(callback) {\n    return new Promise(resolve => {\n      if (this.connected) {\n        callback().then(resolve);\n      } else {\n        this.onceConnected = () => {\n          callback().then(resolve);\n          this.onceConnected = undefined;\n        };\n      }\n    });\n  }\n  get linked() {\n    return this._linked;\n  }\n  set linked(linked) {\n    var _a, _b;\n    this._linked = linked;\n    if (linked) (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n  }\n  setOnceLinked(callback) {\n    return new Promise(resolve => {\n      if (this.linked) {\n        callback().then(resolve);\n      } else {\n        this.onceLinked = () => {\n          callback().then(resolve);\n          this.onceLinked = undefined;\n        };\n      }\n    });\n  }\n  async handleIncomingEvent(m) {\n    var _a, _b;\n    if (m.type !== 'Event' || m.event !== 'Web3Response') {\n      return;\n    }\n    try {\n      const decryptedData = await this.cipher.decrypt(m.data);\n      const message = JSON.parse(decryptedData);\n      if (message.type !== 'WEB3_RESPONSE') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message);\n    } catch (_c) {\n      (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n        message: 'Had error decrypting',\n        value: 'incomingEvent'\n      });\n    }\n  }\n  async checkUnseenEvents() {\n    if (!this.connected) {\n      this.shouldFetchUnseenEventsOnConnect = true;\n      return;\n    }\n    await new Promise(resolve => setTimeout(resolve, 250));\n    try {\n      await this.fetchUnseenEventsAPI();\n    } catch (e) {\n      console.error('Unable to check for unseen events', e);\n    }\n  }\n  async fetchUnseenEventsAPI() {\n    this.shouldFetchUnseenEventsOnConnect = false;\n    const responseEvents = await this.http.fetchUnseenEvents();\n    responseEvents.forEach(e => this.handleIncomingEvent(e));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns a Promise that completes when successful\n   */\n  async setSessionMetadata(key, value) {\n    const message = {\n      type: 'SetSessionConfig',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      metadata: {\n        [key]: value\n      }\n    };\n    return this.setOnceConnected(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to set session metadata');\n      }\n    });\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param unencryptedData unencrypted event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns a Promise that emits event ID when successful\n   */\n  async publishEvent(event, unencryptedData, callWebhook = false) {\n    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), {\n      origin: location.origin,\n      relaySource: window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk'\n    })));\n    const message = {\n      type: 'PublishEvent',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      event,\n      data,\n      callWebhook\n    };\n    return this.setOnceLinked(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to publish event');\n      }\n      return res.eventId;\n    });\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData('h');\n    } catch (_a) {\n      // noop\n    }\n  }\n  async makeRequest(message, timeout = REQUEST_TIMEOUT) {\n    const reqId = message.id;\n    this.sendData(message);\n    // await server message with corresponding id\n    let timeoutId;\n    return Promise.race([new Promise((_, reject) => {\n      timeoutId = window.setTimeout(() => {\n        reject(new Error(`request ${reqId} timed out`));\n      }, timeout);\n    }), new Promise(resolve => {\n      this.requestResolutions.set(reqId, m => {\n        clearTimeout(timeoutId); // clear the timeout\n        resolve(m);\n        this.requestResolutions.delete(reqId);\n      });\n    })]);\n  }\n  async authenticate() {\n    const m = {\n      type: 'HostSession',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      sessionKey: this.session.key\n    };\n    const res = await this.makeRequest(m);\n    if (res.type === 'Fail') {\n      throw new Error(res.error || 'failed to authentcate');\n    }\n  }\n  sendIsLinked() {\n    const m = {\n      type: 'IsLinked',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id\n    };\n    this.sendData(m);\n  }\n  sendGetSessionConfig() {\n    const m = {\n      type: 'GetSessionConfig',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id\n    };\n    this.sendData(m);\n  }\n}\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletLinkConnection","type_1","require","Cipher_1","DiagnosticLogger_1","RelayAbstract_1","Session_1","WalletLinkHTTP_1","WalletLinkWebSocket_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","session","linkAPIUrl","listener","diagnostic","WebSocketClass","WebSocket","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","_connected","_linked","shouldFetchUnseenEventsOnConnect","requestResolutions","Map","handleSessionMetadataUpdated","metadata","handlers","handleDestroyed","handleAccountUpdated","handleWalletUsernameUpdated","handleAppVersionUpdated","v","JsonRpcUrl","handleChainUpdated","forEach","handler","key","undefined","__destroyed","_a","_b","resetAndReload","log","EVENTS","METADATA_DESTROYED","alreadyDestroyed","isDestroyed","sessionIdHash","Session","hash","id","encryptedEthereumAddress","address","cipher","decrypt","accountUpdated","_c","GENERAL_ERROR","message","handleMetadataUpdated","encryptedMetadataValue","decryptedValue","metadataUpdated","walletUsername","WALLET_USER_NAME_KEY","appVersion","APP_VERSION_KEY","encryptedChainId","encryptedJsonRpcUrl","chainId","jsonRpcUrl","chainUpdated","Cipher","secret","ws","WalletLinkWebSocket","setConnectionStateListener","state","CONNECTED_STATE_CHANGE","connected","ConnectionState","DISCONNECTED","connect","Promise","resolve","setTimeout","catch","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","updateLastHeartbeat","setInterval","heartbeat","fetchUnseenEventsAPI","CONNECTING","setIncomingDataListener","m","type","linked","LINKED","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","keys","handleIncomingEvent","get","http","WalletLinkHTTP","Error","STARTED_CONNECTING","destroy","disconnect","onceConnected","call","connectedUpdated","setOnceConnected","callback","then","onceLinked","linkedUpdated","setOnceLinked","event","decryptedData","data","JSON","parse","handleWeb3ResponseMessage","checkUnseenEvents","e","console","error","responseEvents","fetchUnseenEvents","setSessionMetadata","sessionId","res","makeRequest","publishEvent","unencryptedData","callWebhook","encrypt","stringify","assign","origin","location","relaySource","window","coinbaseWalletExtension","eventId","sendData","Date","now","timeout","reqId","timeoutId","race","_","reject","set","clearTimeout","delete","sessionKey"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/cbw-sdk/dist/relay/walletlink/connection/WalletLinkConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletLinkConnection = void 0;\nconst type_1 = require(\"../../../core/type\");\nconst Cipher_1 = require(\"../../../lib/Cipher\");\nconst DiagnosticLogger_1 = require(\"../../../provider/DiagnosticLogger\");\nconst RelayAbstract_1 = require(\"../../RelayAbstract\");\nconst Session_1 = require(\"../../Session\");\nconst WalletLinkHTTP_1 = require(\"./WalletLinkHTTP\");\nconst WalletLinkWebSocket_1 = require(\"./WalletLinkWebSocket\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletLinkConnection {\n    /**\n     * Constructor\n     * @param session Session\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param listener WalletLinkConnectionUpdateListener\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor({ session, linkAPIUrl, listener, diagnostic, WebSocketClass = WebSocket, }) {\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, type_1.IntNumber)(1);\n        /**\n         * true if connected and authenticated, else false\n         * runs listener when connected status changes\n         */\n        this._connected = false;\n        /**\n         * true if linked (a guest has joined before)\n         * runs listener when linked status changes\n         */\n        this._linked = false;\n        this.shouldFetchUnseenEventsOnConnect = false;\n        this.requestResolutions = new Map();\n        this.handleSessionMetadataUpdated = (metadata) => {\n            if (!metadata)\n                return;\n            // Map of metadata key to handler function\n            const handlers = new Map([\n                ['__destroyed', this.handleDestroyed],\n                ['EthereumAddress', this.handleAccountUpdated],\n                ['WalletUsername', this.handleWalletUsernameUpdated],\n                ['AppVersion', this.handleAppVersionUpdated],\n                [\n                    'ChainId',\n                    (v) => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl),\n                ],\n            ]);\n            // call handler for each metadata key if value is defined\n            handlers.forEach((handler, key) => {\n                const value = metadata[key];\n                if (value === undefined)\n                    return;\n                handler(value);\n            });\n        };\n        this.handleDestroyed = (__destroyed) => {\n            var _a, _b;\n            if (__destroyed !== '1')\n                return;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n            (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {\n                alreadyDestroyed: this.isDestroyed,\n                sessionIdHash: Session_1.Session.hash(this.session.id),\n            });\n        };\n        this.handleAccountUpdated = async (encryptedEthereumAddress) => {\n            var _a, _b;\n            try {\n                const address = await this.cipher.decrypt(encryptedEthereumAddress);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n            }\n            catch (_c) {\n                (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n                    message: 'Had error decrypting',\n                    value: 'selectedAddress',\n                });\n            }\n        };\n        this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n            var _a, _b;\n            try {\n                const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n            }\n            catch (_c) {\n                (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n                    message: 'Had error decrypting',\n                    value: key,\n                });\n            }\n        };\n        this.handleWalletUsernameUpdated = async (walletUsername) => {\n            this.handleMetadataUpdated(RelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n        };\n        this.handleAppVersionUpdated = async (appVersion) => {\n            this.handleMetadataUpdated(RelayAbstract_1.APP_VERSION_KEY, appVersion);\n        };\n        this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n            var _a, _b;\n            try {\n                const chainId = await this.cipher.decrypt(encryptedChainId);\n                const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n            }\n            catch (_c) {\n                (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n                    message: 'Had error decrypting',\n                    value: 'chainId|jsonRpcUrl',\n                });\n            }\n        };\n        this.session = session;\n        this.cipher = new Cipher_1.Cipher(session.secret);\n        this.diagnostic = diagnostic;\n        this.listener = listener;\n        const ws = new WalletLinkWebSocket_1.WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocketClass);\n        ws.setConnectionStateListener(async (state) => {\n            var _a;\n            // attempt to reconnect every 5 seconds when disconnected\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n                state,\n                sessionIdHash: Session_1.Session.hash(session.id),\n            });\n            let connected = false;\n            switch (state) {\n                case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:\n                    // if DISCONNECTED and not destroyed\n                    if (!this.destroyed) {\n                        const connect = async () => {\n                            // wait 5 seconds\n                            await new Promise((resolve) => setTimeout(resolve, 5000));\n                            // check whether it's destroyed again\n                            if (!this.destroyed) {\n                                // reconnect\n                                ws.connect().catch(() => {\n                                    connect();\n                                });\n                            }\n                        };\n                        connect();\n                    }\n                    break;\n                case WalletLinkWebSocket_1.ConnectionState.CONNECTED:\n                    // perform authentication upon connection\n                    try {\n                        // if CONNECTED, authenticate, and then check link status\n                        await this.authenticate();\n                        this.sendIsLinked();\n                        this.sendGetSessionConfig();\n                        connected = true;\n                    }\n                    catch (_b) {\n                        /* empty */\n                    }\n                    // send heartbeat every n seconds while connected\n                    // if CONNECTED, start the heartbeat timer\n                    // first timer event updates lastHeartbeat timestamp\n                    // subsequent calls send heartbeat message\n                    this.updateLastHeartbeat();\n                    setInterval(() => {\n                        this.heartbeat();\n                    }, HEARTBEAT_INTERVAL);\n                    // check for unseen events\n                    if (this.shouldFetchUnseenEventsOnConnect) {\n                        this.fetchUnseenEventsAPI();\n                    }\n                    break;\n                case WalletLinkWebSocket_1.ConnectionState.CONNECTING:\n                    break;\n            }\n            // distinctUntilChanged\n            if (this.connected !== connected) {\n                this.connected = connected;\n            }\n        });\n        ws.setIncomingDataListener((m) => {\n            var _a, _b, _c;\n            switch (m.type) {\n                // handle server's heartbeat responses\n                case 'Heartbeat':\n                    this.updateLastHeartbeat();\n                    return;\n                // handle link status updates\n                case 'IsLinkedOK':\n                case 'Linked': {\n                    const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n                    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n                        sessionIdHash: Session_1.Session.hash(session.id),\n                        linked,\n                        type: m.type,\n                        onlineGuests: m.onlineGuests,\n                    });\n                    this.linked = linked || m.onlineGuests > 0;\n                    break;\n                }\n                // handle session config updates\n                case 'GetSessionConfigOK':\n                case 'SessionConfigUpdated': {\n                    (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                        sessionIdHash: Session_1.Session.hash(session.id),\n                        metadata_keys: m && m.metadata ? Object.keys(m.metadata) : undefined,\n                    });\n                    this.handleSessionMetadataUpdated(m.metadata);\n                    break;\n                }\n                case 'Event': {\n                    this.handleIncomingEvent(m);\n                    break;\n                }\n            }\n            // resolve request promises\n            if (m.id !== undefined) {\n                (_c = this.requestResolutions.get(m.id)) === null || _c === void 0 ? void 0 : _c(m);\n            }\n        });\n        this.ws = ws;\n        this.http = new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        var _a;\n        if (this.destroyed) {\n            throw new Error('instance is destroyed');\n        }\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.session.id),\n        });\n        this.ws.connect();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        var _a;\n        this.destroyed = true;\n        this.ws.disconnect();\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.session.id),\n        });\n        this.listener = undefined;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    get connected() {\n        return this._connected;\n    }\n    set connected(connected) {\n        var _a, _b;\n        this._connected = connected;\n        if (connected)\n            (_a = this.onceConnected) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this.listener) === null || _b === void 0 ? void 0 : _b.connectedUpdated(connected);\n    }\n    setOnceConnected(callback) {\n        return new Promise((resolve) => {\n            if (this.connected) {\n                callback().then(resolve);\n            }\n            else {\n                this.onceConnected = () => {\n                    callback().then(resolve);\n                    this.onceConnected = undefined;\n                };\n            }\n        });\n    }\n    get linked() {\n        return this._linked;\n    }\n    set linked(linked) {\n        var _a, _b;\n        this._linked = linked;\n        if (linked)\n            (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n    }\n    setOnceLinked(callback) {\n        return new Promise((resolve) => {\n            if (this.linked) {\n                callback().then(resolve);\n            }\n            else {\n                this.onceLinked = () => {\n                    callback().then(resolve);\n                    this.onceLinked = undefined;\n                };\n            }\n        });\n    }\n    async handleIncomingEvent(m) {\n        var _a, _b;\n        if (m.type !== 'Event' || m.event !== 'Web3Response') {\n            return;\n        }\n        try {\n            const decryptedData = await this.cipher.decrypt(m.data);\n            const message = JSON.parse(decryptedData);\n            if (message.type !== 'WEB3_RESPONSE')\n                return;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message);\n        }\n        catch (_c) {\n            (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n                message: 'Had error decrypting',\n                value: 'incomingEvent',\n            });\n        }\n    }\n    async checkUnseenEvents() {\n        if (!this.connected) {\n            this.shouldFetchUnseenEventsOnConnect = true;\n            return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 250));\n        try {\n            await this.fetchUnseenEventsAPI();\n        }\n        catch (e) {\n            console.error('Unable to check for unseen events', e);\n        }\n    }\n    async fetchUnseenEventsAPI() {\n        this.shouldFetchUnseenEventsOnConnect = false;\n        const responseEvents = await this.http.fetchUnseenEvents();\n        responseEvents.forEach((e) => this.handleIncomingEvent(e));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns a Promise that completes when successful\n     */\n    async setSessionMetadata(key, value) {\n        const message = {\n            type: 'SetSessionConfig',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            metadata: { [key]: value },\n        };\n        return this.setOnceConnected(async () => {\n            const res = await this.makeRequest(message);\n            if (res.type === 'Fail') {\n                throw new Error(res.error || 'failed to set session metadata');\n            }\n        });\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param unencryptedData unencrypted event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns a Promise that emits event ID when successful\n     */\n    async publishEvent(event, unencryptedData, callWebhook = false) {\n        const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, relaySource: window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk' })));\n        const message = {\n            type: 'PublishEvent',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            event,\n            data,\n            callWebhook,\n        };\n        return this.setOnceLinked(async () => {\n            const res = await this.makeRequest(message);\n            if (res.type === 'Fail') {\n                throw new Error(res.error || 'failed to publish event');\n            }\n            return res.eventId;\n        });\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData('h');\n        }\n        catch (_a) {\n            // noop\n        }\n    }\n    async makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        this.sendData(message);\n        // await server message with corresponding id\n        let timeoutId;\n        return Promise.race([\n            new Promise((_, reject) => {\n                timeoutId = window.setTimeout(() => {\n                    reject(new Error(`request ${reqId} timed out`));\n                }, timeout);\n            }),\n            new Promise((resolve) => {\n                this.requestResolutions.set(reqId, (m) => {\n                    clearTimeout(timeoutId); // clear the timeout\n                    resolve(m);\n                    this.requestResolutions.delete(reqId);\n                });\n            }),\n        ]);\n    }\n    async authenticate() {\n        const m = {\n            type: 'HostSession',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            sessionKey: this.session.key,\n        };\n        const res = await this.makeRequest(m);\n        if (res.type === 'Fail') {\n            throw new Error(res.error || 'failed to authentcate');\n        }\n    }\n    sendIsLinked() {\n        const m = {\n            type: 'IsLinked',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n        };\n        this.sendData(m);\n    }\n    sendGetSessionConfig() {\n        const m = {\n            type: 'GetSessionConfig',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n        };\n        this.sendData(m);\n    }\n}\nexports.WalletLinkConnection = WalletLinkConnection;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAG,KAAK,CAAC;AACrC,MAAMC,MAAM,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC5C,MAAMC,QAAQ,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC/C,MAAME,kBAAkB,GAAGF,OAAO,CAAC,oCAAoC,CAAC;AACxE,MAAMG,eAAe,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AACtD,MAAMI,SAAS,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC1C,MAAMK,gBAAgB,GAAGL,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMM,qBAAqB,GAAGN,OAAO,CAAC,uBAAuB,CAAC;AAC9D,MAAMO,kBAAkB,GAAG,KAAK;AAChC,MAAMC,eAAe,GAAG,KAAK;AAC7B;AACA;AACA;AACA,MAAMV,oBAAoB,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIW,WAAWA,CAAC;IAAEC,OAAO;IAAEC,UAAU;IAAEC,QAAQ;IAAEC,UAAU;IAAEC,cAAc,GAAGC;EAAW,CAAC,EAAE;IACpF,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC,EAAEnB,MAAM,CAACoB,SAAS,EAAE,CAAC,CAAC;IACzC;AACR;AACA;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB;AACR;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,gCAAgC,GAAG,KAAK;IAC7C,IAAI,CAACC,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;IACnC,IAAI,CAACC,4BAA4B,GAAIC,QAAQ,IAAK;MAC9C,IAAI,CAACA,QAAQ,EACT;MACJ;MACA,MAAMC,QAAQ,GAAG,IAAIH,GAAG,CAAC,CACrB,CAAC,aAAa,EAAE,IAAI,CAACI,eAAe,CAAC,EACrC,CAAC,iBAAiB,EAAE,IAAI,CAACC,oBAAoB,CAAC,EAC9C,CAAC,gBAAgB,EAAE,IAAI,CAACC,2BAA2B,CAAC,EACpD,CAAC,YAAY,EAAE,IAAI,CAACC,uBAAuB,CAAC,EAC5C,CACI,SAAS,EACRC,CAAC,IAAKN,QAAQ,CAACO,UAAU,IAAI,IAAI,CAACC,kBAAkB,CAACF,CAAC,EAAEN,QAAQ,CAACO,UAAU,CAAC,CAChF,CACJ,CAAC;MACF;MACAN,QAAQ,CAACQ,OAAO,CAAC,CAACC,OAAO,EAAEC,GAAG,KAAK;QAC/B,MAAMxC,KAAK,GAAG6B,QAAQ,CAACW,GAAG,CAAC;QAC3B,IAAIxC,KAAK,KAAKyC,SAAS,EACnB;QACJF,OAAO,CAACvC,KAAK,CAAC;MAClB,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAAC+B,eAAe,GAAIW,WAAW,IAAK;MACpC,IAAIC,EAAE,EAAEC,EAAE;MACV,IAAIF,WAAW,KAAK,GAAG,EACnB;MACJ,CAACC,EAAE,GAAG,IAAI,CAAC5B,QAAQ,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,cAAc,CAAC,CAAC;MAC7E,CAACD,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACC,kBAAkB,EAAE;QAC7GC,gBAAgB,EAAE,IAAI,CAACC,WAAW;QAClCC,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAAC,IAAI,CAACxC,OAAO,CAACyC,EAAE;MACzD,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAACtB,oBAAoB,GAAG,MAAOuB,wBAAwB,IAAK;MAC5D,IAAIZ,EAAE,EAAEC,EAAE;MACV,IAAI;QACA,MAAMY,OAAO,GAAG,MAAM,IAAI,CAACC,MAAM,CAACC,OAAO,CAACH,wBAAwB,CAAC;QACnE,CAACZ,EAAE,GAAG,IAAI,CAAC5B,QAAQ,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgB,cAAc,CAACH,OAAO,CAAC;MACxF,CAAC,CACD,OAAOI,EAAE,EAAE;QACP,CAAChB,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACc,aAAa,EAAE;UACxGC,OAAO,EAAE,sBAAsB;UAC/B9D,KAAK,EAAE;QACX,CAAC,CAAC;MACN;IACJ,CAAC;IACD,IAAI,CAAC+D,qBAAqB,GAAG,OAAOvB,GAAG,EAAEwB,sBAAsB,KAAK;MAChE,IAAIrB,EAAE,EAAEC,EAAE;MACV,IAAI;QACA,MAAMqB,cAAc,GAAG,MAAM,IAAI,CAACR,MAAM,CAACC,OAAO,CAACM,sBAAsB,CAAC;QACxE,CAACrB,EAAE,GAAG,IAAI,CAAC5B,QAAQ,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACuB,eAAe,CAAC1B,GAAG,EAAEyB,cAAc,CAAC;MACrG,CAAC,CACD,OAAOL,EAAE,EAAE;QACP,CAAChB,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACc,aAAa,EAAE;UACxGC,OAAO,EAAE,sBAAsB;UAC/B9D,KAAK,EAAEwC;QACX,CAAC,CAAC;MACN;IACJ,CAAC;IACD,IAAI,CAACP,2BAA2B,GAAG,MAAOkC,cAAc,IAAK;MACzD,IAAI,CAACJ,qBAAqB,CAACzD,eAAe,CAAC8D,oBAAoB,EAAED,cAAc,CAAC;IACpF,CAAC;IACD,IAAI,CAACjC,uBAAuB,GAAG,MAAOmC,UAAU,IAAK;MACjD,IAAI,CAACN,qBAAqB,CAACzD,eAAe,CAACgE,eAAe,EAAED,UAAU,CAAC;IAC3E,CAAC;IACD,IAAI,CAAChC,kBAAkB,GAAG,OAAOkC,gBAAgB,EAAEC,mBAAmB,KAAK;MACvE,IAAI7B,EAAE,EAAEC,EAAE;MACV,IAAI;QACA,MAAM6B,OAAO,GAAG,MAAM,IAAI,CAAChB,MAAM,CAACC,OAAO,CAACa,gBAAgB,CAAC;QAC3D,MAAMG,UAAU,GAAG,MAAM,IAAI,CAACjB,MAAM,CAACC,OAAO,CAACc,mBAAmB,CAAC;QACjE,CAAC7B,EAAE,GAAG,IAAI,CAAC5B,QAAQ,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgC,YAAY,CAACF,OAAO,EAAEC,UAAU,CAAC;MAClG,CAAC,CACD,OAAOd,EAAE,EAAE;QACP,CAAChB,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACc,aAAa,EAAE;UACxGC,OAAO,EAAE,sBAAsB;UAC/B9D,KAAK,EAAE;QACX,CAAC,CAAC;MACN;IACJ,CAAC;IACD,IAAI,CAACa,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC4C,MAAM,GAAG,IAAIrD,QAAQ,CAACwE,MAAM,CAAC/D,OAAO,CAACgE,MAAM,CAAC;IACjD,IAAI,CAAC7D,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,MAAM+D,EAAE,GAAG,IAAIrE,qBAAqB,CAACsE,mBAAmB,CAAC,GAAGjE,UAAU,MAAM,EAAEG,cAAc,CAAC;IAC7F6D,EAAE,CAACE,0BAA0B,CAAC,MAAOC,KAAK,IAAK;MAC3C,IAAItC,EAAE;MACN;MACA,CAACA,EAAE,GAAG,IAAI,CAAC3B,UAAU,MAAM,IAAI,IAAI2B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACmC,sBAAsB,EAAE;QACjHD,KAAK;QACL9B,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAACxC,OAAO,CAACyC,EAAE;MACpD,CAAC,CAAC;MACF,IAAI6B,SAAS,GAAG,KAAK;MACrB,QAAQF,KAAK;QACT,KAAKxE,qBAAqB,CAAC2E,eAAe,CAACC,YAAY;UACnD;UACA,IAAI,CAAC,IAAI,CAAClE,SAAS,EAAE;YACjB,MAAMmE,OAAO,GAAG,MAAAA,CAAA,KAAY;cACxB;cACA,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;cACzD;cACA,IAAI,CAAC,IAAI,CAACrE,SAAS,EAAE;gBACjB;gBACA2D,EAAE,CAACQ,OAAO,CAAC,CAAC,CAACI,KAAK,CAAC,MAAM;kBACrBJ,OAAO,CAAC,CAAC;gBACb,CAAC,CAAC;cACN;YACJ,CAAC;YACDA,OAAO,CAAC,CAAC;UACb;UACA;QACJ,KAAK7E,qBAAqB,CAAC2E,eAAe,CAACO,SAAS;UAChD;UACA,IAAI;YACA;YACA,MAAM,IAAI,CAACC,YAAY,CAAC,CAAC;YACzB,IAAI,CAACC,YAAY,CAAC,CAAC;YACnB,IAAI,CAACC,oBAAoB,CAAC,CAAC;YAC3BX,SAAS,GAAG,IAAI;UACpB,CAAC,CACD,OAAOvC,EAAE,EAAE;YACP;UAAA;UAEJ;UACA;UACA;UACA;UACA,IAAI,CAACmD,mBAAmB,CAAC,CAAC;UAC1BC,WAAW,CAAC,MAAM;YACd,IAAI,CAACC,SAAS,CAAC,CAAC;UACpB,CAAC,EAAEvF,kBAAkB,CAAC;UACtB;UACA,IAAI,IAAI,CAACe,gCAAgC,EAAE;YACvC,IAAI,CAACyE,oBAAoB,CAAC,CAAC;UAC/B;UACA;QACJ,KAAKzF,qBAAqB,CAAC2E,eAAe,CAACe,UAAU;UACjD;MACR;MACA;MACA,IAAI,IAAI,CAAChB,SAAS,KAAKA,SAAS,EAAE;QAC9B,IAAI,CAACA,SAAS,GAAGA,SAAS;MAC9B;IACJ,CAAC,CAAC;IACFL,EAAE,CAACsB,uBAAuB,CAAEC,CAAC,IAAK;MAC9B,IAAI1D,EAAE,EAAEC,EAAE,EAAEgB,EAAE;MACd,QAAQyC,CAAC,CAACC,IAAI;QACV;QACA,KAAK,WAAW;UACZ,IAAI,CAACP,mBAAmB,CAAC,CAAC;UAC1B;QACJ;QACA,KAAK,YAAY;QACjB,KAAK,QAAQ;UAAE;YACX,MAAMQ,MAAM,GAAGF,CAAC,CAACC,IAAI,KAAK,YAAY,GAAGD,CAAC,CAACE,MAAM,GAAG9D,SAAS;YAC7D,CAACE,EAAE,GAAG,IAAI,CAAC3B,UAAU,MAAM,IAAI,IAAI2B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACyD,MAAM,EAAE;cACjGrD,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAACxC,OAAO,CAACyC,EAAE,CAAC;cACjDiD,MAAM;cACND,IAAI,EAAED,CAAC,CAACC,IAAI;cACZG,YAAY,EAAEJ,CAAC,CAACI;YACpB,CAAC,CAAC;YACF,IAAI,CAACF,MAAM,GAAGA,MAAM,IAAIF,CAAC,CAACI,YAAY,GAAG,CAAC;YAC1C;UACJ;QACA;QACA,KAAK,oBAAoB;QACzB,KAAK,sBAAsB;UAAE;YACzB,CAAC7D,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAAC2D,uBAAuB,EAAE;cAClHvD,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAACxC,OAAO,CAACyC,EAAE,CAAC;cACjDqD,aAAa,EAAEN,CAAC,IAAIA,CAAC,CAACxE,QAAQ,GAAGhC,MAAM,CAAC+G,IAAI,CAACP,CAAC,CAACxE,QAAQ,CAAC,GAAGY;YAC/D,CAAC,CAAC;YACF,IAAI,CAACb,4BAA4B,CAACyE,CAAC,CAACxE,QAAQ,CAAC;YAC7C;UACJ;QACA,KAAK,OAAO;UAAE;YACV,IAAI,CAACgF,mBAAmB,CAACR,CAAC,CAAC;YAC3B;UACJ;MACJ;MACA;MACA,IAAIA,CAAC,CAAC/C,EAAE,KAAKb,SAAS,EAAE;QACpB,CAACmB,EAAE,GAAG,IAAI,CAAClC,kBAAkB,CAACoF,GAAG,CAACT,CAAC,CAAC/C,EAAE,CAAC,MAAM,IAAI,IAAIM,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyC,CAAC,CAAC;MACvF;IACJ,CAAC,CAAC;IACF,IAAI,CAACvB,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACiC,IAAI,GAAG,IAAIvG,gBAAgB,CAACwG,cAAc,CAAClG,UAAU,EAAED,OAAO,CAACyC,EAAE,EAAEzC,OAAO,CAAC2B,GAAG,CAAC;EACxF;EACA;AACJ;AACA;EACI8C,OAAOA,CAAA,EAAG;IACN,IAAI3C,EAAE;IACN,IAAI,IAAI,CAACxB,SAAS,EAAE;MAChB,MAAM,IAAI8F,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA,CAACtE,EAAE,GAAG,IAAI,CAAC3B,UAAU,MAAM,IAAI,IAAI2B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACmE,kBAAkB,EAAE;MAC7G/D,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAAC,IAAI,CAACxC,OAAO,CAACyC,EAAE;IACzD,CAAC,CAAC;IACF,IAAI,CAACwB,EAAE,CAACQ,OAAO,CAAC,CAAC;EACrB;EACA;AACJ;AACA;AACA;EACI6B,OAAOA,CAAA,EAAG;IACN,IAAIxE,EAAE;IACN,IAAI,CAACxB,SAAS,GAAG,IAAI;IACrB,IAAI,CAAC2D,EAAE,CAACsC,UAAU,CAAC,CAAC;IACpB,CAACzE,EAAE,GAAG,IAAI,CAAC3B,UAAU,MAAM,IAAI,IAAI2B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACsC,YAAY,EAAE;MACvGlC,aAAa,EAAE5C,SAAS,CAAC6C,OAAO,CAACC,IAAI,CAAC,IAAI,CAACxC,OAAO,CAACyC,EAAE;IACzD,CAAC,CAAC;IACF,IAAI,CAACvC,QAAQ,GAAG0B,SAAS;EAC7B;EACA,IAAIS,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC/B,SAAS;EACzB;EACA,IAAIgE,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC5D,UAAU;EAC1B;EACA,IAAI4D,SAASA,CAACA,SAAS,EAAE;IACrB,IAAIxC,EAAE,EAAEC,EAAE;IACV,IAAI,CAACrB,UAAU,GAAG4D,SAAS;IAC3B,IAAIA,SAAS,EACT,CAACxC,EAAE,GAAG,IAAI,CAAC0E,aAAa,MAAM,IAAI,IAAI1E,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2E,IAAI,CAAC,IAAI,CAAC;IAChF,CAAC1E,EAAE,GAAG,IAAI,CAAC7B,QAAQ,MAAM,IAAI,IAAI6B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2E,gBAAgB,CAACpC,SAAS,CAAC;EAC5F;EACAqC,gBAAgBA,CAACC,QAAQ,EAAE;IACvB,OAAO,IAAIlC,OAAO,CAAEC,OAAO,IAAK;MAC5B,IAAI,IAAI,CAACL,SAAS,EAAE;QAChBsC,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAClC,OAAO,CAAC;MAC5B,CAAC,MACI;QACD,IAAI,CAAC6B,aAAa,GAAG,MAAM;UACvBI,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAClC,OAAO,CAAC;UACxB,IAAI,CAAC6B,aAAa,GAAG5E,SAAS;QAClC,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EACA,IAAI8D,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC/E,OAAO;EACvB;EACA,IAAI+E,MAAMA,CAACA,MAAM,EAAE;IACf,IAAI5D,EAAE,EAAEC,EAAE;IACV,IAAI,CAACpB,OAAO,GAAG+E,MAAM;IACrB,IAAIA,MAAM,EACN,CAAC5D,EAAE,GAAG,IAAI,CAACgF,UAAU,MAAM,IAAI,IAAIhF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2E,IAAI,CAAC,IAAI,CAAC;IAC7E,CAAC1E,EAAE,GAAG,IAAI,CAAC7B,QAAQ,MAAM,IAAI,IAAI6B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgF,aAAa,CAACrB,MAAM,CAAC;EACtF;EACAsB,aAAaA,CAACJ,QAAQ,EAAE;IACpB,OAAO,IAAIlC,OAAO,CAAEC,OAAO,IAAK;MAC5B,IAAI,IAAI,CAACe,MAAM,EAAE;QACbkB,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAClC,OAAO,CAAC;MAC5B,CAAC,MACI;QACD,IAAI,CAACmC,UAAU,GAAG,MAAM;UACpBF,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAClC,OAAO,CAAC;UACxB,IAAI,CAACmC,UAAU,GAAGlF,SAAS;QAC/B,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EACA,MAAMoE,mBAAmBA,CAACR,CAAC,EAAE;IACzB,IAAI1D,EAAE,EAAEC,EAAE;IACV,IAAIyD,CAAC,CAACC,IAAI,KAAK,OAAO,IAAID,CAAC,CAACyB,KAAK,KAAK,cAAc,EAAE;MAClD;IACJ;IACA,IAAI;MACA,MAAMC,aAAa,GAAG,MAAM,IAAI,CAACtE,MAAM,CAACC,OAAO,CAAC2C,CAAC,CAAC2B,IAAI,CAAC;MACvD,MAAMlE,OAAO,GAAGmE,IAAI,CAACC,KAAK,CAACH,aAAa,CAAC;MACzC,IAAIjE,OAAO,CAACwC,IAAI,KAAK,eAAe,EAChC;MACJ,CAAC3D,EAAE,GAAG,IAAI,CAAC5B,QAAQ,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACwF,yBAAyB,CAACrE,OAAO,CAAC;IACnG,CAAC,CACD,OAAOF,EAAE,EAAE;MACP,CAAChB,EAAE,GAAG,IAAI,CAAC5B,UAAU,MAAM,IAAI,IAAI4B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,GAAG,CAACzC,kBAAkB,CAAC0C,MAAM,CAACc,aAAa,EAAE;QACxGC,OAAO,EAAE,sBAAsB;QAC/B9D,KAAK,EAAE;MACX,CAAC,CAAC;IACN;EACJ;EACA,MAAMoI,iBAAiBA,CAAA,EAAG;IACtB,IAAI,CAAC,IAAI,CAACjD,SAAS,EAAE;MACjB,IAAI,CAAC1D,gCAAgC,GAAG,IAAI;MAC5C;IACJ;IACA,MAAM,IAAI8D,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IACxD,IAAI;MACA,MAAM,IAAI,CAACU,oBAAoB,CAAC,CAAC;IACrC,CAAC,CACD,OAAOmC,CAAC,EAAE;MACNC,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEF,CAAC,CAAC;IACzD;EACJ;EACA,MAAMnC,oBAAoBA,CAAA,EAAG;IACzB,IAAI,CAACzE,gCAAgC,GAAG,KAAK;IAC7C,MAAM+G,cAAc,GAAG,MAAM,IAAI,CAACzB,IAAI,CAAC0B,iBAAiB,CAAC,CAAC;IAC1DD,cAAc,CAAClG,OAAO,CAAE+F,CAAC,IAAK,IAAI,CAACxB,mBAAmB,CAACwB,CAAC,CAAC,CAAC;EAC9D;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMK,kBAAkBA,CAAClG,GAAG,EAAExC,KAAK,EAAE;IACjC,MAAM8D,OAAO,GAAG;MACZwC,IAAI,EAAE,kBAAkB;MACxBhD,EAAE,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAACoB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC3CsH,SAAS,EAAE,IAAI,CAAC9H,OAAO,CAACyC,EAAE;MAC1BzB,QAAQ,EAAE;QAAE,CAACW,GAAG,GAAGxC;MAAM;IAC7B,CAAC;IACD,OAAO,IAAI,CAACwH,gBAAgB,CAAC,YAAY;MACrC,MAAMoB,GAAG,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC/E,OAAO,CAAC;MAC3C,IAAI8E,GAAG,CAACtC,IAAI,KAAK,MAAM,EAAE;QACrB,MAAM,IAAIW,KAAK,CAAC2B,GAAG,CAACL,KAAK,IAAI,gCAAgC,CAAC;MAClE;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMO,YAAYA,CAAChB,KAAK,EAAEiB,eAAe,EAAEC,WAAW,GAAG,KAAK,EAAE;IAC5D,MAAMhB,IAAI,GAAG,MAAM,IAAI,CAACvE,MAAM,CAACwF,OAAO,CAAChB,IAAI,CAACiB,SAAS,CAACrJ,MAAM,CAACsJ,MAAM,CAACtJ,MAAM,CAACsJ,MAAM,CAAC,CAAC,CAAC,EAAEJ,eAAe,CAAC,EAAE;MAAEK,MAAM,EAAEC,QAAQ,CAACD,MAAM;MAAEE,WAAW,EAAEC,MAAM,CAACC,uBAAuB,GAAG,cAAc,GAAG;IAAM,CAAC,CAAC,CAAC,CAAC;IAC5M,MAAM1F,OAAO,GAAG;MACZwC,IAAI,EAAE,cAAc;MACpBhD,EAAE,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAACoB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC3CsH,SAAS,EAAE,IAAI,CAAC9H,OAAO,CAACyC,EAAE;MAC1BwE,KAAK;MACLE,IAAI;MACJgB;IACJ,CAAC;IACD,OAAO,IAAI,CAACnB,aAAa,CAAC,YAAY;MAClC,MAAMe,GAAG,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC/E,OAAO,CAAC;MAC3C,IAAI8E,GAAG,CAACtC,IAAI,KAAK,MAAM,EAAE;QACrB,MAAM,IAAIW,KAAK,CAAC2B,GAAG,CAACL,KAAK,IAAI,yBAAyB,CAAC;MAC3D;MACA,OAAOK,GAAG,CAACa,OAAO;IACtB,CAAC,CAAC;EACN;EACAC,QAAQA,CAAC5F,OAAO,EAAE;IACd,IAAI,CAACgB,EAAE,CAAC4E,QAAQ,CAACzB,IAAI,CAACiB,SAAS,CAACpF,OAAO,CAAC,CAAC;EAC7C;EACAiC,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAC3E,qBAAqB,GAAGuI,IAAI,CAACC,GAAG,CAAC,CAAC;EAC3C;EACA3D,SAASA,CAAA,EAAG;IACR,IAAI0D,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACxI,qBAAqB,GAAGV,kBAAkB,GAAG,CAAC,EAAE;MAClE,IAAI,CAACoE,EAAE,CAACsC,UAAU,CAAC,CAAC;MACpB;IACJ;IACA,IAAI;MACA,IAAI,CAACtC,EAAE,CAAC4E,QAAQ,CAAC,GAAG,CAAC;IACzB,CAAC,CACD,OAAO/G,EAAE,EAAE;MACP;IAAA;EAER;EACA,MAAMkG,WAAWA,CAAC/E,OAAO,EAAE+F,OAAO,GAAGlJ,eAAe,EAAE;IAClD,MAAMmJ,KAAK,GAAGhG,OAAO,CAACR,EAAE;IACxB,IAAI,CAACoG,QAAQ,CAAC5F,OAAO,CAAC;IACtB;IACA,IAAIiG,SAAS;IACb,OAAOxE,OAAO,CAACyE,IAAI,CAAC,CAChB,IAAIzE,OAAO,CAAC,CAAC0E,CAAC,EAAEC,MAAM,KAAK;MACvBH,SAAS,GAAGR,MAAM,CAAC9D,UAAU,CAAC,MAAM;QAChCyE,MAAM,CAAC,IAAIjD,KAAK,CAAC,WAAW6C,KAAK,YAAY,CAAC,CAAC;MACnD,CAAC,EAAED,OAAO,CAAC;IACf,CAAC,CAAC,EACF,IAAItE,OAAO,CAAEC,OAAO,IAAK;MACrB,IAAI,CAAC9D,kBAAkB,CAACyI,GAAG,CAACL,KAAK,EAAGzD,CAAC,IAAK;QACtC+D,YAAY,CAACL,SAAS,CAAC,CAAC,CAAC;QACzBvE,OAAO,CAACa,CAAC,CAAC;QACV,IAAI,CAAC3E,kBAAkB,CAAC2I,MAAM,CAACP,KAAK,CAAC;MACzC,CAAC,CAAC;IACN,CAAC,CAAC,CACL,CAAC;EACN;EACA,MAAMlE,YAAYA,CAAA,EAAG;IACjB,MAAMS,CAAC,GAAG;MACNC,IAAI,EAAE,aAAa;MACnBhD,EAAE,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAACoB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC3CsH,SAAS,EAAE,IAAI,CAAC9H,OAAO,CAACyC,EAAE;MAC1BgH,UAAU,EAAE,IAAI,CAACzJ,OAAO,CAAC2B;IAC7B,CAAC;IACD,MAAMoG,GAAG,GAAG,MAAM,IAAI,CAACC,WAAW,CAACxC,CAAC,CAAC;IACrC,IAAIuC,GAAG,CAACtC,IAAI,KAAK,MAAM,EAAE;MACrB,MAAM,IAAIW,KAAK,CAAC2B,GAAG,CAACL,KAAK,IAAI,uBAAuB,CAAC;IACzD;EACJ;EACA1C,YAAYA,CAAA,EAAG;IACX,MAAMQ,CAAC,GAAG;MACNC,IAAI,EAAE,UAAU;MAChBhD,EAAE,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAACoB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC3CsH,SAAS,EAAE,IAAI,CAAC9H,OAAO,CAACyC;IAC5B,CAAC;IACD,IAAI,CAACoG,QAAQ,CAACrD,CAAC,CAAC;EACpB;EACAP,oBAAoBA,CAAA,EAAG;IACnB,MAAMO,CAAC,GAAG;MACNC,IAAI,EAAE,kBAAkB;MACxBhD,EAAE,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAACoB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC3CsH,SAAS,EAAE,IAAI,CAAC9H,OAAO,CAACyC;IAC5B,CAAC;IACD,IAAI,CAACoG,QAAQ,CAACrD,CAAC,CAAC;EACpB;AACJ;AACAtG,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}