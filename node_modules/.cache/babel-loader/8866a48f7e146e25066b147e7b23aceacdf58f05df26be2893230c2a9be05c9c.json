{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nexport const ivLength = 16;\n/**\n * Decrypts encrypted data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Decryption options.\n * @returns The decrypted data.\n */\nexport async function decrypt(value, key, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const encrypted = Bytes.from(value);\n  const iv = encrypted.slice(0, ivLength);\n  const data = encrypted.slice(ivLength);\n  const decrypted = await globalThis.crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, Bytes.from(data));\n  const result = new Uint8Array(decrypted);\n  if (as === 'Bytes') return result;\n  return Hex.from(result);\n}\n/**\n * Encrypts data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Encryption options.\n * @returns The encrypted data.\n */\nexport async function encrypt(value, key, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const iv = Bytes.random(ivLength);\n  const encrypted = await globalThis.crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, Bytes.from(value));\n  const result = Bytes.concat(iv, new Uint8Array(encrypted));\n  if (as === 'Bytes') return result;\n  return Hex.from(result);\n}\n/**\n * Derives an AES-GCM key from a password using PBKDF2.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * // @log: CryptoKey {}\n * ```\n *\n * @param options - Options for key derivation.\n * @returns The derived key.\n */\nexport async function getKey(options) {\n  const {\n    iterations = 900_000,\n    password,\n    salt = randomSalt(32)\n  } = options;\n  const baseKey = await globalThis.crypto.subtle.importKey('raw', Bytes.fromString(password), {\n    name: 'PBKDF2'\n  }, false, ['deriveBits', 'deriveKey']);\n  const key = await globalThis.crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt,\n    iterations,\n    hash: 'SHA-256'\n  }, baseKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, false, ['encrypt', 'decrypt']);\n  return key;\n}\n/**\n * Generates a random salt of the specified size.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const salt = AesGcm.randomSalt()\n * // @log: Uint8Array [123, 79, 183, 167, 163, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166]\n * ```\n *\n * @param size - The size of the salt to generate. Defaults to `32`.\n * @returns A random salt of the specified size.\n */\nexport function randomSalt(size = 32) {\n  return Bytes.random(size);\n}","map":{"version":3,"names":["Bytes","Hex","ivLength","decrypt","value","key","options","as","encrypted","from","iv","slice","data","decrypted","globalThis","crypto","subtle","name","result","Uint8Array","encrypt","random","concat","getKey","iterations","password","salt","randomSalt","baseKey","importKey","fromString","deriveKey","hash","length","size"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/AesGcm.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nexport const ivLength = 16\n\n/**\n * Decrypts encrypted data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Decryption options.\n * @returns The decrypted data.\n */\nexport async function decrypt<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Bytes.Bytes | Hex.Hex,\n  key: CryptoKey,\n  options: decrypt.Options<as> = {},\n): Promise<decrypt.ReturnType<as>> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const encrypted = Bytes.from(value)\n  const iv = encrypted.slice(0, ivLength)\n  const data = encrypted.slice(ivLength)\n  const decrypted = await globalThis.crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    Bytes.from(data),\n  )\n  const result = new Uint8Array(decrypted)\n  if (as === 'Bytes') return result as never\n  return Hex.from(result) as never\n}\n\nexport declare namespace decrypt {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encrypts data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Encryption options.\n * @returns The encrypted data.\n */\nexport async function encrypt<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Bytes' | 'Hex' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Bytes.Bytes | Hex.Hex,\n  key: CryptoKey,\n  options: encrypt.Options<as> = {},\n): Promise<encrypt.ReturnType<as>> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const iv = Bytes.random(ivLength)\n  const encrypted = await globalThis.crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    Bytes.from(value),\n  )\n  const result = Bytes.concat(iv, new Uint8Array(encrypted))\n  if (as === 'Bytes') return result as never\n  return Hex.from(result) as never\n}\n\nexport declare namespace encrypt {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> = {\n    /** The output format. @default 'Hex' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.concat.ErrorType\n    | Bytes.from.ErrorType\n    | Bytes.random.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Derives an AES-GCM key from a password using PBKDF2.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * // @log: CryptoKey {}\n * ```\n *\n * @param options - Options for key derivation.\n * @returns The derived key.\n */\nexport async function getKey(options: getKey.Options): Promise<CryptoKey> {\n  const { iterations = 900_000, password, salt = randomSalt(32) } = options\n  const baseKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    Bytes.fromString(password),\n    { name: 'PBKDF2' },\n    false,\n    ['deriveBits', 'deriveKey'],\n  )\n  const key = await globalThis.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: 'SHA-256',\n    },\n    baseKey,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['encrypt', 'decrypt'],\n  )\n  return key\n}\n\nexport declare namespace getKey {\n  type Options = {\n    /** The number of iterations to use. @default 900_000 */\n    iterations?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `AesGcm.randomSalt(32)` */\n    salt?: Bytes.Bytes | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Generates a random salt of the specified size.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const salt = AesGcm.randomSalt()\n * // @log: Uint8Array [123, 79, 183, 167, 163, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166]\n * ```\n *\n * @param size - The size of the salt to generate. Defaults to `32`.\n * @returns A random salt of the specified size.\n */\nexport function randomSalt(size = 32): Bytes.Bytes {\n  return Bytes.random(size)\n}\n\nexport declare namespace randomSalt {\n  type ErrorType = Bytes.random.ErrorType | Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}