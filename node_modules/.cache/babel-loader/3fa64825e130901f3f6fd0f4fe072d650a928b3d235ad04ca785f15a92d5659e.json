{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readContract = readContract;\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst getContractError_js_1 = require(\"../../utils/errors/getContractError.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst call_js_1 = require(\"./call.js\");\nasync function readContract(client, parameters) {\n  const {\n    abi,\n    address,\n    args,\n    functionName,\n    ...rest\n  } = parameters;\n  const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({\n    abi,\n    args,\n    functionName\n  });\n  try {\n    const {\n      data\n    } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({\n      ...rest,\n      data: calldata,\n      to: address\n    });\n    return (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n      abi,\n      args,\n      functionName,\n      data: data || '0x'\n    });\n  } catch (error) {\n    throw (0, getContractError_js_1.getContractError)(error, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName\n    });\n  }\n}","map":{"version":3,"names":["exports","readContract","decodeFunctionResult_js_1","require","encodeFunctionData_js_1","getContractError_js_1","getAction_js_1","call_js_1","client","parameters","abi","address","args","functionName","rest","calldata","encodeFunctionData","data","getAction","call","to","decodeFunctionResult","error","getContractError","docsPath"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/actions/public/readContract.ts"],"sourcesContent":["import type { Abi } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type ReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = UnionEvaluate<\n  Pick<\n    CallParameters,\n    | 'account'\n    | 'blockNumber'\n    | 'blockTag'\n    | 'factory'\n    | 'factoryData'\n    | 'stateOverride'\n  >\n> &\n  ContractFunctionParameters<abi, 'pure' | 'view', functionName, args, boolean>\n\nexport type ReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ContractFunctionReturnType<abi, 'pure' | 'view', functionName, args>\n\nexport type ReadContractErrorType = GetContractErrorReturnType<\n  CallErrorType | EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n>\n\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  client: Client<Transport, chain>,\n  parameters: ReadContractParameters<abi, functionName, args>,\n): Promise<ReadContractReturnType<abi, functionName, args>> {\n  const { abi, address, args, functionName, ...rest } =\n    parameters as ReadContractParameters\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      ...(rest as CallParameters),\n      data: calldata,\n      to: address!,\n    })\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    }) as ReadContractReturnType<abi, functionName>\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n"],"mappings":";;;;;AAsGAA,OAAA,CAAAC,YAAA,GAAAA,YAAA;AAzFA,MAAAC,yBAAA,GAAAC,OAAA;AAIA,MAAAC,uBAAA,GAAAD,OAAA;AAKA,MAAAE,qBAAA,GAAAF,OAAA;AAIA,MAAAG,cAAA,GAAAH,OAAA;AAEA,MAAAI,SAAA,GAAAJ,OAAA;AA0EO,eAAeF,YAAYA,CAMhCO,MAAgC,EAChCC,UAA2D;EAE3D,MAAM;IAAEC,GAAG;IAAEC,OAAO;IAAEC,IAAI;IAAEC,YAAY;IAAE,GAAGC;EAAI,CAAE,GACjDL,UAAoC;EACtC,MAAMM,QAAQ,GAAG,IAAAX,uBAAA,CAAAY,kBAAkB,EAAC;IAClCN,GAAG;IACHE,IAAI;IACJC;GAC+B,CAAC;EAClC,IAAI;IACF,MAAM;MAAEI;IAAI,CAAE,GAAG,MAAM,IAAAX,cAAA,CAAAY,SAAS,EAC9BV,MAAM,EACND,SAAA,CAAAY,IAAI,EACJ,MAAM,CACP,CAAC;MACA,GAAIL,IAAuB;MAC3BG,IAAI,EAAEF,QAAQ;MACdK,EAAE,EAAET;KACL,CAAC;IACF,OAAO,IAAAT,yBAAA,CAAAmB,oBAAoB,EAAC;MAC1BX,GAAG;MACHE,IAAI;MACJC,YAAY;MACZI,IAAI,EAAEA,IAAI,IAAI;KACf,CAA8C;EACjD,CAAC,CAAC,OAAOK,KAAK,EAAE;IACd,MAAM,IAAAjB,qBAAA,CAAAkB,gBAAgB,EAACD,KAAkB,EAAE;MACzCZ,GAAG;MACHC,OAAO;MACPC,IAAI;MACJY,QAAQ,EAAE,6BAA6B;MACvCX;KACD,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}