{"ast":null,"code":"import { secp256r1 } from '@noble/curves/p256';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nimport * as PublicKey from './PublicKey.js';\nimport * as Entropy from './internal/entropy.js';\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1;\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n  const {\n    privateKey\n  } = options;\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === 'string' ? privateKey.slice(2) : Hex.fromBytes(privateKey).slice(2));\n  return PublicKey.from(point);\n}\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = secp256r1.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(options) {\n  const {\n    payload,\n    signature\n  } = options;\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  const signature_ = new secp256r1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n  const payload_ = payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload;\n  const point = signature_.recoverPublicKey(payload_.substring(2));\n  return PublicKey.from(point);\n}\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options) {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey\n  } = options;\n  const {\n    r,\n    s,\n    recovery\n  } = secp256r1.sign(payload instanceof Uint8Array ? payload : Bytes.fromHex(payload), privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey), {\n    extraEntropy: typeof extraEntropy === 'boolean' ? extraEntropy : Hex.from(extraEntropy).slice(2),\n    lowS: true,\n    ...(hash ? {\n      prehash: true\n    } : {})\n  });\n  return {\n    r,\n    s,\n    yParity: recovery\n  };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options) {\n  const {\n    hash,\n    payload,\n    publicKey,\n    signature\n  } = options;\n  return secp256r1.verify(signature, payload instanceof Uint8Array ? payload : Bytes.fromHex(payload), PublicKey.toHex(publicKey).substring(2), ...(hash ? [{\n    prehash: true,\n    lowS: true\n  }] : []));\n}","map":{"version":3,"names":["secp256r1","Bytes","Hex","PublicKey","Entropy","noble","getPublicKey","options","privateKey","point","ProjectivePoint","fromPrivateKey","slice","fromBytes","from","randomPrivateKey","as","bytes","utils","recoverPublicKey","payload","signature","r","s","yParity","signature_","Signature","BigInt","addRecoveryBit","payload_","Uint8Array","substring","sign","extraEntropy","hash","recovery","fromHex","lowS","prehash","verify","publicKey","toHex"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/P256.ts"],"sourcesContent":["import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport * as Entropy from './internal/entropy.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}