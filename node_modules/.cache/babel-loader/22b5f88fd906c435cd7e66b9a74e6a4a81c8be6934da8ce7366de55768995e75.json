{"ast":null,"code":"import { BaseError } from './base.js';\nexport class ChainNotConfiguredError extends BaseError {\n  constructor() {\n    super('Chain not configured.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ChainNotConfiguredError'\n    });\n  }\n}\nexport class ConnectorAlreadyConnectedError extends BaseError {\n  constructor() {\n    super('Connector already connected.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorAlreadyConnectedError'\n    });\n  }\n}\nexport class ConnectorNotConnectedError extends BaseError {\n  constructor() {\n    super('Connector not connected.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorNotConnectedError'\n    });\n  }\n}\nexport class ConnectorNotFoundError extends BaseError {\n  constructor() {\n    super('Connector not found.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorNotFoundError'\n    });\n  }\n}\nexport class ConnectorAccountNotFoundError extends BaseError {\n  constructor({\n    address,\n    connector\n  }) {\n    super(`Account \"${address}\" not found for connector \"${connector.name}\".`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorAccountNotFoundError'\n    });\n  }\n}\nexport class ConnectorChainMismatchError extends BaseError {\n  constructor({\n    connectionChainId,\n    connectorChainId\n  }) {\n    super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {\n      metaMessages: [`Current Chain ID:  ${connectorChainId}`, `Expected Chain ID: ${connectionChainId}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorChainMismatchError'\n    });\n  }\n}\nexport class ConnectorUnavailableReconnectingError extends BaseError {\n  constructor({\n    connector\n  }) {\n    super(`Connector \"${connector.name}\" unavailable while reconnecting.`, {\n      details: ['During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.', 'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.', 'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.'].join(' ')\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'ConnectorUnavailableReconnectingError'\n    });\n  }\n}","map":{"version":3,"names":["BaseError","ChainNotConfiguredError","constructor","Object","defineProperty","ConnectorAlreadyConnectedError","ConnectorNotConnectedError","ConnectorNotFoundError","ConnectorAccountNotFoundError","address","connector","name","ConnectorChainMismatchError","connectionChainId","connectorChainId","metaMessages","ConnectorUnavailableReconnectingError","details","join"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/core/src/errors/config.ts"],"sourcesContent":["import type { Address } from 'viem'\n\nimport type { Connector } from '../createConfig.js'\nimport { BaseError } from './base.js'\n\nexport type ChainNotConfiguredErrorType = ChainNotConfiguredError & {\n  name: 'ChainNotConfiguredError'\n}\nexport class ChainNotConfiguredError extends BaseError {\n  override name = 'ChainNotConfiguredError'\n  constructor() {\n    super('Chain not configured.')\n  }\n}\n\nexport type ConnectorAlreadyConnectedErrorType =\n  ConnectorAlreadyConnectedError & {\n    name: 'ConnectorAlreadyConnectedError'\n  }\nexport class ConnectorAlreadyConnectedError extends BaseError {\n  override name = 'ConnectorAlreadyConnectedError'\n  constructor() {\n    super('Connector already connected.')\n  }\n}\n\nexport type ConnectorNotConnectedErrorType = ConnectorNotConnectedError & {\n  name: 'ConnectorNotConnectedError'\n}\nexport class ConnectorNotConnectedError extends BaseError {\n  override name = 'ConnectorNotConnectedError'\n  constructor() {\n    super('Connector not connected.')\n  }\n}\n\nexport type ConnectorNotFoundErrorType = ConnectorNotFoundError & {\n  name: 'ConnectorNotFoundError'\n}\nexport class ConnectorNotFoundError extends BaseError {\n  override name = 'ConnectorNotFoundError'\n  constructor() {\n    super('Connector not found.')\n  }\n}\n\nexport type ConnectorAccountNotFoundErrorType =\n  ConnectorAccountNotFoundError & {\n    name: 'ConnectorAccountNotFoundError'\n  }\nexport class ConnectorAccountNotFoundError extends BaseError {\n  override name = 'ConnectorAccountNotFoundError'\n  constructor({\n    address,\n    connector,\n  }: {\n    address: Address\n    connector: Connector\n  }) {\n    super(`Account \"${address}\" not found for connector \"${connector.name}\".`)\n  }\n}\n\nexport type ConnectorChainMismatchErrorType = ConnectorAccountNotFoundError & {\n  name: 'ConnectorChainMismatchError'\n}\nexport class ConnectorChainMismatchError extends BaseError {\n  override name = 'ConnectorChainMismatchError'\n  constructor({\n    connectionChainId,\n    connectorChainId,\n  }: {\n    connectionChainId: number\n    connectorChainId: number\n  }) {\n    super(\n      `The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${connectorChainId}`,\n          `Expected Chain ID: ${connectionChainId}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type ConnectorUnavailableReconnectingErrorType =\n  ConnectorUnavailableReconnectingError & {\n    name: 'ConnectorUnavailableReconnectingError'\n  }\nexport class ConnectorUnavailableReconnectingError extends BaseError {\n  override name = 'ConnectorUnavailableReconnectingError'\n  constructor({ connector }: { connector: { name: string } }) {\n    super(`Connector \"${connector.name}\" unavailable while reconnecting.`, {\n      details: [\n        'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',\n        'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',\n        'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',\n      ].join(' '),\n    })\n  }\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,WAAW;AAKrC,OAAM,MAAOC,uBAAwB,SAAQD,SAAS;EAEpDE,YAAA;IACE,KAAK,CAAC,uBAAuB,CAAC;IAFvBC,MAAA,CAAAC,cAAA;;;;aAAO;;EAGhB;;AAOF,OAAM,MAAOC,8BAA+B,SAAQL,SAAS;EAE3DE,YAAA;IACE,KAAK,CAAC,8BAA8B,CAAC;IAF9BC,MAAA,CAAAC,cAAA;;;;aAAO;;EAGhB;;AAMF,OAAM,MAAOE,0BAA2B,SAAQN,SAAS;EAEvDE,YAAA;IACE,KAAK,CAAC,0BAA0B,CAAC;IAF1BC,MAAA,CAAAC,cAAA;;;;aAAO;;EAGhB;;AAMF,OAAM,MAAOG,sBAAuB,SAAQP,SAAS;EAEnDE,YAAA;IACE,KAAK,CAAC,sBAAsB,CAAC;IAFtBC,MAAA,CAAAC,cAAA;;;;aAAO;;EAGhB;;AAOF,OAAM,MAAOI,6BAA8B,SAAQR,SAAS;EAE1DE,YAAY;IACVO,OAAO;IACPC;EAAS,CAIV;IACC,KAAK,CAAC,YAAYD,OAAO,8BAA8BC,SAAS,CAACC,IAAI,IAAI,CAAC;IARnER,MAAA,CAAAC,cAAA;;;;aAAO;;EAShB;;AAMF,OAAM,MAAOQ,2BAA4B,SAAQZ,SAAS;EAExDE,YAAY;IACVW,iBAAiB;IACjBC;EAAgB,CAIjB;IACC,KAAK,CACH,2CAA2CA,gBAAgB,gDAAgDD,iBAAiB,IAAI,EAChI;MACEE,YAAY,EAAE,CACZ,sBAAsBD,gBAAgB,EAAE,EACxC,sBAAsBD,iBAAiB,EAAE;KAE5C,CACF;IAhBMV,MAAA,CAAAC,cAAA;;;;aAAO;;EAiBhB;;AAOF,OAAM,MAAOY,qCAAsC,SAAQhB,SAAS;EAElEE,YAAY;IAAEQ;EAAS,CAAmC;IACxD,KAAK,CAAC,cAAcA,SAAS,CAACC,IAAI,mCAAmC,EAAE;MACrEM,OAAO,EAAE,CACP,uHAAuH,EACvH,sHAAsH,EACtH,8GAA8G,CAC/G,CAACC,IAAI,CAAC,GAAG;KACX,CAAC;IARKf,MAAA,CAAAC,cAAA;;;;aAAO;;EAShB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}