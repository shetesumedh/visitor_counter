{"ast":null,"code":"import { blake3 } from '@noble/hashes/blake3';\nimport * as Bytes from './Bytes.js';\n/**\n * Creates a new Binary State Tree instance.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n * ```\n *\n * @returns A Binary State Tree.\n */\nexport function create() {\n  return {\n    root: emptyNode()\n  };\n}\n/**\n * Inserts a key-value pair into the Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert( // [!code focus]\n *   tree, // [!code focus]\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'), // [!code focus]\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1') // [!code focus]\n * ) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @param key - Key to insert.\n * @param value - Value to insert.\n */\nexport function insert(tree, key, value) {\n  const stem = Bytes.slice(key, 0, 31);\n  const subIndex = Bytes.slice(key, 31)[0];\n  if (tree.root.type === 'empty') {\n    tree.root = stemNode(stem);\n    tree.root.values[subIndex] = value;\n    return;\n  }\n  function inner(node_, stem, subIndex, value, depth) {\n    let node = node_;\n    if (node.type === 'empty') {\n      node = stemNode(stem);\n      node.values[subIndex] = value;\n      return node;\n    }\n    const stemBits = bytesToBits(stem);\n    if (node.type === 'stem') {\n      if (Bytes.isEqual(node.stem, stem)) {\n        node.values[subIndex] = value;\n        return node;\n      }\n      const existingStemBits = bytesToBits(node.stem);\n      return splitLeaf(node, stemBits, existingStemBits, subIndex, value, depth);\n    }\n    if (node.type === 'internal') {\n      const bit = stemBits[depth];\n      if (bit === 0) {\n        node.left = inner(node.left, stem, subIndex, value, depth + 1);\n      } else {\n        node.right = inner(node.right, stem, subIndex, value, depth + 1);\n      }\n      return node;\n    }\n    return emptyNode();\n  }\n  tree.root = inner(tree.root, stem, subIndex, value, 0);\n}\n/**\n * Merkelizes a Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert(\n *   tree,\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'),\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1')\n * )\n *\n * const hash = BinaryStateTree.merkelize(tree) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @returns Merkle hash.\n */\nexport function merkelize(tree) {\n  function inner(node) {\n    if (node.type === 'empty') return new Uint8Array(32).fill(0);\n    if (node.type === 'internal') {\n      const hash_left = inner(node.left);\n      const hash_right = inner(node.right);\n      return hash(Bytes.concat(hash_left, hash_right));\n    }\n    let level = node.values.map(hash);\n    while (level.length > 1) {\n      const level_ = [];\n      for (let i = 0; i < level.length; i += 2) level_.push(hash(Bytes.concat(level[i], level[i + 1])));\n      level = level_;\n    }\n    return hash(Bytes.concat(node.stem, new Uint8Array(1).fill(0), level[0]));\n  }\n  return inner(tree.root);\n}\n/** @internal */\nfunction splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth) {\n  if (stemBits[depth] === existingStemBits[depth]) {\n    const internal = internalNode();\n    const bit = stemBits[depth];\n    if (bit === 0) {\n      internal.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);\n    } else {\n      internal.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);\n    }\n    return internal;\n  }\n  const internal = internalNode();\n  const bit = stemBits[depth];\n  const stem = bitsToBytes(stemBits);\n  if (bit === 0) {\n    internal.left = stemNode(stem);\n    internal.left.values[subIndex] = value;\n    internal.right = leaf;\n  } else {\n    internal.right = stemNode(stem);\n    internal.right.values[subIndex] = value;\n    internal.left = leaf;\n  }\n  return internal;\n}\n/** @internal */\nfunction emptyNode() {\n  return {\n    type: 'empty'\n  };\n}\n/** @internal */\nfunction internalNode() {\n  return {\n    left: emptyNode(),\n    right: emptyNode(),\n    type: 'internal'\n  };\n}\n/** @internal */\nfunction stemNode(stem) {\n  return {\n    stem,\n    values: Array.from({\n      length: 256\n    }, () => undefined),\n    type: 'stem'\n  };\n}\n/** @internal */\nfunction bytesToBits(bytes) {\n  const bits = [];\n  for (const byte of bytes) for (let i = 0; i < 8; i++) bits.push(byte >> 7 - i & 1);\n  return bits;\n}\n/** @internal */\nfunction bitsToBytes(bits) {\n  const byte_data = new Uint8Array(bits.length / 8);\n  for (let i = 0; i < bits.length; i += 8) {\n    let byte = 0;\n    for (let j = 0; j < 8; j++) byte |= bits[i + j] << 7 - j;\n    byte_data[i / 8] = byte;\n  }\n  return byte_data;\n}\n/** @internal */\nfunction hash(bytes) {\n  if (!bytes) return new Uint8Array(32).fill(0);\n  if (!bytes.some(byte => byte !== 0)) return new Uint8Array(32).fill(0);\n  return blake3(bytes);\n}","map":{"version":3,"names":["blake3","Bytes","create","root","emptyNode","insert","tree","key","value","stem","slice","subIndex","type","stemNode","values","inner","node_","depth","node","stemBits","bytesToBits","isEqual","existingStemBits","splitLeaf","bit","left","right","merkelize","Uint8Array","fill","hash_left","hash_right","hash","concat","level","map","length","level_","i","push","leaf","internal","internalNode","bitsToBytes","Array","from","undefined","bytes","bits","byte","byte_data","j","some"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/BinaryStateTree.ts"],"sourcesContent":["import { blake3 } from '@noble/hashes/blake3'\n\nimport * as Bytes from './Bytes.js'\nimport type { OneOf } from './internal/types.js'\n\n/** Type that defines a Binary State Tree instance. */\nexport type BinaryStateTree = {\n  root: Node\n}\n\n/** Type defining a node of the BST. */\nexport type Node = OneOf<EmptyNode | StemNode | InternalNode>\n\n/**\n * Creates a new Binary State Tree instance.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n * ```\n *\n * @returns A Binary State Tree.\n */\nexport function create(): BinaryStateTree {\n  return {\n    root: emptyNode(),\n  }\n}\n\n/**\n * Inserts a key-value pair into the Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert( // [!code focus]\n *   tree, // [!code focus]\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'), // [!code focus]\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1') // [!code focus]\n * ) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @param key - Key to insert.\n * @param value - Value to insert.\n */\nexport function insert(\n  tree: BinaryStateTree,\n  key: Bytes.Bytes,\n  value: Bytes.Bytes,\n): void {\n  const stem = Bytes.slice(key, 0, 31)\n  const subIndex = Bytes.slice(key, 31)[0]!\n\n  if (tree.root.type === 'empty') {\n    tree.root = stemNode(stem)\n    tree.root.values[subIndex] = value\n    return\n  }\n\n  function inner(\n    node_: Node,\n    stem: Bytes.Bytes,\n    subIndex: number,\n    value: Bytes.Bytes,\n    depth: number,\n  ): Node {\n    let node = node_\n\n    if (node.type === 'empty') {\n      node = stemNode(stem)\n      node.values[subIndex!] = value\n      return node\n    }\n\n    const stemBits = bytesToBits(stem)\n    if (node.type === 'stem') {\n      if (Bytes.isEqual(node.stem, stem)) {\n        node.values[subIndex!] = value\n        return node\n      }\n      const existingStemBits = bytesToBits(node.stem)\n      return splitLeaf(node, stemBits, existingStemBits, subIndex, value, depth)\n    }\n\n    if (node.type === 'internal') {\n      const bit = stemBits[depth]\n      if (bit === 0) {\n        node.left = inner(node.left, stem, subIndex, value, depth + 1)\n      } else {\n        node.right = inner(node.right, stem, subIndex, value, depth + 1)\n      }\n      return node\n    }\n\n    return emptyNode()\n  }\n  tree.root = inner(tree.root, stem, subIndex, value, 0)\n}\n\n/**\n * Merkelizes a Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert(\n *   tree,\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'),\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1')\n * )\n *\n * const hash = BinaryStateTree.merkelize(tree) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @returns Merkle hash.\n */\nexport function merkelize(tree: BinaryStateTree): Bytes.Bytes {\n  function inner(node: Node): Bytes.Bytes {\n    if (node.type === 'empty') return new Uint8Array(32).fill(0)\n    if (node.type === 'internal') {\n      const hash_left = inner(node.left)\n      const hash_right = inner(node.right)\n      return hash(Bytes.concat(hash_left, hash_right))\n    }\n\n    let level = node.values.map(hash)\n    while (level.length > 1) {\n      const level_ = []\n      for (let i = 0; i < level.length; i += 2)\n        level_.push(hash(Bytes.concat(level[i]!, level[i + 1]!)))\n      level = level_\n    }\n\n    return hash(Bytes.concat(node.stem, new Uint8Array(1).fill(0), level[0]!))\n  }\n\n  return inner(tree.root)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Internal\n//////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\ntype EmptyNode = {\n  type: 'empty'\n}\n\n/** @internal */\ntype InternalNode = {\n  left: Node\n  right: Node\n  type: 'internal'\n}\n\n/** @internal */\ntype StemNode = {\n  stem: Bytes.Bytes\n  values: (Bytes.Bytes | undefined)[]\n  type: 'stem'\n}\n\n/** @internal */\nfunction splitLeaf(\n  leaf: Node,\n  stemBits: number[],\n  existingStemBits: number[],\n  subIndex: number,\n  value: Bytes.Bytes,\n  depth: number,\n): Node {\n  if (stemBits[depth] === existingStemBits[depth]) {\n    const internal = internalNode()\n    const bit = stemBits[depth]\n    if (bit === 0) {\n      internal.left = splitLeaf(\n        leaf,\n        stemBits,\n        existingStemBits,\n        subIndex,\n        value,\n        depth + 1,\n      )\n    } else {\n      internal.right = splitLeaf(\n        leaf,\n        stemBits,\n        existingStemBits,\n        subIndex,\n        value,\n        depth + 1,\n      )\n    }\n    return internal\n  }\n\n  const internal = internalNode()\n  const bit = stemBits[depth]\n  const stem = bitsToBytes(stemBits)\n  if (bit === 0) {\n    internal.left = stemNode(stem)\n    internal.left.values[subIndex] = value\n    internal.right = leaf\n  } else {\n    internal.right = stemNode(stem)\n    internal.right.values[subIndex] = value\n    internal.left = leaf\n  }\n  return internal\n}\n\n/** @internal */\nfunction emptyNode(): EmptyNode {\n  return {\n    type: 'empty',\n  }\n}\n\n/** @internal */\nfunction internalNode(): InternalNode {\n  return {\n    left: emptyNode(),\n    right: emptyNode(),\n    type: 'internal',\n  }\n}\n\n/** @internal */\nfunction stemNode(stem: Bytes.Bytes): StemNode {\n  return {\n    stem,\n    values: Array.from({ length: 256 }, () => undefined),\n    type: 'stem',\n  }\n}\n\n/** @internal */\nfunction bytesToBits(bytes: Bytes.Bytes): number[] {\n  const bits = []\n  for (const byte of bytes)\n    for (let i = 0; i < 8; i++) bits.push((byte >> (7 - i)) & 1)\n  return bits\n}\n\n/** @internal */\nfunction bitsToBytes(bits: number[]): Bytes.Bytes {\n  const byte_data = new Uint8Array(bits.length / 8)\n  for (let i = 0; i < bits.length; i += 8) {\n    let byte = 0\n    for (let j = 0; j < 8; j++) byte |= bits[i + j]! << (7 - j)\n    byte_data[i / 8] = byte\n  }\n  return byte_data\n}\n\n/** @internal */\nfunction hash(bytes: Bytes.Bytes | undefined): Bytes.Bytes {\n  if (!bytes) return new Uint8Array(32).fill(0)\n  if (!bytes.some((byte) => byte !== 0)) return new Uint8Array(32).fill(0)\n  return blake3(bytes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}