{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(signature, options = {}) {\n  const {\n    recovered\n  } = options;\n  if (typeof signature.r === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (typeof signature.s === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (recovered && typeof signature.yParity === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (signature.r < 0n || signature.r > Solidity.maxUint256) throw new InvalidRError({\n    value: signature.r\n  });\n  if (signature.s < 0n || signature.s > Solidity.maxUint256) throw new InvalidSError({\n    value: signature.s\n  });\n  if (typeof signature.yParity === 'number' && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n    value: signature.yParity\n  });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature) {\n  return fromHex(Hex.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature) {\n  if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n    signature\n  });\n  const r = BigInt(Hex.slice(signature, 0, 32));\n  const s = BigInt(Hex.slice(signature, 32, 64));\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`);\n    if (Number.isNaN(yParity)) return undefined;\n    try {\n      return vToYParity(yParity);\n    } catch {\n      throw new InvalidYParityError({\n        value: yParity\n      });\n    }\n  })();\n  if (typeof yParity === 'undefined') return {\n    r,\n    s\n  };\n  return {\n    r,\n    s,\n    yParity\n  };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value) {\n  if (typeof value.r === 'undefined') return undefined;\n  if (typeof value.s === 'undefined') return undefined;\n  return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from(signature) {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature);\n    if (typeof signature.r === 'string') return fromRpc(signature);\n    if (signature.v) return fromLegacy(signature);\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined' ? {\n        yParity: signature.yParity\n      } : {})\n    };\n  })();\n  assert(signature_);\n  return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature) {\n  return fromDerHex(Hex.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature) {\n  const {\n    r,\n    s\n  } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n  return {\n    r,\n    s\n  };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature) {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v)\n  };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature) {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined;\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n    if (typeof v === 'number' && typeof yParity !== 'number') yParity = vToYParity(v);\n    if (typeof yParity !== 'number') throw new InvalidYParityError({\n      value: signature.yParity\n    });\n    return yParity;\n  })();\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity\n  };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple) {\n  const [yParity, r, s] = tuple;\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity)\n  });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature) {\n  return Bytes.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature) {\n  assert(signature);\n  const r = signature.r;\n  const s = signature.s;\n  const signature_ = Hex.concat(Hex.fromNumber(r, {\n    size: 32\n  }), Hex.fromNumber(s, {\n    size: 32\n  }),\n  // If the signature is recovered, add the recovery byte to the signature.\n  typeof signature.yParity === 'number' ? Hex.fromNumber(yParityToV(signature.yParity), {\n    size: 1\n  }) : '0x');\n  return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature) {\n  const sig = new secp256k1.Signature(signature.r, signature.s);\n  return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature) {\n  const sig = new secp256k1.Signature(signature.r, signature.s);\n  return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature) {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity)\n  };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature) {\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  return {\n    r: Hex.fromNumber(r, {\n      size: 32\n    }),\n    s: Hex.fromNumber(s, {\n      size: 32\n    }),\n    yParity: yParity === 0 ? '0x0' : '0x1'\n  };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature) {\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  return [yParity ? '0x01' : '0x', r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r)), s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s))];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(signature, options = {}) {\n  try {\n    assert(signature, options);\n    return true;\n  } catch {\n    return false;\n  }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v) {\n  if (v === 0 || v === 27) return 0;\n  if (v === 1 || v === 28) return 1;\n  if (v >= 35) return v % 2 === 0 ? 1 : 0;\n  throw new InvalidVError({\n    value: v\n  });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity) {\n  if (yParity === 0) return 27;\n  if (yParity === 1) return 28;\n  throw new InvalidYParityError({\n    value: yParity\n  });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  constructor({\n    signature\n  }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: ['Expected: 64 bytes or 65 bytes.', `Received ${Hex.size(Hex.from(signature))} bytes.`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidSerializedSizeError'\n    });\n  }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  constructor({\n    signature\n  }) {\n    super(`Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.MissingPropertiesError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  constructor({\n    value\n  }) {\n    super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidRError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  constructor({\n    value\n  }) {\n    super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidSError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  constructor({\n    value\n  }) {\n    super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidYParityError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  constructor({\n    value\n  }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidVError'\n    });\n  }\n}","map":{"version":3,"names":["secp256k1","Bytes","Errors","Hex","Json","Solidity","assert","signature","options","recovered","r","MissingPropertiesError","s","yParity","maxUint256","InvalidRError","value","InvalidSError","InvalidYParityError","fromBytes","fromHex","length","InvalidSerializedSizeError","BigInt","slice","Number","isNaN","undefined","vToYParity","extract","from","signature_","Uint8Array","fromRpc","v","fromLegacy","fromDerBytes","fromDerHex","Signature","fromDER","fromTuple","tuple","toBytes","toHex","concat","fromNumber","size","yParityToV","toDerBytes","sig","toDERRawBytes","toDerHex","toDERHex","toLegacy","toRpc","toTuple","trimLeft","validate","InvalidVError","BaseError","constructor","metaMessages","Object","defineProperty","stringify"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/Signature.ts"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}