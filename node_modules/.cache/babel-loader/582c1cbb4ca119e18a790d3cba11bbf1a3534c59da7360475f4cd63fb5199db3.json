{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidChecksumError = exports.InvalidInputError = exports.InvalidAddressError = void 0;\nexports.assert = assert;\nexports.checksum = checksum;\nexports.from = from;\nexports.fromPublicKey = fromPublicKey;\nexports.isEqual = isEqual;\nexports.validate = validate;\nconst Bytes = require(\"./Bytes.js\");\nconst Caches = require(\"./Caches.js\");\nconst Errors = require(\"./Errors.js\");\nconst Hash = require(\"./Hash.js\");\nconst PublicKey = require(\"./PublicKey.js\");\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\nfunction assert(value, options = {}) {\n  const {\n    strict = true\n  } = options;\n  if (!addressRegex.test(value)) throw new InvalidAddressError({\n    address: value,\n    cause: new InvalidInputError()\n  });\n  if (strict) {\n    if (value.toLowerCase() === value) return;\n    if (checksum(value) !== value) throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidChecksumError()\n    });\n  }\n}\nfunction checksum(address) {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address);\n  assert(address, {\n    strict: false\n  });\n  const hexAddress = address.substring(2).toLowerCase();\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), {\n    as: 'Bytes'\n  });\n  const characters = hexAddress.split('');\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i].toUpperCase();\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1].toUpperCase();\n    }\n  }\n  const result = `0x${characters.join('')}`;\n  Caches.checksum.set(address, result);\n  return result;\n}\nfunction from(address, options = {}) {\n  const {\n    checksum: checksumVal = false\n  } = options;\n  assert(address);\n  if (checksumVal) return checksum(address);\n  return address;\n}\nfunction fromPublicKey(publicKey, options = {}) {\n  const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n  return from(`0x${address}`, options);\n}\nfunction isEqual(addressA, addressB) {\n  assert(addressA, {\n    strict: false\n  });\n  assert(addressB, {\n    strict: false\n  });\n  return addressA.toLowerCase() === addressB.toLowerCase();\n}\nfunction validate(address, options = {}) {\n  const {\n    strict = true\n  } = options ?? {};\n  try {\n    assert(address, {\n      strict\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass InvalidAddressError extends Errors.BaseError {\n  constructor({\n    address,\n    cause\n  }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidAddressError'\n    });\n  }\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidInputError extends Errors.BaseError {\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidInputError'\n    });\n  }\n}\nexports.InvalidInputError = InvalidInputError;\nclass InvalidChecksumError extends Errors.BaseError {\n  constructor() {\n    super('Address does not match its checksum counterpart.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidChecksumError'\n    });\n  }\n}\nexports.InvalidChecksumError = InvalidChecksumError;","map":{"version":3,"names":["exports","assert","checksum","from","fromPublicKey","isEqual","validate","Bytes","require","Caches","Errors","Hash","PublicKey","addressRegex","value","options","strict","test","InvalidAddressError","address","cause","InvalidInputError","toLowerCase","InvalidChecksumError","has","get","hexAddress","substring","hash","keccak256","fromString","as","characters","split","i","toUpperCase","result","join","set","checksumVal","publicKey","toHex","slice","addressA","addressB","BaseError","constructor","Object","defineProperty"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/node_modules/ox/core/Address.ts"],"sourcesContent":["import type { Address as abitype_Address } from 'abitype'\nimport * as Bytes from './Bytes.js'\nimport * as Caches from './Caches.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as PublicKey from './PublicKey.js'\n\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/\n\n/** Root type for Address. */\nexport type Address = abitype_Address\n\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(\n  value: string,\n  options: assert.Options = {},\n): asserts value is Address {\n  const { strict = true } = options\n\n  if (!addressRegex.test(value))\n    throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidInputError(),\n    })\n\n  if (strict) {\n    if (value.toLowerCase() === value) return\n    if (checksum(value as Address) !== value)\n      throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidChecksumError(),\n      })\n  }\n}\n\nexport declare namespace assert {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = InvalidAddressError | Errors.GlobalErrorType\n}\n\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address: string): Address {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address)!\n\n  assert(address, { strict: false })\n\n  const hexAddress = address.substring(2).toLowerCase()\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' })\n\n  const characters = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1]! >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i]!.toUpperCase()\n    }\n    if ((hash[i >> 1]! & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1]!.toUpperCase()\n    }\n  }\n\n  const result = `0x${characters.join('')}` as const\n  Caches.checksum.set(address, result)\n  return result\n}\n\nexport declare namespace checksum {\n  type ErrorType =\n    | assert.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address: string, options: from.Options = {}): Address {\n  const { checksum: checksumVal = false } = options\n  assert(address)\n  if (checksumVal) return checksum(address)\n  return address as Address\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | checksum.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(\n  publicKey: PublicKey.PublicKey,\n  options: fromPublicKey.Options = {},\n): Address {\n  const address = Hash.keccak256(\n    `0x${PublicKey.toHex(publicKey).slice(4)}`,\n  ).substring(26)\n  return from(`0x${address}`, options)\n}\n\nexport declare namespace fromPublicKey {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA: Address, addressB: Address): boolean {\n  assert(addressA, { strict: false })\n  assert(addressB, { strict: false })\n  return addressA.toLowerCase() === addressB.toLowerCase()\n}\n\nexport declare namespace isEqual {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(\n  address: string,\n  options: validate.Options = {},\n): address is Address {\n  const { strict = true } = options ?? {}\n  try {\n    assert(address, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n}\n\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError<\n  cause extends InvalidInputError | InvalidChecksumError =\n    | InvalidInputError\n    | InvalidChecksumError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'Address.InvalidAddressError'\n\n  constructor({ address, cause }: { address: string; cause: cause }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidInputError'\n\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.')\n  }\n}\n\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidChecksumError'\n\n  constructor() {\n    super('Address does not match its checksum counterpart.')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}