{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseEventLogs = parseEventLogs;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst isAddressEqual_js_1 = require(\"../address/isAddressEqual.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst keccak256_js_1 = require(\"../hash/keccak256.js\");\nconst toEventSelector_js_1 = require(\"../hash/toEventSelector.js\");\nconst decodeEventLog_js_1 = require(\"./decodeEventLog.js\");\nfunction parseEventLogs(parameters) {\n  const {\n    abi,\n    args,\n    logs,\n    strict = true\n  } = parameters;\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined;\n    if (Array.isArray(parameters.eventName)) return parameters.eventName;\n    return [parameters.eventName];\n  })();\n  return logs.map(log => {\n    try {\n      const abiItem = abi.find(abiItem => abiItem.type === 'event' && log.topics[0] === (0, toEventSelector_js_1.toEventSelector)(abiItem));\n      if (!abiItem) return null;\n      const event = (0, decodeEventLog_js_1.decodeEventLog)({\n        ...log,\n        abi: [abiItem],\n        strict\n      });\n      if (eventName && !eventName.includes(event.eventName)) return null;\n      if (!includesArgs({\n        args: event.args,\n        inputs: abiItem.inputs,\n        matchArgs: args\n      })) return null;\n      return {\n        ...event,\n        ...log\n      };\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof abi_js_1.AbiEventSignatureNotFoundError) return null;\n      if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {\n        if (strict) return null;\n        eventName = err.abiItem.name;\n        isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n      }\n      return {\n        ...log,\n        args: isUnnamed ? [] : {},\n        eventName\n      };\n    }\n  }).filter(Boolean);\n}\nfunction includesArgs(parameters) {\n  const {\n    args,\n    inputs,\n    matchArgs\n  } = parameters;\n  if (!matchArgs) return true;\n  if (!args) return false;\n  function isEqual(input, value, arg) {\n    try {\n      if (input.type === 'address') return (0, isAddressEqual_js_1.isAddressEqual)(value, arg);\n      if (input.type === 'string' || input.type === 'bytes') return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value)) === arg;\n      return value === arg;\n    } catch {\n      return false;\n    }\n  }\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true;\n      const input = inputs[index];\n      if (!input) return false;\n      const value_ = Array.isArray(value) ? value : [value];\n      return value_.some(value => isEqual(input, value, args[index]));\n    });\n  }\n  if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value]) => {\n    if (value === null || value === undefined) return true;\n    const input = inputs.find(input => input.name === key);\n    if (!input) return false;\n    const value_ = Array.isArray(value) ? value : [value];\n    return value_.some(value => isEqual(input, value, args[key]));\n  });\n  return false;\n}","map":{"version":3,"names":["exports","parseEventLogs","abi_js_1","require","isAddressEqual_js_1","toBytes_js_1","keccak256_js_1","toEventSelector_js_1","decodeEventLog_js_1","parameters","abi","args","logs","strict","eventName","undefined","Array","isArray","map","log","abiItem","find","type","topics","toEventSelector","event","decodeEventLog","includes","includesArgs","inputs","matchArgs","err","isUnnamed","AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","name","some","x","filter","Boolean","isEqual","input","value","arg","isAddressEqual","keccak256","toBytes","every","index","value_","Object","entries","key"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/abi/parseEventLogs.ts"],"sourcesContent":["// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = (abi as Abi).find(\n          (abiItem) =>\n            abiItem.type === 'event' &&\n            log.topics[0] === toEventSelector(abiItem),\n        ) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (value === null || value === undefined) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}