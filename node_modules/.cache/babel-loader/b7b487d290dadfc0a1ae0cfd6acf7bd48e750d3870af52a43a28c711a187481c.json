{"ast":null,"code":"import { useInfiniteQuery as tanstack_useInfiniteQuery, useQuery as tanstack_useQuery, useMutation } from '@tanstack/react-query';\nimport { hashFn } from '@wagmi/core/query';\nexport { useMutation };\n// Adding some basic customization.\n// Ideally we don't have this function, but `import('@tanstack/react-query').useQuery` currently has some quirks where it is super hard to\n// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.\nexport function useQuery(parameters) {\n  const result = tanstack_useQuery({\n    ...parameters,\n    queryKeyHashFn: hashFn // for bigint support\n  });\n  result.queryKey = parameters.queryKey;\n  return result;\n}\n// Adding some basic customization.\nexport function useInfiniteQuery(parameters) {\n  const result = tanstack_useInfiniteQuery({\n    ...parameters,\n    queryKeyHashFn: hashFn // for bigint support\n  });\n  result.queryKey = parameters.queryKey;\n  return result;\n}","map":{"version":3,"names":["useInfiniteQuery","tanstack_useInfiniteQuery","useQuery","tanstack_useQuery","useMutation","hashFn","parameters","result","queryKeyHashFn","queryKey"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/wagmi/src/utils/query.ts"],"sourcesContent":["import {\n  type DefaultError,\n  type QueryKey,\n  type UseInfiniteQueryOptions,\n  type UseInfiniteQueryResult,\n  type UseMutationOptions,\n  type UseMutationResult,\n  type UseQueryOptions,\n  type UseQueryResult,\n  useInfiniteQuery as tanstack_useInfiniteQuery,\n  useQuery as tanstack_useQuery,\n  useMutation,\n} from '@tanstack/react-query'\nimport type {\n  Compute,\n  ExactPartial,\n  Omit,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport { hashFn } from '@wagmi/core/query'\n\nexport type UseMutationParameters<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  Omit<\n    UseMutationOptions<data, error, Compute<variables>, context>,\n    'mutationFn' | 'mutationKey' | 'throwOnError'\n  >\n>\n\nexport type UseMutationReturnType<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  UnionStrictOmit<\n    UseMutationResult<data, error, variables, context>,\n    'mutate' | 'mutateAsync'\n  >\n>\n\nexport { useMutation }\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport type UseQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n> = Compute<\n  ExactPartial<\n    Omit<UseQueryOptions<queryFnData, error, data, queryKey>, 'initialData'>\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseQueryOptions<queryFnData, error, data, queryKey>['initialData']\n      | undefined\n  }\n>\n\nexport type UseQueryReturnType<data = unknown, error = DefaultError> = Compute<\n  UseQueryResult<data, error> & {\n    queryKey: QueryKey\n  }\n>\n\n// Adding some basic customization.\n// Ideally we don't have this function, but `import('@tanstack/react-query').useQuery` currently has some quirks where it is super hard to\n// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.\nexport function useQuery<queryFnData, error, data, queryKey extends QueryKey>(\n  parameters: UseQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseQueryReturnType<data, error> {\n  const result = tanstack_useQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport type UseInfiniteQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryData = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n  pageParam = unknown,\n> = Compute<\n  Omit<\n    UseInfiniteQueryOptions<\n      queryFnData,\n      error,\n      data,\n      queryData,\n      queryKey,\n      pageParam\n    >,\n    'initialData'\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseInfiniteQueryOptions<\n          queryFnData,\n          error,\n          data,\n          queryKey\n        >['initialData']\n      | undefined\n  }\n>\n\nexport type UseInfiniteQueryReturnType<\n  data = unknown,\n  error = DefaultError,\n> = UseInfiniteQueryResult<data, error> & {\n  queryKey: QueryKey\n}\n\n// Adding some basic customization.\nexport function useInfiniteQuery<\n  queryFnData,\n  error,\n  data,\n  queryKey extends QueryKey,\n>(\n  parameters: UseInfiniteQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseInfiniteQueryReturnType<data, error> {\n  const result = tanstack_useInfiniteQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseInfiniteQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n"],"mappings":"AAAA,SASEA,gBAAgB,IAAIC,yBAAyB,EAC7CC,QAAQ,IAAIC,iBAAiB,EAC7BC,WAAW,QACN,uBAAuB;AAO9B,SAASC,MAAM,QAAQ,mBAAmB;AA0B1C,SAASD,WAAW;AA0BpB;AACA;AACA;AACA,OAAM,SAAUF,QAAQA,CACtBI,UAEC;EAED,MAAMC,MAAM,GAAGJ,iBAAiB,CAAC;IAC/B,GAAIG,UAAkB;IACtBE,cAAc,EAAEH,MAAM,CAAE;GACzB,CAAoC;EACrCE,MAAM,CAACE,QAAQ,GAAGH,UAAU,CAACG,QAAQ;EACrC,OAAOF,MAAM;AACf;AA0CA;AACA,OAAM,SAAUP,gBAAgBA,CAM9BM,UAEC;EAED,MAAMC,MAAM,GAAGN,yBAAyB,CAAC;IACvC,GAAIK,UAAkB;IACtBE,cAAc,EAAEH,MAAM,CAAE;GACzB,CAA4C;EAC7CE,MAAM,CAACE,QAAQ,GAAGH,UAAU,CAACG,QAAQ;EACrC,OAAOF,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}