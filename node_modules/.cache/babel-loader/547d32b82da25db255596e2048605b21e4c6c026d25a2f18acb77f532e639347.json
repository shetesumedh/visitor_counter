{"ast":null,"code":"import * as Address from './Address.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nexport function fromTupleList(accessList) {\n  const list = [];\n  for (let i = 0; i < accessList.length; i++) {\n    const [address, storageKeys] = accessList[i];\n    if (address) Address.assert(address, {\n      strict: false\n    });\n    list.push({\n      address: address,\n      storageKeys: storageKeys.map(key => Hash.validate(key) ? key : Hex.trimLeft(key))\n    });\n  }\n  return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nexport function toTupleList(accessList) {\n  if (!accessList || accessList.length === 0) return [];\n  const tuple = [];\n  for (const {\n    address,\n    storageKeys\n  } of accessList) {\n    for (let j = 0; j < storageKeys.length; j++) if (Hex.size(storageKeys[j]) !== 32) throw new InvalidStorageKeySizeError({\n      storageKey: storageKeys[j]\n    });\n    if (address) Address.assert(address, {\n      strict: false\n    });\n    tuple.push([address, storageKeys]);\n  }\n  return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */\nexport class InvalidStorageKeySizeError extends Errors.BaseError {\n  constructor({\n    storageKey\n  }) {\n    super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Hex.size(storageKey)} bytes.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AccessList.InvalidStorageKeySizeError'\n    });\n  }\n}","map":{"version":3,"names":["Address","Errors","Hash","Hex","fromTupleList","accessList","list","i","length","address","storageKeys","assert","strict","push","map","key","validate","trimLeft","toTupleList","tuple","j","size","InvalidStorageKeySizeError","storageKey","BaseError","constructor","Object","defineProperty"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/AccessList.ts"],"sourcesContent":["import * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, Mutable } from './internal/types.js'\n\nexport type AccessList = Compute<readonly Item[]>\n\nexport type Item = Compute<{\n  address: Address.Address\n  storageKeys: readonly Hex.Hex[]\n}>\n\nexport type ItemTuple = Compute<\n  [address: Address.Address, storageKeys: readonly Hex.Hex[]]\n>\n\nexport type Tuple = readonly ItemTuple[]\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nexport function fromTupleList(accessList: Tuple): AccessList {\n  const list: Mutable<AccessList> = []\n  for (let i = 0; i < accessList.length; i++) {\n    const [address, storageKeys] = accessList[i] as [Hex.Hex, Hex.Hex[]]\n\n    if (address) Address.assert(address, { strict: false })\n\n    list.push({\n      address: address,\n      storageKeys: storageKeys.map((key) =>\n        Hash.validate(key) ? key : Hex.trimLeft(key),\n      ),\n    })\n  }\n  return list\n}\n\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nexport function toTupleList(\n  accessList?: AccessList | undefined,\n): Compute<Tuple> {\n  if (!accessList || accessList.length === 0) return []\n\n  const tuple: Mutable<Tuple> = []\n  for (const { address, storageKeys } of accessList) {\n    for (let j = 0; j < storageKeys.length; j++)\n      if (Hex.size(storageKeys[j]!) !== 32)\n        throw new InvalidStorageKeySizeError({\n          storageKey: storageKeys[j]!,\n        })\n\n    if (address) Address.assert(address, { strict: false })\n\n    tuple.push([address, storageKeys])\n  }\n  return tuple\n}\n\n/** Thrown when the size of a storage key is invalid. */\nexport class InvalidStorageKeySizeError extends Errors.BaseError {\n  override readonly name = 'AccessList.InvalidStorageKeySizeError'\n  constructor({ storageKey }: { storageKey: Hex.Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Hex.size(storageKey)} bytes.`,\n    )\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,MAAM,MAAM,aAAa;AACrC,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAgB/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAM,SAAUC,aAAaA,CAACC,UAAiB;EAC7C,MAAMC,IAAI,GAAwB,EAAE;EACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1C,MAAM,CAACE,OAAO,EAAEC,WAAW,CAAC,GAAGL,UAAU,CAACE,CAAC,CAAyB;IAEpE,IAAIE,OAAO,EAAET,OAAO,CAACW,MAAM,CAACF,OAAO,EAAE;MAAEG,MAAM,EAAE;IAAK,CAAE,CAAC;IAEvDN,IAAI,CAACO,IAAI,CAAC;MACRJ,OAAO,EAAEA,OAAO;MAChBC,WAAW,EAAEA,WAAW,CAACI,GAAG,CAAEC,GAAG,IAC/Bb,IAAI,CAACc,QAAQ,CAACD,GAAG,CAAC,GAAGA,GAAG,GAAGZ,GAAG,CAACc,QAAQ,CAACF,GAAG,CAAC;KAE/C,CAAC;EACJ;EACA,OAAOT,IAAI;AACb;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,OAAM,SAAUY,WAAWA,CACzBb,UAAmC;EAEnC,IAAI,CAACA,UAAU,IAAIA,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EAErD,MAAMW,KAAK,GAAmB,EAAE;EAChC,KAAK,MAAM;IAAEV,OAAO;IAAEC;EAAW,CAAE,IAAIL,UAAU,EAAE;IACjD,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,WAAW,CAACF,MAAM,EAAEY,CAAC,EAAE,EACzC,IAAIjB,GAAG,CAACkB,IAAI,CAACX,WAAW,CAACU,CAAC,CAAE,CAAC,KAAK,EAAE,EAClC,MAAM,IAAIE,0BAA0B,CAAC;MACnCC,UAAU,EAAEb,WAAW,CAACU,CAAC;KAC1B,CAAC;IAEN,IAAIX,OAAO,EAAET,OAAO,CAACW,MAAM,CAACF,OAAO,EAAE;MAAEG,MAAM,EAAE;IAAK,CAAE,CAAC;IAEvDO,KAAK,CAACN,IAAI,CAAC,CAACJ,OAAO,EAAEC,WAAW,CAAC,CAAC;EACpC;EACA,OAAOS,KAAK;AACd;AAEA;AACA,OAAM,MAAOG,0BAA2B,SAAQrB,MAAM,CAACuB,SAAS;EAE9DC,YAAY;IAAEF;EAAU,CAA2B;IACjD,KAAK,CACH,yBAAyBA,UAAU,wCAAwCpB,GAAG,CAACkB,IAAI,CAACE,UAAU,CAAC,SAAS,CACzG;IAJeG,MAAA,CAAAC,cAAA;;;;aAAO;;EAKzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}