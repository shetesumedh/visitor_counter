{"ast":null,"code":"/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from \"./_md.js\";\nimport { fromBig } from \"./_u64.js\";\nimport { BLAKE2, compress } from \"./blake2.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createXOFer, swap32IfBE, toBytes, u32, u8 } from \"./utils.js\";\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000\n};\nconst B3_IV = SHA256_IV.slice();\nconst B3_SIGMA = /* @__PURE__ */(() => {\n  const Id = Array.from({\n    length: 16\n  }, (_, i) => i);\n  const permute = arr => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map(i => arr[i]);\n  const res = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2 {\n  constructor(opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    this.chunkPos = 0; // Position of current block in chunk\n    this.chunksDone = 0; // How many chunks we already have\n    this.flags = 0 | 0;\n    this.stack = [];\n    // Output\n    this.posOut = 0;\n    this.bufferOut32 = new Uint32Array(16);\n    this.chunkOut = 0; // index of output chunk\n    this.enableXOF = true;\n    const {\n      key,\n      context\n    } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({\n        dkLen: 32\n      }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  get() {\n    return [];\n  }\n  set() {}\n  b2Compress(counter, flags, buf, bufPos = 0) {\n    const {\n      state: s,\n      pos\n    } = this;\n    const {\n      h,\n      l\n    } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const {\n      v0,\n      v1,\n      v2,\n      v3,\n      v4,\n      v5,\n      v6,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11,\n      v12,\n      v13,\n      v14,\n      v15\n    } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  compress(buf, bufPos = 0, isLast = false) {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to) {\n    to = super._cloneInto(to);\n    const {\n      IV,\n      flags,\n      state,\n      chunkPos,\n      posOut,\n      chunkOut,\n      stack,\n      chunksDone\n    } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map(i => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  b2CompressOut() {\n    const {\n      state: s,\n      pos,\n      flags,\n      buffer32,\n      bufferOut32: out32\n    } = this;\n    const {\n      h,\n      l\n    } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const {\n      v0,\n      v1,\n      v2,\n      v3,\n      v4,\n      v5,\n      v6,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11,\n      v12,\n      v13,\n      v14,\n      v15\n    } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  finish() {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  writeInto(out) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const {\n      blockLen,\n      bufferOut\n    } = this;\n    for (let pos = 0, len = out.length; pos < len;) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out) {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes) {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out) {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3 = /* @__PURE__ */createXOFer(opts => new BLAKE3(opts));","map":{"version":3,"names":["SHA256_IV","fromBig","BLAKE2","compress","abytes","aexists","anumber","aoutput","clean","createXOFer","swap32IfBE","toBytes","u32","u8","B3_Flags","CHUNK_START","CHUNK_END","PARENT","ROOT","KEYED_HASH","DERIVE_KEY_CONTEXT","DERIVE_KEY_MATERIAL","B3_IV","slice","B3_SIGMA","Id","Array","from","length","_","i","permute","arr","map","res","v","push","Uint8Array","BLAKE3","constructor","opts","flags","dkLen","undefined","chunkPos","chunksDone","stack","posOut","bufferOut32","Uint32Array","chunkOut","enableXOF","key","context","hasContext","Error","k","IV","ctx","contextKey","update","digest","state","bufferOut","get","set","b2Compress","counter","buf","bufPos","s","pos","h","l","BigInt","v0","v1","v2","v3","v4","v5","v6","v7","v8","v9","v10","v11","v12","v13","v14","v15","isLast","blockLen","chunk","last","chunks","pop","buffer32","_cloneInto","to","destroy","destroyed","b2CompressOut","out32","finish","finished","buffer","subarray","writeInto","out","len","take","Math","min","xofInto","xof","bytes","digestInto","outputLen","blake3"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/node_modules/@noble/hashes/src/blake3.ts"],"sourcesContent":["/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from './_md.ts';\nimport { fromBig } from './_u64.ts';\nimport { BLAKE2, compress } from './blake2.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createXOFer, swap32IfBE, toBytes, u32, u8,\n  type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000,\n} as const;\n\nconst B3_IV = SHA256_IV.slice();\n\nconst B3_SIGMA: Uint8Array = /* @__PURE__ */ (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n/**\n * Ensure to use EITHER `key` OR `context`, not both.\n *\n * * `key`: 32-byte MAC key.\n * * `context`: string for KDF. Should be hardcoded, globally unique, and application - specific.\n *   A good default format for the context string is \"[application] [commit timestamp] [purpose]\".\n */\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private flags = 0 | 0;\n  private IV: Uint32Array;\n  private state: Uint32Array;\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    const { key, context } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n        .update(ctx)\n        .digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get(): [] {\n    return [];\n  }\n  protected set(): void {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false): void {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3: CHashXO = /* @__PURE__ */ createXOFer<BLAKE3, Blake3Opts>(\n  (opts) => new BLAKE3(opts)\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}