{"ast":null,"code":"import * as AbiParameters from './AbiParameters.js';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert(value) {\n  const {\n    domain,\n    message,\n    primaryType,\n    types\n  } = value;\n  const validateData = (struct, data) => {\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      const value = data[name];\n      const integerMatch = type.match(Solidity.integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [, base, size_] = integerMatch;\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '') / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !Address.validate(value)) throw new Address.InvalidAddressError({\n        address: value,\n        cause: new Address.InvalidInputError()\n      });\n      const bytesMatch = type.match(Solidity.bytesRegex);\n      if (bytesMatch) {\n        const [, size] = bytesMatch;\n        if (size && Hex.size(value) !== Number.parseInt(size)) throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size),\n          givenSize: Hex.size(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) {\n        validateReference(type);\n        validateData(struct, value);\n      }\n    }\n  };\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({\n      domain\n    });\n    validateData(types.EIP712Domain, domain);\n  }\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message);else throw new InvalidPrimaryTypeError({\n      primaryType,\n      types\n    });\n  }\n}\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain) {\n  return hashDomain({\n    domain\n  });\n}\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode(value) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = value;\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types\n  };\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts = ['0x19', '0x01'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types\n  }));\n  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({\n    data: message,\n    primaryType,\n    types\n  }));\n  return Hex.concat(...parts);\n}\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value) {\n  const {\n    primaryType,\n    types\n  } = value;\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? []).map(({\n      name,\n      type: t\n    }) => `${t} ${name}`).join(',')})`;\n  }\n  return result;\n}\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(domain) {\n  return [typeof domain?.name === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, domain?.version && {\n    name: 'version',\n    type: 'string'\n  }, typeof domain?.chainId === 'number' && {\n    name: 'chainId',\n    type: 'uint256'\n  }, domain?.verifyingContract && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, domain?.salt && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(value) {\n  return Hash.keccak256(encode(value));\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value) {\n  const {\n    domain,\n    types\n  } = value;\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain)\n    }\n  });\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value) {\n  const {\n    data,\n    primaryType,\n    types\n  } = value;\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types\n  });\n  return Hash.keccak256(encoded);\n}\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize(value) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types\n  } = value;\n  const normalizeData = (struct, value) => {\n    const data = {\n      ...value\n    };\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      if (type === 'address') data[name] = data[name].toLowerCase();\n    }\n    return data;\n  };\n  const domain = (() => {\n    if (!domain_) return {};\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_);\n    return normalizeData(type, domain_);\n  })();\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined;\n    if (!types[primaryType]) return {};\n    return normalizeData(types[primaryType], message_);\n  })();\n  return Json.stringify({\n    domain,\n    message,\n    primaryType,\n    types\n  }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString();\n    return value;\n  });\n}\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate(value) {\n  try {\n    assert(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  constructor({\n    expectedSize,\n    givenSize\n  }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.BytesSizeMismatchError'\n    });\n  }\n}\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  constructor({\n    domain\n  }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidDomainError'\n    });\n  }\n}\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  constructor({\n    primaryType,\n    types\n  }) {\n    super(`Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`, {\n      metaMessages: ['Check that the primary type is a key in `types`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidPrimaryTypeError'\n    });\n  }\n}\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  constructor({\n    type\n  }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidStructTypeError'\n    });\n  }\n}\n/** @internal */\nexport function encodeData(value) {\n  const {\n    data,\n    primaryType,\n    types\n  } = value;\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return AbiParameters.encode(encodedTypes, encodedValues);\n}\n/** @internal */\nexport function hashType(value) {\n  const {\n    primaryType,\n    types\n  } = value;\n  const encodedHashType = Hex.fromString(encodeType({\n    primaryType,\n    types\n  }));\n  return Hash.keccak256(encodedHashType);\n}\n/** @internal */\nexport function encodeField(properties) {\n  let {\n    types,\n    name,\n    type,\n    value\n  } = properties;\n  if (types[type] !== undefined) return [{\n    type: 'bytes32'\n  }, Hash.keccak256(encodeData({\n    data: value,\n    primaryType: type,\n    types\n  }))];\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : '';\n    value = `0x${prepend + value.slice(2)}`;\n    return [{\n      type: 'bytes32'\n    }, Hash.keccak256(value, {\n      as: 'Hex'\n    })];\n  }\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, Hash.keccak256(Bytes.fromString(value), {\n    as: 'Hex'\n  })];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, Hash.keccak256(AbiParameters.encode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))];\n  }\n  return [{\n    type\n  }, value];\n}\n/** @internal */\nexport function findTypeDependencies(value, results = new Set()) {\n  const {\n    primaryType: primaryType_,\n    types\n  } = value;\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) return results;\n  results.add(primaryType);\n  for (const field of types[primaryType]) findTypeDependencies({\n    primaryType: field.type,\n    types\n  }, results);\n  return results;\n}\n/** @internal */\nfunction validateReference(type) {\n  // Struct type must not be a Solidity type.\n  if (type === 'address' || type === 'bool' || type === 'string' || type.startsWith('bytes') || type.startsWith('uint') || type.startsWith('int')) throw new InvalidStructTypeError({\n    type\n  });\n}","map":{"version":3,"names":["AbiParameters","Address","Bytes","Errors","Hash","Hex","Json","Solidity","assert","value","domain","message","primaryType","types","validateData","struct","data","param","name","type","integerMatch","match","integerRegex","base","size_","fromNumber","signed","size","Number","parseInt","validate","InvalidAddressError","address","cause","InvalidInputError","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","validateReference","EIP712Domain","InvalidDomainError","InvalidPrimaryTypeError","domainSeparator","hashDomain","encode","extractEip712DomainTypes","parts","push","hashStruct","concat","encodeType","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","t","join","version","chainId","verifyingContract","salt","filter","Boolean","getSignPayload","keccak256","encoded","encodeData","serialize","domain_","message_","normalizeData","toLowerCase","undefined","stringify","_","toString","BaseError","constructor","Object","defineProperty","metaMessages","JSON","keys","InvalidStructTypeError","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","fromString","properties","prepend","length","slice","as","lastIndexOf","parsedType","typeValuePairs","item","v","results","Set","primaryType_","has","add","startsWith"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/TypedData.ts"],"sourcesContent":["import type * as abitype from 'abitype'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute } from './internal/types.js'\n\nexport type TypedData = abitype.TypedData\nexport type Domain = abitype.TypedDataDomain\nexport type Parameter = abitype.TypedDataParameter\n\n// TODO: Make reusable for Viem?\nexport type Definition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = primaryType extends 'EIP712Domain'\n  ? EIP712DomainDefinition<typedData, primaryType>\n  : MessageDefinition<typedData, primaryType, primaryTypes>\n\nexport type EIP712DomainDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends 'EIP712Domain' = 'EIP712Domain',\n  ///\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n> = {\n  types?: typedData | undefined\n} & {\n  primaryType:\n    | 'EIP712Domain'\n    | (primaryType extends 'EIP712Domain' ? primaryType : never)\n  domain: schema extends { EIP712Domain: infer domain }\n    ? domain\n    : Compute<Domain>\n  message?: undefined\n}\n\nexport type MessageDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n  message = schema[primaryType extends keyof schema\n    ? primaryType\n    : keyof schema],\n> = {\n  types: typedData\n} & {\n  primaryType:\n    | primaryTypes // show all values\n    | (primaryType extends primaryTypes ? primaryType : never) // infer value\n  domain?:\n    | (schema extends { EIP712Domain: infer domain } ? domain : Compute<Domain>)\n    | undefined\n  message: { [_: string]: any } extends message // Check if message was inferred\n    ? Record<string, unknown>\n    : message\n}\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): void {\n  const { domain, message, primaryType, types } =\n    value as unknown as assert.Value\n\n  const validateData = (\n    struct: readonly Parameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(Solidity.integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '') / 8,\n        })\n      }\n\n      if (\n        type === 'address' &&\n        typeof value === 'string' &&\n        !Address.validate(value)\n      )\n        throw new Address.InvalidAddressError({\n          address: value,\n          cause: new Address.InvalidInputError(),\n        })\n\n      const bytesMatch = type.match(Solidity.bytesRegex)\n      if (bytesMatch) {\n        const [, size] = bytesMatch\n        if (size && Hex.size(value as Hex.Hex) !== Number.parseInt(size))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size),\n            givenSize: Hex.size(value as Hex.Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport declare namespace assert {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | Address.InvalidAddressError\n    | BytesSizeMismatchError\n    | InvalidPrimaryTypeError\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain: Domain): Hex.Hex {\n  return hashDomain({\n    domain,\n  })\n}\n\nexport declare namespace domainSeparator {\n  type ErrorType = hashDomain.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  const { domain = {}, message, primaryType } = value as encode.Value\n\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types,\n  } as TypedData\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts: Hex.Hex[] = ['0x19', '0x01']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types,\n      }),\n    )\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types,\n      }),\n    )\n\n  return Hex.concat(...parts)\n}\n\nexport declare namespace encode {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | extractEip712DomainTypes.ErrorType\n    | hashDomain.ErrorType\n    | hashStruct.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value: encodeType.Value): string {\n  const { primaryType, types } = value\n\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? [])\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nexport declare namespace encodeType {\n  type Value = {\n    primaryType: string\n    types: TypedData\n  }\n\n  type ErrorType = findTypeDependencies.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(\n  domain: Domain | undefined,\n): Parameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as Parameter[]\n}\n\nexport declare namespace extractEip712DomainTypes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value: hashDomain.Value): Hex.Hex {\n  const { domain, types } = value\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n    },\n  })\n}\n\nexport declare namespace hashDomain {\n  type Value = {\n    /** The Typed Data domain. */\n    domain: Domain\n    /** The Typed Data types. */\n    types?:\n      | {\n          EIP712Domain?: readonly Parameter[] | undefined\n          [key: string]: readonly Parameter[] | undefined\n        }\n      | undefined\n  }\n\n  type ErrorType = hashStruct.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value: hashStruct.Value): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return Hash.keccak256(encoded)\n}\n\nexport declare namespace hashStruct {\n  type Value = {\n    /** The Typed Data struct to hash. */\n    data: Record<string, unknown>\n    /** The primary type of the Typed Data struct. */\n    primaryType: string\n    /** The types of the Typed Data struct. */\n    types: TypedData\n  }\n\n  type ErrorType =\n    | encodeData.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: serialize.Value<typedData, primaryType>): string {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = value as unknown as serialize.Value\n\n  const normalizeData = (\n    struct: readonly Parameter[],\n    value: Record<string, unknown>,\n  ) => {\n    const data = { ...value }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!domain_) return {}\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_)\n    return normalizeData(type, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    if (!types[primaryType]) return {}\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return Json.stringify({ domain, message, primaryType, types }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\nexport declare namespace serialize {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType = Json.stringify.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'TypedData.BytesSizeMismatchError'\n\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidDomainError'\n\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidPrimaryTypeError'\n\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidStructTypeError'\n\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n    })\n  }\n}\n\n/** @internal */\nexport function encodeData(value: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encodedTypes: AbiParameters.Parameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return AbiParameters.encode(encodedTypes, encodedValues)\n}\n\n/** @internal */\nexport declare namespace encodeData {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | encodeField.ErrorType\n    | hashType.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function hashType(value: {\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { primaryType, types } = value\n  const encodedHashType = Hex.fromString(encodeType({ primaryType, types }))\n  return Hash.keccak256(encodedHashType)\n}\n\n/** @internal */\nexport declare namespace hashType {\n  type ErrorType =\n    | Hex.fromString.ErrorType\n    | encodeType.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeField(properties: {\n  types: TypedData\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameters.Parameter, value: Hex.Hex] {\n  let { types, name, type, value } = properties\n\n  if (types[type] !== undefined)\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, Hash.keccak256(value, { as: 'Hex' })]\n  }\n\n  if (type === 'string')\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(Bytes.fromString(value), { as: 'Hex' }),\n    ]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameters.Parameter, any][]).map(\n      (item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n    )\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(\n        AbiParameters.encode(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n\n/** @internal */\nexport declare namespace encodeField {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function findTypeDependencies(\n  value: {\n    primaryType: string\n    types: TypedData\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const { primaryType: primaryType_, types } = value\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined)\n    return results\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType])\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  return results\n}\n\n/** @internal */\nexport declare namespace findTypeDependencies {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}