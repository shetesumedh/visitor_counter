{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeParameter = decodeParameter;\nexports.decodeAddress = decodeAddress;\nexports.decodeArray = decodeArray;\nexports.decodeBool = decodeBool;\nexports.decodeBytes = decodeBytes;\nexports.decodeNumber = decodeNumber;\nexports.decodeTuple = decodeTuple;\nexports.decodeString = decodeString;\nexports.prepareParameters = prepareParameters;\nexports.prepareParameter = prepareParameter;\nexports.encode = encode;\nexports.encodeAddress = encodeAddress;\nexports.encodeArray = encodeArray;\nexports.encodeBytes = encodeBytes;\nexports.encodeBoolean = encodeBoolean;\nexports.encodeNumber = encodeNumber;\nexports.encodeString = encodeString;\nexports.encodeTuple = encodeTuple;\nexports.getArrayComponents = getArrayComponents;\nexports.hasDynamicChild = hasDynamicChild;\nconst AbiParameters = require(\"../AbiParameters.js\");\nconst Address = require(\"../Address.js\");\nconst Bytes = require(\"../Bytes.js\");\nconst Errors = require(\"../Errors.js\");\nconst Hex = require(\"../Hex.js\");\nconst Solidity_js_1 = require(\"../Solidity.js\");\nfunction decodeParameter(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      checksumAddress,\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    checksumAddress,\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor, {\n    checksum: checksumAddress\n  });\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor, options = {}) {\n  const {\n    checksum = false\n  } = options;\n  const value = cursor.readBytes(32);\n  const wrap = address => checksum ? Address.checksum(address) : address;\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, options) {\n  const {\n    checksumAddress,\n    length,\n    staticPosition\n  } = options;\n  if (!length) {\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  if (hasDynamicChild(param)) {\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\nfunction decodeBool(cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\nfunction decodeBytes(cursor, param, {\n  staticPosition\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    cursor.setPosition(staticPosition + offset);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    if (length === 0) {\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    cursor.setPosition(staticPosition + 32);\n    return [Hex.fromBytes(data), 32];\n  }\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? Bytes.toBigInt(value, {\n    signed\n  }) : Bytes.toNumber(value, {\n    signed\n  }), 32];\n}\nfunction decodeTuple(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  if (hasDynamicChild(param)) {\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\nfunction decodeString(cursor, {\n  staticPosition\n}) {\n  const offset = Bytes.toNumber(cursor.readBytes(32));\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = Bytes.toNumber(cursor.readBytes(32));\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = Bytes.toString(Bytes.trimLeft(data));\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\nfunction prepareParameters({\n  checksumAddress,\n  parameters,\n  values\n}) {\n  const preparedParameters = [];\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(prepareParameter({\n      checksumAddress,\n      parameter: parameters[i],\n      value: values[i]\n    }));\n  }\n  return preparedParameters;\n}\nfunction prepareParameter({\n  checksumAddress = false,\n  parameter: parameter_,\n  value\n}) {\n  const parameter = parameter_;\n  const arrayComponents = getArrayComponents(parameter.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type\n      }\n    });\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value, {\n      checksumAddress,\n      parameter: parameter\n    });\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value, {\n      checksum: checksumAddress\n    });\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value);\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int');\n    const [,, size = '256'] = Solidity_js_1.integerRegex.exec(parameter.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      type: parameter.type\n    });\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value);\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type);\n}\nfunction encode(preparedParameters) {\n  let staticSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) staticSize += 32;else staticSize += Hex.size(encoded);\n  }\n  const staticParameters = [];\n  const dynamicParameters = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) {\n      staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParameters.push(encoded);\n      dynamicSize += Hex.size(encoded);\n    } else {\n      staticParameters.push(encoded);\n    }\n  }\n  return Hex.concat(...staticParameters, ...dynamicParameters);\n}\nfunction encodeAddress(value, options) {\n  const {\n    checksum = false\n  } = options;\n  Address.assert(value, {\n    strict: checksum\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, options) {\n  const {\n    checksumAddress,\n    length,\n    parameter\n  } = options;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${parameter.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParameters = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParameters.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters);\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction encodeBytes(value, {\n  type\n}) {\n  const [, parametersize] = type.split('bytes');\n  const bytesSize = Hex.size(value);\n  if (!parametersize) {\n    let value_ = value;\n    if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n    return {\n      dynamic: true,\n      encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n        size: 32\n      })), value_)\n    };\n  }\n  if (bytesSize !== Number.parseInt(parametersize)) throw new AbiParameters.BytesSizeMismatchError({\n    expectedSize: Number.parseInt(parametersize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padRight(value)\n  };\n}\nfunction encodeBoolean(value) {\n  if (typeof value !== 'boolean') throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(Hex.fromBoolean(value))\n  };\n}\nfunction encodeNumber(value, {\n  signed,\n  size\n}) {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = Hex.fromString(value);\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n      size: 32\n    })), ...parts)\n  };\n}\nfunction encodeTuple(value, options) {\n  const {\n    checksumAddress,\n    parameter\n  } = options;\n  let dynamic = false;\n  const preparedParameters = [];\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: value[index]\n    });\n    preparedParameters.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["exports","decodeParameter","decodeAddress","decodeArray","decodeBool","decodeBytes","decodeNumber","decodeTuple","decodeString","prepareParameters","prepareParameter","encode","encodeAddress","encodeArray","encodeBytes","encodeBoolean","encodeNumber","encodeString","encodeTuple","getArrayComponents","hasDynamicChild","AbiParameters","require","Address","Bytes","Errors","Hex","Solidity_js_1","cursor","param","options","checksumAddress","staticPosition","arrayComponents","type","length","checksum","startsWith","InvalidTypeError","sizeOfLength","sizeOfOffset","value","readBytes","wrap","address","fromBytes","slice","offset","toNumber","start","startOfData","setPosition","dynamicChild","consumed","i","data","consumed_","push","toBoolean","size","_","split","Number","parseInt","signed","toBigInt","hasUnnamedChild","components","some","name","component","toString","trimLeft","parameters","values","preparedParameters","parameter","parameter_","integerRegex","exec","staticSize","dynamic","encoded","staticParameters","dynamicParameters","dynamicSize","fromNumber","concat","assert","strict","padLeft","toLowerCase","Array","isArray","InvalidArrayError","ArrayLengthMismatchError","expectedLength","givenLength","preparedParam","map","parametersize","bytesSize","value_","padRight","Math","ceil","BytesSizeMismatchError","expectedSize","BaseError","fromBoolean","max","BigInt","min","IntegerOutOfRangeError","hexValue","fromString","partsLength","parts","param_","index","matches","match","undefined","endsWith"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/node_modules/ox/core/internal/abiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}