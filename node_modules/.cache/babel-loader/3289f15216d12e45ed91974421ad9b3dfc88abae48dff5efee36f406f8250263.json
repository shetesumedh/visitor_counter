{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.multicall = multicall;\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst contract_js_1 = require(\"../../errors/contract.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst getChainContractAddress_js_1 = require(\"../../utils/chain/getChainContractAddress.js\");\nconst getContractError_js_1 = require(\"../../utils/errors/getContractError.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst readContract_js_1 = require(\"./readContract.js\");\nasync function multicall(client, parameters) {\n  const {\n    account,\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    multicallAddress: multicallAddress_,\n    stateOverride\n  } = parameters;\n  const contracts = parameters.contracts;\n  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === 'object' && client.batch.multicall.batchSize || 1_024);\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new Error('client chain not configured. multicallAddress is required.');\n    multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const chunkedCalls = [[]];\n  let currentChunk = 0;\n  let currentChunkSize = 0;\n  for (let i = 0; i < contracts.length; i++) {\n    const {\n      abi,\n      address,\n      args,\n      functionName\n    } = contracts[i];\n    try {\n      const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({\n        abi,\n        args,\n        functionName\n      });\n      currentChunkSize += (callData.length - 2) / 2;\n      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {\n        currentChunk++;\n        currentChunkSize = (callData.length - 2) / 2;\n        chunkedCalls[currentChunk] = [];\n      }\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData,\n        target: address\n      }];\n    } catch (err) {\n      const error = (0, getContractError_js_1.getContractError)(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n        sender: account\n      });\n      if (!allowFailure) throw error;\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData: '0x',\n        target: address\n      }];\n    }\n  }\n  const aggregate3Results = await Promise.allSettled(chunkedCalls.map(calls => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({\n    abi: abis_js_1.multicall3Abi,\n    account,\n    address: multicallAddress,\n    args: [calls],\n    blockNumber,\n    blockTag,\n    functionName: 'aggregate3',\n    stateOverride\n  })));\n  const results = [];\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i];\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason;\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined\n        });\n      }\n      continue;\n    }\n    const aggregate3Result = result.value;\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      const {\n        returnData,\n        success\n      } = aggregate3Result[j];\n      const {\n        callData\n      } = chunkedCalls[i][j];\n      const {\n        abi,\n        address,\n        functionName,\n        args\n      } = contracts[results.length];\n      try {\n        if (callData === '0x') throw new abi_js_1.AbiDecodingZeroDataError();\n        if (!success) throw new contract_js_1.RawContractError({\n          data: returnData\n        });\n        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n          abi,\n          args,\n          data: returnData,\n          functionName\n        });\n        results.push(allowFailure ? {\n          result,\n          status: 'success'\n        } : result);\n      } catch (err) {\n        const error = (0, getContractError_js_1.getContractError)(err, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName\n        });\n        if (!allowFailure) throw error;\n        results.push({\n          error,\n          result: undefined,\n          status: 'failure'\n        });\n      }\n    }\n  }\n  if (results.length !== contracts.length) throw new base_js_1.BaseError('multicall results mismatch');\n  return results;\n}","map":{"version":3,"names":["exports","multicall","abis_js_1","require","abi_js_1","base_js_1","contract_js_1","decodeFunctionResult_js_1","encodeFunctionData_js_1","getChainContractAddress_js_1","getContractError_js_1","getAction_js_1","readContract_js_1","client","parameters","account","allowFailure","batchSize","batchSize_","blockNumber","blockTag","multicallAddress","multicallAddress_","stateOverride","contracts","batch","chain","Error","getChainContractAddress","contract","chunkedCalls","currentChunk","currentChunkSize","i","length","abi","address","args","functionName","callData","encodeFunctionData","target","err","error","getContractError","docsPath","sender","aggregate3Results","Promise","allSettled","map","calls","getAction","readContract","multicall3Abi","results","result","status","reason","j","push","undefined","aggregate3Result","value","returnData","success","AbiDecodingZeroDataError","RawContractError","data","decodeFunctionResult","BaseError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/actions/public/multicall.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionParameters } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { CallParameters } from './call.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    optional?: boolean\n    properties?: Record<string, any>\n  } = {},\n> = Pick<CallParameters, 'blockNumber' | 'blockTag' | 'stateOverride'> & {\n  account?: Address | undefined\n  allowFailure?: allowFailure | boolean | undefined\n  batchSize?: number | undefined\n  contracts: MulticallContracts<\n    Narrow<contracts>,\n    { mutability: AbiStateMutability } & options\n  >\n  multicallAddress?: Address | undefined\n}\n\nexport type MulticallReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    error?: Error\n  } = { error: Error },\n> = MulticallResults<\n  Narrow<contracts>,\n  allowFailure,\n  { mutability: AbiStateMutability } & options\n>\n\nexport type MulticallErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | GetContractErrorReturnType<\n      EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n    >\n  | ErrorType\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  const contracts extends readonly unknown[],\n  chain extends Chain | undefined,\n  allowFailure extends boolean = true,\n>(\n  client: Client<Transport, chain>,\n  parameters: MulticallParameters<contracts, allowFailure>,\n): Promise<MulticallReturnType<contracts, allowFailure>> {\n  const {\n    account,\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    multicallAddress: multicallAddress_,\n    stateOverride,\n  } = parameters\n  const contracts = parameters.contracts as ContractFunctionParameters[]\n\n  const batchSize =\n    batchSize_ ??\n    ((typeof client.batch?.multicall === 'object' &&\n      client.batch.multicall.batchSize) ||\n      1_024)\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. multicallAddress is required.',\n      )\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({ abi, args, functionName })\n\n      currentChunkSize += (callData.length - 2) / 2\n      // Check to see if we need to create a new chunk.\n      if (\n        // Check if batching is enabled.\n        batchSize > 0 &&\n        // Check if the current size of the batch exceeds the size limit.\n        currentChunkSize > batchSize &&\n        // Check if the current chunk is not already empty.\n        chunkedCalls[currentChunk].length > 0\n      ) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n        sender: account,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const aggregate3Results = await Promise.allSettled(\n    chunkedCalls.map((calls) =>\n      getAction(\n        client,\n        readContract,\n        'readContract',\n      )({\n        abi: multicall3Abi,\n        account,\n        address: multicallAddress!,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n        stateOverride,\n      }),\n    ),\n  )\n\n  const results = []\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i]\n\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined,\n        })\n      }\n      continue\n    }\n\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const { returnData, success } = aggregate3Result[j]\n\n      // Extract the request call data from the original call.\n      const { callData } = chunkedCalls[i][j]\n\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const { abi, address, functionName, args } = contracts[\n        results.length\n      ] as ContractFunctionParameters\n\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError()\n        if (!success) throw new RawContractError({ data: returnData })\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName,\n        })\n        results.push(allowFailure ? { result, status: 'success' } : result)\n      } catch (err) {\n        const error = getContractError(err as BaseError, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName,\n        })\n        if (!allowFailure) throw error\n        results.push({ error, result: undefined, status: 'failure' })\n      }\n    }\n  }\n\n  if (results.length !== contracts.length)\n    throw new BaseError('multicall results mismatch')\n  return results as MulticallReturnType<contracts, allowFailure>\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}