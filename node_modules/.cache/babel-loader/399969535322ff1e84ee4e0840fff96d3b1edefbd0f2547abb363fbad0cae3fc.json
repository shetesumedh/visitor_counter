{"ast":null,"code":"import { ConnectorAlreadyConnectedError } from '../errors/config.js';\n/** https://wagmi.sh/core/api/actions/connect */\nexport async function connect(config, parameters) {\n  // \"Register\" connector if not already created\n  let connector;\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector);\n  } else connector = parameters.connector;\n  // Check if connector is already connected\n  if (connector.uid === config.state.current) throw new ConnectorAlreadyConnectedError();\n  try {\n    config.setState(x => ({\n      ...x,\n      status: 'connecting'\n    }));\n    connector.emitter.emit('message', {\n      type: 'connecting'\n    });\n    const {\n      connector: _,\n      ...rest\n    } = parameters;\n    const data = await connector.connect(rest);\n    const accounts = data.accounts;\n    connector.emitter.off('connect', config._internal.events.connect);\n    connector.emitter.on('change', config._internal.events.change);\n    connector.emitter.on('disconnect', config._internal.events.disconnect);\n    await config.storage?.setItem('recentConnectorId', connector.id);\n    config.setState(x => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts,\n        chainId: data.chainId,\n        connector: connector\n      }),\n      current: connector.uid,\n      status: 'connected'\n    }));\n    return {\n      accounts,\n      chainId: data.chainId\n    };\n  } catch (error) {\n    config.setState(x => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected'\n    }));\n    throw error;\n  }\n}","map":{"version":3,"names":["ConnectorAlreadyConnectedError","connect","config","parameters","connector","_internal","connectors","setup","uid","state","current","setState","x","status","emitter","emit","type","_","rest","data","accounts","off","events","on","change","disconnect","storage","setItem","id","connections","Map","set","chainId","error"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/@wagmi/core/src/actions/connect.ts"],"sourcesContent":["import type {\n  Address,\n  ResourceUnavailableRpcErrorType,\n  UserRejectedRequestErrorType,\n} from 'viem'\n\nimport type { CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connector } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport {\n  ConnectorAlreadyConnectedError,\n  type ConnectorAlreadyConnectedErrorType,\n} from '../errors/config.js'\nimport type { ChainIdParameter } from '../types/properties.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type ConnectParameters<\n  config extends Config = Config,\n  connector extends Connector | CreateConnectorFn =\n    | Connector\n    | CreateConnectorFn,\n  ///\n  parameters extends unknown | undefined =\n    | (connector extends CreateConnectorFn\n        ? Omit<\n            NonNullable<Parameters<ReturnType<connector>['connect']>[0]>,\n            'isReconnecting'\n          >\n        : never)\n    | (connector extends Connector\n        ? Omit<\n            NonNullable<Parameters<connector['connect']>[0]>,\n            'isReconnecting'\n          >\n        : never),\n> = Compute<\n  ChainIdParameter<config> & {\n    connector: connector | CreateConnectorFn\n  }\n> &\n  parameters\n\nexport type ConnectReturnType<config extends Config = Config> = {\n  accounts: readonly [Address, ...Address[]]\n  chainId:\n    | config['chains'][number]['id']\n    | (number extends config['chains'][number]['id'] ? number : number & {})\n}\n\nexport type ConnectErrorType =\n  | ConnectorAlreadyConnectedErrorType\n  // connector.connect()\n  | UserRejectedRequestErrorType\n  | ResourceUnavailableRpcErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/connect */\nexport async function connect<\n  config extends Config,\n  connector extends Connector | CreateConnectorFn,\n>(\n  config: config,\n  parameters: ConnectParameters<config, connector>,\n): Promise<ConnectReturnType<config>> {\n  // \"Register\" connector if not already created\n  let connector: Connector\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector)\n  } else connector = parameters.connector\n\n  // Check if connector is already connected\n  if (connector.uid === config.state.current)\n    throw new ConnectorAlreadyConnectedError()\n\n  try {\n    config.setState((x) => ({ ...x, status: 'connecting' }))\n    connector.emitter.emit('message', { type: 'connecting' })\n\n    const { connector: _, ...rest } = parameters\n    const data = await connector.connect(rest)\n    const accounts = data.accounts as readonly [Address, ...Address[]]\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    await config.storage?.setItem('recentConnectorId', connector.id)\n    config.setState((x) => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts,\n        chainId: data.chainId,\n        connector: connector,\n      }),\n      current: connector.uid,\n      status: 'connected',\n    }))\n\n    return { accounts, chainId: data.chainId }\n  } catch (error) {\n    config.setState((x) => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected',\n    }))\n    throw error\n  }\n}\n"],"mappings":"AASA,SACEA,8BAA8B,QAEzB,qBAAqB;AA8C5B;AACA,OAAO,eAAeC,OAAOA,CAI3BC,MAAc,EACdC,UAAgD;EAEhD;EACA,IAAIC,SAAoB;EACxB,IAAI,OAAOD,UAAU,CAACC,SAAS,KAAK,UAAU,EAAE;IAC9CA,SAAS,GAAGF,MAAM,CAACG,SAAS,CAACC,UAAU,CAACC,KAAK,CAACJ,UAAU,CAACC,SAAS,CAAC;EACrE,CAAC,MAAMA,SAAS,GAAGD,UAAU,CAACC,SAAS;EAEvC;EACA,IAAIA,SAAS,CAACI,GAAG,KAAKN,MAAM,CAACO,KAAK,CAACC,OAAO,EACxC,MAAM,IAAIV,8BAA8B,EAAE;EAE5C,IAAI;IACFE,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MAAE,GAAGA,CAAC;MAAEC,MAAM,EAAE;IAAY,CAAE,CAAC,CAAC;IACxDT,SAAS,CAACU,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE;MAAEC,IAAI,EAAE;IAAY,CAAE,CAAC;IAEzD,MAAM;MAAEZ,SAAS,EAAEa,CAAC;MAAE,GAAGC;IAAI,CAAE,GAAGf,UAAU;IAC5C,MAAMgB,IAAI,GAAG,MAAMf,SAAS,CAACH,OAAO,CAACiB,IAAI,CAAC;IAC1C,MAAME,QAAQ,GAAGD,IAAI,CAACC,QAA4C;IAElEhB,SAAS,CAACU,OAAO,CAACO,GAAG,CAAC,SAAS,EAAEnB,MAAM,CAACG,SAAS,CAACiB,MAAM,CAACrB,OAAO,CAAC;IACjEG,SAAS,CAACU,OAAO,CAACS,EAAE,CAAC,QAAQ,EAAErB,MAAM,CAACG,SAAS,CAACiB,MAAM,CAACE,MAAM,CAAC;IAC9DpB,SAAS,CAACU,OAAO,CAACS,EAAE,CAAC,YAAY,EAAErB,MAAM,CAACG,SAAS,CAACiB,MAAM,CAACG,UAAU,CAAC;IAEtE,MAAMvB,MAAM,CAACwB,OAAO,EAAEC,OAAO,CAAC,mBAAmB,EAAEvB,SAAS,CAACwB,EAAE,CAAC;IAChE1B,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MACtB,GAAGA,CAAC;MACJiB,WAAW,EAAE,IAAIC,GAAG,CAAClB,CAAC,CAACiB,WAAW,CAAC,CAACE,GAAG,CAAC3B,SAAS,CAACI,GAAG,EAAE;QACrDY,QAAQ;QACRY,OAAO,EAAEb,IAAI,CAACa,OAAO;QACrB5B,SAAS,EAAEA;OACZ,CAAC;MACFM,OAAO,EAAEN,SAAS,CAACI,GAAG;MACtBK,MAAM,EAAE;KACT,CAAC,CAAC;IAEH,OAAO;MAAEO,QAAQ;MAAEY,OAAO,EAAEb,IAAI,CAACa;IAAO,CAAE;EAC5C,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd/B,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MACtB,GAAGA,CAAC;MACJ;MACAC,MAAM,EAAED,CAAC,CAACF,OAAO,GAAG,WAAW,GAAG;KACnC,CAAC,CAAC;IACH,MAAMuB,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}