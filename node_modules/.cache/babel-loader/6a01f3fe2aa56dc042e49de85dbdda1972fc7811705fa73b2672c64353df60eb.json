{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSize = assertSize;\nexports.fromHex = fromHex;\nexports.hexToBigInt = hexToBigInt;\nexports.hexToBool = hexToBool;\nexports.hexToNumber = hexToNumber;\nexports.hexToString = hexToString;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nfunction assertSize(hexOrBytes, {\n  size\n}) {\n  if ((0, size_js_1.size)(hexOrBytes) > size) throw new encoding_js_1.SizeOverflowError({\n    givenSize: (0, size_js_1.size)(hexOrBytes),\n    maxSize: size\n  });\n}\nfunction fromHex(hex, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return hexToNumber(hex, opts);\n  if (to === 'bigint') return hexToBigInt(hex, opts);\n  if (to === 'string') return hexToString(hex, opts);\n  if (to === 'boolean') return hexToBool(hex, opts);\n  return (0, toBytes_js_1.hexToBytes)(hex, opts);\n}\nfunction hexToBigInt(hex, opts = {}) {\n  const {\n    signed\n  } = opts;\n  if (opts.size) assertSize(hex, {\n    size: opts.size\n  });\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max = (1n << BigInt(size) * 8n - 1n) - 1n;\n  if (value <= max) return value;\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\nfunction hexToBool(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, {\n      size: opts.size\n    });\n    hex = (0, trim_js_1.trim)(hex);\n  }\n  if ((0, trim_js_1.trim)(hex) === '0x00') return false;\n  if ((0, trim_js_1.trim)(hex) === '0x01') return true;\n  throw new encoding_js_1.InvalidHexBooleanError(hex);\n}\nfunction hexToNumber(hex, opts = {}) {\n  return Number(hexToBigInt(hex, opts));\n}\nfunction hexToString(hex, opts = {}) {\n  let bytes = (0, toBytes_js_1.hexToBytes)(hex);\n  if (opts.size) {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = (0, trim_js_1.trim)(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}","map":{"version":3,"names":["exports","assertSize","fromHex","hexToBigInt","hexToBool","hexToNumber","hexToString","encoding_js_1","require","size_js_1","trim_js_1","toBytes_js_1","hexOrBytes","size","SizeOverflowError","givenSize","maxSize","hex","toOrOpts","opts","to","hexToBytes","signed","value","BigInt","length","max","padStart","hex_","trim","InvalidHexBooleanError","Number","bytes","dir","TextDecoder","decode"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/encoding/fromHex.ts"],"sourcesContent":["import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}