{"ast":null,"code":"import { Bytes } from '../../index.js';\nimport * as Ens from '../Ens.js';\nimport * as Hex from '../Hex.js';\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet) {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '');\n  if (value.length === 0) return new Uint8Array(1);\n  const bytes = new Uint8Array(Bytes.fromString(value).byteLength + 2);\n  let offset = 0;\n  const list = value.split('.');\n  for (let i = 0; i < list.length; i++) {\n    let encoded = Bytes.fromString(list[i]);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) encoded = Bytes.fromString(wrapLabelhash(Ens.labelhash(list[i])));\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1);\n  return bytes;\n}\n/** @internal */\nexport function wrapLabelhash(hash) {\n  return `[${hash.slice(2)}]`;\n}\n/** @internal */\nexport function unwrapLabelhash(label) {\n  if (label.length !== 66) return null;\n  if (label.indexOf('[') !== 0) return null;\n  if (label.indexOf(']') !== 65) return null;\n  const hash = `0x${label.slice(1, 65)}`;\n  if (!Hex.validate(hash, {\n    strict: true\n  })) return null;\n  return hash;\n}","map":{"version":3,"names":["Bytes","Ens","Hex","packetToBytes","packet","value","replace","length","Uint8Array","bytes","fromString","byteLength","offset","list","split","i","encoded","wrapLabelhash","labelhash","set","slice","hash","unwrapLabelhash","label","indexOf","validate","strict"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/internal/ens.ts"],"sourcesContent":["import { Bytes } from '../../index.js'\nimport * as Ens from '../Ens.js'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet: string): Bytes.Bytes {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (value.length === 0) return new Uint8Array(1)\n\n  const bytes = new Uint8Array(Bytes.fromString(value).byteLength + 2)\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    let encoded = Bytes.fromString(list[i]!)\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255)\n      encoded = Bytes.fromString(wrapLabelhash(Ens.labelhash(list[i]!)))\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)\n\n  return bytes\n}\n\nexport declare namespace packetToBytes {\n  type ErrorType =\n    | wrapLabelhash.ErrorType\n    | Ens.labelhash.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function wrapLabelhash(hash: Hex.Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`\n}\n\nexport declare namespace wrapLabelhash {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function unwrapLabelhash(label: string): Hex.Hex | null {\n  if (label.length !== 66) return null\n  if (label.indexOf('[') !== 0) return null\n  if (label.indexOf(']') !== 65) return null\n  const hash = `0x${label.slice(1, 65)}`\n  if (!Hex.validate(hash, { strict: true })) return null\n  return hash\n}\n\nexport declare namespace unwrapLabelhash {\n  type ErrorType = Hex.validate.ErrorType | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,gBAAgB;AACtC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAEhC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAEhC;;;;AAIA,OAAM,SAAUC,aAAaA,CAACC,MAAc;EAC1C;EACA,MAAMC,KAAK,GAAGD,MAAM,CAACE,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;EAC7C,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE,OAAO,IAAIC,UAAU,CAAC,CAAC,CAAC;EAEhD,MAAMC,KAAK,GAAG,IAAID,UAAU,CAACR,KAAK,CAACU,UAAU,CAACL,KAAK,CAAC,CAACM,UAAU,GAAG,CAAC,CAAC;EAEpE,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,IAAI,GAAGR,KAAK,CAACS,KAAK,CAAC,GAAG,CAAC;EAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACN,MAAM,EAAEQ,CAAC,EAAE,EAAE;IACpC,IAAIC,OAAO,GAAGhB,KAAK,CAACU,UAAU,CAACG,IAAI,CAACE,CAAC,CAAE,CAAC;IACxC;IACA;IACA,IAAIC,OAAO,CAACL,UAAU,GAAG,GAAG,EAC1BK,OAAO,GAAGhB,KAAK,CAACU,UAAU,CAACO,aAAa,CAAChB,GAAG,CAACiB,SAAS,CAACL,IAAI,CAACE,CAAC,CAAE,CAAC,CAAC,CAAC;IACpEN,KAAK,CAACG,MAAM,CAAC,GAAGI,OAAO,CAACT,MAAM;IAC9BE,KAAK,CAACU,GAAG,CAACH,OAAO,EAAEJ,MAAM,GAAG,CAAC,CAAC;IAC9BA,MAAM,IAAII,OAAO,CAACT,MAAM,GAAG,CAAC;EAC9B;EAEA,IAAIE,KAAK,CAACE,UAAU,KAAKC,MAAM,GAAG,CAAC,EAAE,OAAOH,KAAK,CAACW,KAAK,CAAC,CAAC,EAAER,MAAM,GAAG,CAAC,CAAC;EAEtE,OAAOH,KAAK;AACd;AAUA;AACA,OAAM,SAAUQ,aAAaA,CAACI,IAAa;EACzC,OAAO,IAAIA,IAAI,CAACD,KAAK,CAAC,CAAC,CAAC,GAAG;AAC7B;AAMA;AACA,OAAM,SAAUE,eAAeA,CAACC,KAAa;EAC3C,IAAIA,KAAK,CAAChB,MAAM,KAAK,EAAE,EAAE,OAAO,IAAI;EACpC,IAAIgB,KAAK,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI;EACzC,IAAID,KAAK,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,OAAO,IAAI;EAC1C,MAAMH,IAAI,GAAG,KAAKE,KAAK,CAACH,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;EACtC,IAAI,CAAClB,GAAG,CAACuB,QAAQ,CAACJ,IAAI,EAAE;IAAEK,MAAM,EAAE;EAAI,CAAE,CAAC,EAAE,OAAO,IAAI;EACtD,OAAOL,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}