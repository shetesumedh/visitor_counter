{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checksumAddress = checksumAddress;\nexports.getAddress = getAddress;\nconst address_js_1 = require(\"../../errors/address.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst keccak256_js_1 = require(\"../hash/keccak256.js\");\nconst lru_js_1 = require(\"../lru.js\");\nconst isAddress_js_1 = require(\"./isAddress.js\");\nconst checksumAddressCache = new lru_js_1.LruMap(8192);\nfunction checksumAddress(address_, chainId) {\n  if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);\n  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();\n  const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), 'bytes');\n  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase();\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase();\n    }\n  }\n  const result = `0x${address.join('')}`;\n  checksumAddressCache.set(`${address_}.${chainId}`, result);\n  return result;\n}\nfunction getAddress(address, chainId) {\n  if (!(0, isAddress_js_1.isAddress)(address, {\n    strict: false\n  })) throw new address_js_1.InvalidAddressError({\n    address\n  });\n  return checksumAddress(address, chainId);\n}","map":{"version":3,"names":["exports","checksumAddress","getAddress","address_js_1","require","toBytes_js_1","keccak256_js_1","lru_js_1","isAddress_js_1","checksumAddressCache","LruMap","address_","chainId","has","get","hexAddress","toLowerCase","substring","hash","keccak256","stringToBytes","address","length","split","i","toUpperCase","result","join","set","isAddress","strict","InvalidAddressError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/utils/address/getAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n"],"mappings":";;;;;AAmBAA,OAAA,CAAAC,eAAA,GAAAA,eAAA;AA4CAD,OAAA,CAAAE,UAAA,GAAAA,UAAA;AA7DA,MAAAC,YAAA,GAAAC,OAAA;AAEA,MAAAC,YAAA,GAAAD,OAAA;AAIA,MAAAE,cAAA,GAAAF,OAAA;AACA,MAAAG,QAAA,GAAAH,OAAA;AACA,MAAAI,cAAA,GAAAJ,OAAA;AAEA,MAAMK,oBAAoB,GAAiB,IAAIF,QAAA,CAAAG,MAAM,CAAU,IAAI,CAAC;AAOpE,SAAgBT,eAAeA,CAC7BU,QAAiB,EAWjBC,OAA4B;EAE5B,IAAIH,oBAAoB,CAACI,GAAG,CAAC,GAAGF,QAAQ,IAAIC,OAAO,EAAE,CAAC,EACpD,OAAOH,oBAAoB,CAACK,GAAG,CAAC,GAAGH,QAAQ,IAAIC,OAAO,EAAE,CAAE;EAE5D,MAAMG,UAAU,GAAGH,OAAO,GACtB,GAAGA,OAAO,GAAGD,QAAQ,CAACK,WAAW,EAAE,EAAE,GACrCL,QAAQ,CAACM,SAAS,CAAC,CAAC,CAAC,CAACD,WAAW,EAAE;EACvC,MAAME,IAAI,GAAG,IAAAZ,cAAA,CAAAa,SAAS,EAAC,IAAAd,YAAA,CAAAe,aAAa,EAACL,UAAU,CAAC,EAAE,OAAO,CAAC;EAE1D,MAAMM,OAAO,GAAG,CACdT,OAAO,GAAGG,UAAU,CAACE,SAAS,CAAC,GAAGL,OAAO,IAAI,CAACU,MAAM,CAAC,GAAGP,UAAU,EAClEQ,KAAK,CAAC,EAAE,CAAC;EACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,IAAIN,IAAI,CAACM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAIH,OAAO,CAACG,CAAC,CAAC,EAAE;MACxCH,OAAO,CAACG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC,CAACC,WAAW,EAAE;IACvC;IACA,IAAI,CAACP,IAAI,CAACM,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,IAAIH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChDH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,CAACC,WAAW,EAAE;IAC/C;EACF;EAEA,MAAMC,MAAM,GAAG,KAAKL,OAAO,CAACM,IAAI,CAAC,EAAE,CAAC,EAAW;EAC/ClB,oBAAoB,CAACmB,GAAG,CAAC,GAAGjB,QAAQ,IAAIC,OAAO,EAAE,EAAEc,MAAM,CAAC;EAC1D,OAAOA,MAAM;AACf;AAOA,SAAgBxB,UAAUA,CACxBmB,OAAe,EAWfT,OAAgB;EAEhB,IAAI,CAAC,IAAAJ,cAAA,CAAAqB,SAAS,EAACR,OAAO,EAAE;IAAES,MAAM,EAAE;EAAK,CAAE,CAAC,EACxC,MAAM,IAAI3B,YAAA,CAAA4B,mBAAmB,CAAC;IAAEV;EAAO,CAAE,CAAC;EAC5C,OAAOpB,eAAe,CAACoB,OAAO,EAAET,OAAO,CAAC;AAC1C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}