{"ast":null,"code":"import { generateMnemonic, mnemonicToSeedSync, validateMnemonic } from '@scure/bip39';\nimport * as Bytes from './Bytes.js';\nimport * as HdKey from './HdKey.js';\nexport { path } from './HdKey.js';\nexport { english, czech, french, italian, japanese, korean, portuguese, simplifiedChinese, spanish, traditionalChinese } from './internal/mnemonic/wordlists.js';\n/**\n * Generates a random mnemonic.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @param wordlist - The wordlist to use.\n * @param options - Generation options.\n * @returns The mnemonic.\n */\nexport function random(wordlist, options = {}) {\n  const {\n    strength = 128\n  } = options;\n  return generateMnemonic(wordlist, strength);\n}\n/**\n * Converts a mnemonic to a HD Key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic).derive(Mnemonic.path({ index: 1 }))\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The HD Key.\n */\nexport function toHdKey(mnemonic, options = {}) {\n  const {\n    passphrase\n  } = options;\n  const seed = toSeed(mnemonic, {\n    passphrase\n  });\n  return HdKey.fromSeed(seed);\n}\n/**\n * Converts a mnemonic to a private key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic)\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Paths\n *\n * You can derive a private key at a specific path using the `path` option.\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic, {\n *   path: Mnemonic.path({ index: 1 }) // 'm/44'/60'/0'/0/1' // [!code focus]\n * })\n * // @log: '0x...'\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The private key.\n */\nexport function toPrivateKey(mnemonic, options = {}) {\n  const {\n    path = HdKey.path(),\n    passphrase\n  } = options;\n  const hdKey = toHdKey(mnemonic, {\n    passphrase\n  }).derive(path);\n  if (options.as === 'Bytes') return Bytes.from(hdKey.privateKey);\n  return hdKey.privateKey;\n}\n/**\n * Converts a mnemonic to a master seed.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The master seed.\n */\nexport function toSeed(mnemonic, options = {}) {\n  const {\n    passphrase\n  } = options;\n  const seed = mnemonicToSeedSync(mnemonic, passphrase);\n  if (options.as === 'Hex') return Bytes.toHex(seed);\n  return seed;\n}\n/**\n * Checks if a mnemonic is valid, given a wordlist.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.validate(\n *   'buyer zoo end danger ice capable shrug naive twist relief mass bonus',\n *   Mnemonic.english\n * )\n * // @log: true\n * ```\n *\n * @param mnemonic - The mnemonic to validate.\n * @param wordlist - The wordlist to use.\n * @returns Whether the mnemonic is valid.\n */\nexport function validate(mnemonic, wordlist) {\n  return validateMnemonic(mnemonic, wordlist);\n}","map":{"version":3,"names":["generateMnemonic","mnemonicToSeedSync","validateMnemonic","Bytes","HdKey","path","english","czech","french","italian","japanese","korean","portuguese","simplifiedChinese","spanish","traditionalChinese","random","wordlist","options","strength","toHdKey","mnemonic","passphrase","seed","toSeed","fromSeed","toPrivateKey","hdKey","derive","as","from","privateKey","toHex","validate"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/core/Mnemonic.ts"],"sourcesContent":["import {\n  generateMnemonic,\n  mnemonicToSeedSync,\n  validateMnemonic,\n} from '@scure/bip39'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as HdKey from './HdKey.js'\nimport type * as Hex from './Hex.js'\n\nexport { path } from './HdKey.js'\n\nexport {\n  english,\n  czech,\n  french,\n  italian,\n  japanese,\n  korean,\n  portuguese,\n  simplifiedChinese,\n  spanish,\n  traditionalChinese,\n} from './internal/mnemonic/wordlists.js'\n\n/**\n * Generates a random mnemonic.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @param wordlist - The wordlist to use.\n * @param options - Generation options.\n * @returns The mnemonic.\n */\nexport function random(\n  wordlist: string[],\n  options: random.Options = {},\n): string {\n  const { strength = 128 } = options\n  return generateMnemonic(wordlist, strength)\n}\n\nexport declare namespace random {\n  type Options = {\n    /**\n     * The strength of the mnemonic to generate, in bits.\n     * @default 128\n     */\n    strength?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a HD Key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic).derive(Mnemonic.path({ index: 1 }))\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The HD Key.\n */\nexport function toHdKey(\n  mnemonic: string,\n  options: toHdKey.Options = {},\n): HdKey.HdKey {\n  const { passphrase } = options\n  const seed = toSeed(mnemonic, { passphrase })\n  return HdKey.fromSeed(seed)\n}\n\nexport declare namespace toHdKey {\n  type Options = {\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a private key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic)\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Paths\n *\n * You can derive a private key at a specific path using the `path` option.\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic, {\n *   path: Mnemonic.path({ index: 1 }) // 'm/44'/60'/0'/0/1' // [!code focus]\n * })\n * // @log: '0x...'\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The private key.\n */\nexport function toPrivateKey<as extends 'Bytes' | 'Hex' = 'Bytes'>(\n  mnemonic: string,\n  options: toPrivateKey.Options<as> = {},\n): toPrivateKey.ReturnType<as> {\n  const { path = HdKey.path(), passphrase } = options\n  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path)\n  if (options.as === 'Bytes') return Bytes.from(hdKey.privateKey) as never\n  return hdKey.privateKey as never\n}\n\nexport declare namespace toPrivateKey {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n    /** An optional path to derive the private key from. @default `m/44'/60'/0'/0/0` */\n    path?: string | undefined\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a master seed.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The master seed.\n */\nexport function toSeed<as extends 'Bytes' | 'Hex' = 'Bytes'>(\n  mnemonic: string,\n  options: toSeed.Options<as> = {},\n): toSeed.ReturnType<as> {\n  const { passphrase } = options\n  const seed = mnemonicToSeedSync(mnemonic, passphrase)\n  if (options.as === 'Hex') return Bytes.toHex(seed) as never\n  return seed as never\n}\n\nexport declare namespace toSeed {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Checks if a mnemonic is valid, given a wordlist.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.validate(\n *   'buyer zoo end danger ice capable shrug naive twist relief mass bonus',\n *   Mnemonic.english\n * )\n * // @log: true\n * ```\n *\n * @param mnemonic - The mnemonic to validate.\n * @param wordlist - The wordlist to use.\n * @returns Whether the mnemonic is valid.\n */\nexport function validate(mnemonic: string, wordlist: string[]): boolean {\n  return validateMnemonic(mnemonic, wordlist)\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,SACEA,gBAAgB,EAChBC,kBAAkB,EAClBC,gBAAgB,QACX,cAAc;AACrB,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,KAAK,MAAM,YAAY;AAGnC,SAASC,IAAI,QAAQ,YAAY;AAEjC,SACEC,OAAO,EACPC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,MAAM,EACNC,UAAU,EACVC,iBAAiB,EACjBC,OAAO,EACPC,kBAAkB,QACb,kCAAkC;AAEzC;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,MAAMA,CACpBC,QAAkB,EAClBC,OAAA,GAA0B,EAAE;EAE5B,MAAM;IAAEC,QAAQ,GAAG;EAAG,CAAE,GAAGD,OAAO;EAClC,OAAOlB,gBAAgB,CAACiB,QAAQ,EAAEE,QAAQ,CAAC;AAC7C;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,OAAOA,CACrBC,QAAgB,EAChBH,OAAA,GAA2B,EAAE;EAE7B,MAAM;IAAEI;EAAU,CAAE,GAAGJ,OAAO;EAC9B,MAAMK,IAAI,GAAGC,MAAM,CAACH,QAAQ,EAAE;IAAEC;EAAU,CAAE,CAAC;EAC7C,OAAOlB,KAAK,CAACqB,QAAQ,CAACF,IAAI,CAAC;AAC7B;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAM,SAAUG,YAAYA,CAC1BL,QAAgB,EAChBH,OAAA,GAAoC,EAAE;EAEtC,MAAM;IAAEb,IAAI,GAAGD,KAAK,CAACC,IAAI,EAAE;IAAEiB;EAAU,CAAE,GAAGJ,OAAO;EACnD,MAAMS,KAAK,GAAGP,OAAO,CAACC,QAAQ,EAAE;IAAEC;EAAU,CAAE,CAAC,CAACM,MAAM,CAACvB,IAAI,CAAC;EAC5D,IAAIa,OAAO,CAACW,EAAE,KAAK,OAAO,EAAE,OAAO1B,KAAK,CAAC2B,IAAI,CAACH,KAAK,CAACI,UAAU,CAAU;EACxE,OAAOJ,KAAK,CAACI,UAAmB;AAClC;AAmBA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUP,MAAMA,CACpBH,QAAgB,EAChBH,OAAA,GAA8B,EAAE;EAEhC,MAAM;IAAEI;EAAU,CAAE,GAAGJ,OAAO;EAC9B,MAAMK,IAAI,GAAGtB,kBAAkB,CAACoB,QAAQ,EAAEC,UAAU,CAAC;EACrD,IAAIJ,OAAO,CAACW,EAAE,KAAK,KAAK,EAAE,OAAO1B,KAAK,CAAC6B,KAAK,CAACT,IAAI,CAAU;EAC3D,OAAOA,IAAa;AACtB;AAiBA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUU,QAAQA,CAACZ,QAAgB,EAAEJ,QAAkB;EAC3D,OAAOf,gBAAgB,CAACmB,QAAQ,EAAEJ,QAAQ,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}