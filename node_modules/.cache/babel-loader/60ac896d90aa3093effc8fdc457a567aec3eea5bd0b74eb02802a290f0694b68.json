{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAbiItem = parseAbiItem;\nconst abiItem_js_1 = require(\"./errors/abiItem.js\");\nconst signatures_js_1 = require(\"./runtime/signatures.js\");\nconst structs_js_1 = require(\"./runtime/structs.js\");\nconst utils_js_1 = require(\"./runtime/utils.js\");\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === 'string') abiItem = (0, utils_js_1.parseSignature)(signature);else {\n    const structs = (0, structs_js_1.parseStructs)(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if ((0, signatures_js_1.isStructSignature)(signature_)) continue;\n      abiItem = (0, utils_js_1.parseSignature)(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new abiItem_js_1.InvalidAbiItemError({\n    signature\n  });\n  return abiItem;\n}","map":{"version":3,"names":["exports","parseAbiItem","abiItem_js_1","require","signatures_js_1","structs_js_1","utils_js_1","signature","abiItem","parseSignature","structs","parseStructs","length","i","signature_","isStructSignature","InvalidAbiItemError"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/abitype/src/human-readable/parseAbiItem.ts"],"sourcesContent":["import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n"],"mappings":";;;;;AA4EAA,OAAA,CAAAC,YAAA,GAAAA,YAAA;AAzEA,MAAAC,YAAA,GAAAC,OAAA;AACA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AAsEA,SAAgBF,YAAYA,CAG1BM,SAcG;EAEH,IAAIC,OAA4C;EAChD,IAAI,OAAOD,SAAS,KAAK,QAAQ,EAC/BC,OAAO,GAAG,IAAAF,UAAA,CAAAG,cAAc,EAACF,SAAS,CAA4B,MAC3D;IACH,MAAMG,OAAO,GAAG,IAAAL,YAAA,CAAAM,YAAY,EAACJ,SAA8B,CAAC;IAC5D,MAAMK,MAAM,GAAGL,SAAS,CAACK,MAAgB;IACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMC,UAAU,GAAIP,SAA+B,CAACM,CAAC,CAAE;MACvD,IAAI,IAAAT,eAAA,CAAAW,iBAAiB,EAACD,UAAU,CAAC,EAAE;MACnCN,OAAO,GAAG,IAAAF,UAAA,CAAAG,cAAc,EAACK,UAAU,EAAEJ,OAAO,CAA4B;MACxE;IACF;EACF;EAEA,IAAI,CAACF,OAAO,EAAE,MAAM,IAAIN,YAAA,CAAAc,mBAAmB,CAAC;IAAET;EAAS,CAAE,CAAC;EAC1D,OAAOC,OAAkC;AAC3C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}