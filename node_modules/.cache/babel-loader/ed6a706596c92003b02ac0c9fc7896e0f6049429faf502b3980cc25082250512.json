{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAbiParameters = parseAbiParameters;\nconst abiParameter_js_1 = require(\"./errors/abiParameter.js\");\nconst signatures_js_1 = require(\"./runtime/signatures.js\");\nconst structs_js_1 = require(\"./runtime/structs.js\");\nconst utils_js_1 = require(\"./runtime/utils.js\");\nconst utils_js_2 = require(\"./runtime/utils.js\");\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === 'string') {\n    const parameters = (0, utils_js_1.splitParameters)(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], {\n        modifiers: signatures_js_1.modifiers\n      }));\n    }\n  } else {\n    const structs = (0, structs_js_1.parseStructs)(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if ((0, signatures_js_1.isStructSignature)(signature)) continue;\n      const parameters = (0, utils_js_1.splitParameters)(signature);\n      const length = parameters.length;\n      for (let k = 0; k < length; k++) {\n        abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], {\n          modifiers: signatures_js_1.modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new abiParameter_js_1.InvalidAbiParametersError({\n    params\n  });\n  return abiParameters;\n}","map":{"version":3,"names":["exports","parseAbiParameters","abiParameter_js_1","require","signatures_js_1","structs_js_1","utils_js_1","utils_js_2","params","abiParameters","parameters","splitParameters","length","i","push","parseAbiParameter","modifiers","structs","parseStructs","signature","isStructSignature","k","InvalidAbiParametersError"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/abitype/src/human-readable/parseAbiParameters.ts"],"sourcesContent":["import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n"],"mappings":";;;;;AAqGAA,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAlGA,MAAAC,iBAAA,GAAAC,OAAA;AACA,MAAAC,eAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,UAAA,GAAAJ,OAAA;AA8FA,SAAgBF,kBAAkBA,CAGhCO,MAcG;EAEH,MAAMC,aAAa,GAAmB,EAAE;EACxC,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAME,UAAU,GAAG,IAAAJ,UAAA,CAAAK,eAAe,EAACH,MAAM,CAAC;IAC1C,MAAMI,MAAM,GAAGF,UAAU,CAACE,MAAM;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/BJ,aAAa,CAACK,IAAI,CAAC,IAAAP,UAAA,CAAAQ,iBAAkB,EAACL,UAAU,CAACG,CAAC,CAAE,EAAE;QAAEG,SAAS,EAATZ,eAAA,CAAAY;MAAS,CAAE,CAAC,CAAC;IACvE;EACF,CAAC,MAAM;IACL,MAAMC,OAAO,GAAG,IAAAZ,YAAA,CAAAa,YAAY,EAACV,MAA2B,CAAC;IACzD,MAAMI,MAAM,GAAGJ,MAAM,CAACI,MAAgB;IACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMM,SAAS,GAAIX,MAA4B,CAACK,CAAC,CAAE;MACnD,IAAI,IAAAT,eAAA,CAAAgB,iBAAiB,EAACD,SAAS,CAAC,EAAE;MAClC,MAAMT,UAAU,GAAG,IAAAJ,UAAA,CAAAK,eAAe,EAACQ,SAAS,CAAC;MAC7C,MAAMP,MAAM,GAAGF,UAAU,CAACE,MAAM;MAChC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,EAAES,CAAC,EAAE,EAAE;QAC/BZ,aAAa,CAACK,IAAI,CAChB,IAAAP,UAAA,CAAAQ,iBAAkB,EAACL,UAAU,CAACW,CAAC,CAAE,EAAE;UAAEL,SAAS,EAATZ,eAAA,CAAAY,SAAS;UAAEC;QAAO,CAAE,CAAC,CAC3D;MACH;IACF;EACF;EAEA,IAAIR,aAAa,CAACG,MAAM,KAAK,CAAC,EAC5B,MAAM,IAAIV,iBAAA,CAAAoB,yBAAyB,CAAC;IAAEd;EAAM,CAAE,CAAC;EAEjD,OAAOC,aAA2C;AACpD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}