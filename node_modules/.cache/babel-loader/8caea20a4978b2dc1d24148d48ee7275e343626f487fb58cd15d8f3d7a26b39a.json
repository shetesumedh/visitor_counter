{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toBlobs = toBlobs;\nconst blob_js_1 = require(\"../../constants/blob.js\");\nconst blob_js_2 = require(\"../../errors/blob.js\");\nconst cursor_js_1 = require(\"../cursor.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst toHex_js_1 = require(\"../encoding/toHex.js\");\nfunction toBlobs(parameters) {\n  const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');\n  const data = typeof parameters.data === 'string' ? (0, toBytes_js_1.hexToBytes)(parameters.data) : parameters.data;\n  const size_ = (0, size_js_1.size)(data);\n  if (!size_) throw new blob_js_2.EmptyBlobError();\n  if (size_ > blob_js_1.maxBytesPerTransaction) throw new blob_js_2.BlobSizeTooLargeError({\n    maxSize: blob_js_1.maxBytesPerTransaction,\n    size: size_\n  });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = (0, cursor_js_1.createCursor)(new Uint8Array(blob_js_1.bytesPerBlob));\n    let size = 0;\n    while (size < blob_js_1.fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (blob_js_1.bytesPerFieldElement - 1));\n      blob.pushByte(0x00);\n      blob.pushBytes(bytes);\n      if (bytes.length < 31) {\n        blob.pushByte(0x80);\n        active = false;\n        break;\n      }\n      size++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return to === 'bytes' ? blobs.map(x => x.bytes) : blobs.map(x => (0, toHex_js_1.bytesToHex)(x.bytes));\n}","map":{"version":3,"names":["exports","toBlobs","blob_js_1","require","blob_js_2","cursor_js_1","size_js_1","toBytes_js_1","toHex_js_1","parameters","to","data","hexToBytes","size_","size","EmptyBlobError","maxBytesPerTransaction","BlobSizeTooLargeError","maxSize","blobs","active","position","blob","createCursor","Uint8Array","bytesPerBlob","fieldElementsPerBlob","bytes","slice","bytesPerFieldElement","pushByte","pushBytes","length","push","map","x","bytesToHex"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/blob/toBlobs.ts"],"sourcesContent":["import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n"],"mappings":";;;;;AAsDAA,OAAA,CAAAC,OAAA,GAAAA,OAAA;AAtDA,MAAAC,SAAA,GAAAC,OAAA;AAMA,MAAAC,SAAA,GAAAD,OAAA;AAQA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,SAAA,GAAAH,OAAA;AACA,MAAAI,YAAA,GAAAJ,OAAA;AACA,MAAAK,UAAA,GAAAL,OAAA;AAqCA,SAAgBF,OAAOA,CAKrBQ,UAAuC;EACvC,MAAMC,EAAE,GACND,UAAU,CAACC,EAAE,KAAK,OAAOD,UAAU,CAACE,IAAI,KAAK,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC;EAC1E,MAAMA,IAAI,GACR,OAAOF,UAAU,CAACE,IAAI,KAAK,QAAQ,GAC/B,IAAAJ,YAAA,CAAAK,UAAU,EAACH,UAAU,CAACE,IAAI,CAAC,GAC3BF,UAAU,CAACE,IACH;EAEd,MAAME,KAAK,GAAG,IAAAP,SAAA,CAAAQ,IAAI,EAACH,IAAI,CAAC;EACxB,IAAI,CAACE,KAAK,EAAE,MAAM,IAAIT,SAAA,CAAAW,cAAc,EAAE;EACtC,IAAIF,KAAK,GAAGX,SAAA,CAAAc,sBAAsB,EAChC,MAAM,IAAIZ,SAAA,CAAAa,qBAAqB,CAAC;IAC9BC,OAAO,EAAEhB,SAAA,CAAAc,sBAAsB;IAC/BF,IAAI,EAAED;GACP,CAAC;EAEJ,MAAMM,KAAK,GAAG,EAAE;EAEhB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIC,QAAQ,GAAG,CAAC;EAChB,OAAOD,MAAM,EAAE;IACb,MAAME,IAAI,GAAG,IAAAjB,WAAA,CAAAkB,YAAY,EAAC,IAAIC,UAAU,CAACtB,SAAA,CAAAuB,YAAY,CAAC,CAAC;IAEvD,IAAIX,IAAI,GAAG,CAAC;IACZ,OAAOA,IAAI,GAAGZ,SAAA,CAAAwB,oBAAoB,EAAE;MAClC,MAAMC,KAAK,GAAGhB,IAAI,CAACiB,KAAK,CAACP,QAAQ,EAAEA,QAAQ,IAAInB,SAAA,CAAA2B,oBAAoB,GAAG,CAAC,CAAC,CAAC;MAGzEP,IAAI,CAACQ,QAAQ,CAAC,IAAI,CAAC;MAGnBR,IAAI,CAACS,SAAS,CAACJ,KAAK,CAAC;MAIrB,IAAIA,KAAK,CAACK,MAAM,GAAG,EAAE,EAAE;QACrBV,IAAI,CAACQ,QAAQ,CAAC,IAAI,CAAC;QACnBV,MAAM,GAAG,KAAK;QACd;MACF;MAEAN,IAAI,EAAE;MACNO,QAAQ,IAAI,EAAE;IAChB;IAEAF,KAAK,CAACc,IAAI,CAACX,IAAI,CAAC;EAClB;EAEA,OACEZ,EAAE,KAAK,OAAO,GACVS,KAAK,CAACe,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACR,KAAK,CAAC,GACzBR,KAAK,CAACe,GAAG,CAAEC,CAAC,IAAK,IAAA3B,UAAA,CAAA4B,UAAU,EAACD,CAAC,CAACR,KAAK,CAAC,CAAC;AAE7C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}