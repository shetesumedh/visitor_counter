{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simulateContract = simulateContract;\nconst parseAccount_js_1 = require(\"../../accounts/utils/parseAccount.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst getContractError_js_1 = require(\"../../utils/errors/getContractError.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst call_js_1 = require(\"./call.js\");\nasync function simulateContract(client, parameters) {\n  const {\n    abi,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...callRequest\n  } = parameters;\n  const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : client.account;\n  const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({\n    abi,\n    args,\n    functionName\n  });\n  try {\n    const {\n      data\n    } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account\n    });\n    const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n      abi,\n      args,\n      functionName,\n      data: data || '0x'\n    });\n    const minimizedAbi = abi.filter(abiItem => 'name' in abiItem && abiItem.name === parameters.functionName);\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account\n      }\n    };\n  } catch (error) {\n    throw (0, getContractError_js_1.getContractError)(error, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address\n    });\n  }\n}","map":{"version":3,"names":["exports","simulateContract","parseAccount_js_1","require","decodeFunctionResult_js_1","encodeFunctionData_js_1","getContractError_js_1","getAction_js_1","call_js_1","client","parameters","abi","address","args","dataSuffix","functionName","callRequest","account","parseAccount","calldata","encodeFunctionData","data","getAction","call","batch","replace","to","result","decodeFunctionResult","minimizedAbi","filter","abiItem","name","request","error","getContractError","docsPath","sender"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/actions/public/simulateContract.ts"],"sourcesContent":["import type { Abi, AbiFunction, AbiStateMutability, Address } from 'abitype'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, ParseAccount } from '../../types/account.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  ExtractAbiFunctionForArgs,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  NoInfer,\n  Prettify,\n  UnionEvaluate,\n  UnionOmit,\n} from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { WriteContractParameters } from '../wallet/writeContract.js'\n\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type GetMutabilityAwareValue<\n  abi extends Abi | readonly unknown[],\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  valueType = TransactionRequest['value'],\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunctionForArgs<abi, mutability, functionName, args>\n    : AbiFunction,\n  _Narrowable extends boolean = IsNarrowable<abi, Abi>,\n> = _Narrowable extends true\n  ? abiFunction['stateMutability'] extends 'payable'\n    ? { value?: NoInfer<valueType> | undefined }\n    : abiFunction['payable'] extends true\n      ? { value?: NoInfer<valueType> | undefined }\n      : { value?: undefined }\n  : { value?: NoInfer<valueType> | undefined }\n\nexport type SimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n  ///\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  account?: accountOverride | null | undefined\n  chain?: chainOverride | undefined\n  /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n  dataSuffix?: Hex | undefined\n} & ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    CallParameters<derivedChain>,\n    | 'account'\n    | 'batch'\n    | 'code'\n    | 'to'\n    | 'data'\n    | 'factory'\n    | 'factoryData'\n    | 'value'\n  > &\n  GetMutabilityAwareValue<\n    abi,\n    'nonpayable' | 'payable',\n    functionName,\n    CallParameters<derivedChain> extends CallParameters\n      ? CallParameters<derivedChain>['value']\n      : CallParameters['value'],\n    args\n  >\n\nexport type SimulateContractReturnType<\n  out abi extends Abi | readonly unknown[] = Abi,\n  in out functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  in out args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  /** @ts-expect-error cast variance */\n  out chain extends Chain | undefined = Chain | undefined,\n  out account extends Account | undefined = Account | undefined,\n  out chainOverride extends Chain | undefined = Chain | undefined,\n  out accountOverride extends Account | Address | null | undefined =\n    | Account\n    | Address\n    | null\n    | undefined,\n  ///\n  in out minimizedAbi extends Abi = readonly [\n    ExtractAbiFunctionForArgs<\n      abi extends Abi ? abi : Abi,\n      'nonpayable' | 'payable',\n      functionName,\n      args\n    >,\n  ],\n  out resolvedAccount extends\n    | Account\n    | null\n    | undefined = accountOverride extends Account | Address | null\n    ? ParseAccount<accountOverride>\n    : account,\n> = {\n  result: ContractFunctionReturnType<\n    minimizedAbi,\n    'nonpayable' | 'payable',\n    functionName,\n    args\n  >\n  request: Prettify<\n    UnionEvaluate<\n      UnionOmit<\n        WriteContractParameters<\n          minimizedAbi,\n          functionName,\n          args,\n          chain,\n          undefined,\n          chainOverride\n        >,\n        'account' | 'abi' | 'args' | 'chain' | 'functionName'\n      >\n    > &\n      ContractFunctionParameters<\n        minimizedAbi,\n        'nonpayable' | 'payable',\n        functionName,\n        args\n      > & {\n        chain: DeriveChain<chain, chainOverride>\n      } & (resolvedAccount extends Account | null\n        ? { account: resolvedAccount }\n        : { account?: undefined })\n  >\n}\n\nexport type SimulateContractErrorType =\n  | ParseAccountErrorType\n  | EncodeFunctionDataErrorType\n  | GetContractErrorReturnType<CallErrorType | DecodeFunctionResultErrorType>\n  | ErrorType\n\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<\n  SimulateContractReturnType<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >\n> {\n  const { abi, address, args, dataSuffix, functionName, ...callRequest } =\n    parameters as SimulateContractParameters\n\n  const account = callRequest.account\n    ? parseAccount(callRequest.account)\n    : client.account\n  const calldata = encodeFunctionData({ abi, args, functionName })\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account,\n    })\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    })\n    const minimizedAbi = abi.filter(\n      (abiItem) =>\n        'name' in abiItem && abiItem.name === parameters.functionName,\n    )\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account,\n      },\n    } as unknown as SimulateContractReturnType<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n"],"mappings":";;;;;AAgOAA,OAAA,CAAAC,gBAAA,GAAAA,gBAAA;AA9NA,MAAAC,iBAAA,GAAAC,OAAA;AAyBA,MAAAC,yBAAA,GAAAD,OAAA;AAIA,MAAAE,uBAAA,GAAAF,OAAA;AAIA,MAAAG,qBAAA,GAAAH,OAAA;AAOA,MAAAI,cAAA,GAAAJ,OAAA;AACA,MAAAK,SAAA,GAAAL,OAAA;AAqLO,eAAeF,gBAAgBA,CAapCQ,MAAyC,EACzCC,UAOC;EAYD,MAAM;IAAEC,GAAG;IAAEC,OAAO;IAAEC,IAAI;IAAEC,UAAU;IAAEC,YAAY;IAAE,GAAGC;EAAW,CAAE,GACpEN,UAAwC;EAE1C,MAAMO,OAAO,GAAGD,WAAW,CAACC,OAAO,GAC/B,IAAAf,iBAAA,CAAAgB,YAAY,EAACF,WAAW,CAACC,OAAO,CAAC,GACjCR,MAAM,CAACQ,OAAO;EAClB,MAAME,QAAQ,GAAG,IAAAd,uBAAA,CAAAe,kBAAkB,EAAC;IAAET,GAAG;IAAEE,IAAI;IAAEE;EAAY,CAAE,CAAC;EAChE,IAAI;IACF,MAAM;MAAEM;IAAI,CAAE,GAAG,MAAM,IAAAd,cAAA,CAAAe,SAAS,EAC9Bb,MAAM,EACND,SAAA,CAAAe,IAAI,EACJ,MAAM,CACP,CAAC;MACAC,KAAK,EAAE,KAAK;MACZH,IAAI,EAAE,GAAGF,QAAQ,GAAGL,UAAU,GAAGA,UAAU,CAACW,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE;MACpEC,EAAE,EAAEd,OAAO;MACX,GAAGI,WAAW;MACdC;KACD,CAAC;IACF,MAAMU,MAAM,GAAG,IAAAvB,yBAAA,CAAAwB,oBAAoB,EAAC;MAClCjB,GAAG;MACHE,IAAI;MACJE,YAAY;MACZM,IAAI,EAAEA,IAAI,IAAI;KACf,CAAC;IACF,MAAMQ,YAAY,GAAGlB,GAAG,CAACmB,MAAM,CAC5BC,OAAO,IACN,MAAM,IAAIA,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAKtB,UAAU,CAACK,YAAY,CAChE;IACD,OAAO;MACLY,MAAM;MACNM,OAAO,EAAE;QACPtB,GAAG,EAAEkB,YAAY;QACjBjB,OAAO;QACPC,IAAI;QACJC,UAAU;QACVC,YAAY;QACZ,GAAGC,WAAW;QACdC;;KAUH;EACH,CAAC,CAAC,OAAOiB,KAAK,EAAE;IACd,MAAM,IAAA5B,qBAAA,CAAA6B,gBAAgB,EAACD,KAAkB,EAAE;MACzCvB,GAAG;MACHC,OAAO;MACPC,IAAI;MACJuB,QAAQ,EAAE,iCAAiC;MAC3CrB,YAAY;MACZsB,MAAM,EAAEpB,OAAO,EAAEL;KAClB,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}