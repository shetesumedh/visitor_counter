{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseStructs = parseStructs;\nconst regex_js_1 = require(\"../../regex.js\");\nconst abiItem_js_1 = require(\"../errors/abiItem.js\");\nconst abiParameter_js_1 = require(\"../errors/abiParameter.js\");\nconst signature_js_1 = require(\"../errors/signature.js\");\nconst struct_js_1 = require(\"../errors/struct.js\");\nconst signatures_js_1 = require(\"./signatures.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!(0, signatures_js_1.isStructSignature)(signature)) continue;\n    const match = (0, signatures_js_1.execStructSignature)(signature);\n    if (!match) throw new signature_js_1.InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new signature_js_1.InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new abiParameter_js_1.InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new struct_js_1.CircularReferenceError({\n          type\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))\n        });\n      } else {\n        if ((0, utils_js_1.isSolidityType)(type)) components.push(abiParameter);else throw new abiItem_js_1.UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}","map":{"version":3,"names":["exports","parseStructs","regex_js_1","require","abiItem_js_1","abiParameter_js_1","signature_js_1","struct_js_1","signatures_js_1","utils_js_1","signatures","shallowStructs","signaturesLength","length","i","signature","isStructSignature","match","execStructSignature","InvalidSignatureError","type","properties","split","components","propertiesLength","k","property","trimmed","trim","abiParameter","parseAbiParameter","push","InvalidStructSignatureError","name","resolvedStructs","entries","Object","entriesLength","parameters","resolveStructs","typeWithoutTupleRegex","abiParameters","structs","ancestors","Set","isTuple","isTupleRegex","test","execTyped","InvalidAbiTypeParameterError","array","has","CircularReferenceError","isSolidityType","UnknownTypeError"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/abitype/src/human-readable/runtime/structs.ts"],"sourcesContent":["import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}