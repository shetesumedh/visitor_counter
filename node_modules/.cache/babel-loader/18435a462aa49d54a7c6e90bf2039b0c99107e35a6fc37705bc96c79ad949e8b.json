{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashTypedData = hashTypedData;\nexports.hashDomain = hashDomain;\nexports.hashStruct = hashStruct;\nexports.encodeType = encodeType;\nconst encodeAbiParameters_js_1 = require(\"../abi/encodeAbiParameters.js\");\nconst concat_js_1 = require(\"../data/concat.js\");\nconst toHex_js_1 = require(\"../encoding/toHex.js\");\nconst keccak256_js_1 = require(\"../hash/keccak256.js\");\nconst typedData_js_1 = require(\"../typedData.js\");\nfunction hashTypedData(parameters) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = parameters;\n  const types = {\n    EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({\n      domain\n    }),\n    ...parameters.types\n  };\n  (0, typedData_js_1.validateTypedData)({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = ['0x1901'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({\n    data: message,\n    primaryType,\n    types: types\n  }));\n  return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));\n}\nfunction hashDomain({\n  domain,\n  types\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types\n  });\n}\nfunction hashStruct({\n  data,\n  primaryType,\n  types\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types\n  });\n  return (0, keccak256_js_1.keccak256)(encoded);\n}\nfunction encodeData({\n  data,\n  primaryType,\n  types\n}) {\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);\n}\nfunction hashType({\n  primaryType,\n  types\n}) {\n  const encodedHashType = (0, toHex_js_1.toHex)(encodeType({\n    primaryType,\n    types\n  }));\n  return (0, keccak256_js_1.keccak256)(encodedHashType);\n}\nfunction encodeType({\n  primaryType,\n  types\n}) {\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    result += `${type}(${types[type].map(({\n      name,\n      type: t\n    }) => `${t} ${name}`).join(',')})`;\n  }\n  return result;\n}\nfunction findTypeDependencies({\n  primaryType: primaryType_,\n  types\n}, results = new Set()) {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField({\n  types,\n  name,\n  type,\n  value\n}) {\n  if (types[type] !== undefined) {\n    return [{\n      type: 'bytes32'\n    }, (0, keccak256_js_1.keccak256)(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : '';\n    value = `0x${prepend + value.slice(2)}`;\n    return [{\n      type: 'bytes32'\n    }, (0, keccak256_js_1.keccak256)(value)];\n  }\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))];\n  }\n  return [{\n    type\n  }, value];\n}","map":{"version":3,"names":["exports","hashTypedData","hashDomain","hashStruct","encodeType","encodeAbiParameters_js_1","require","concat_js_1","toHex_js_1","keccak256_js_1","typedData_js_1","parameters","domain","message","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","parts","push","data","keccak256","concat","encoded","encodeData","encodedTypes","type","encodedValues","hashType","field","value","encodeField","name","encodeAbiParameters","encodedHashType","toHex","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","t","join","primaryType_","results","Set","match","has","undefined","add","prepend","length","slice","lastIndexOf","parsedType","typeValuePairs","item","v"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/viem/utils/signature/hashTypedData.ts"],"sourcesContent":["// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}