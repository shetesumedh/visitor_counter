{"ast":null,"code":"import * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\n/**\n * Encodes data with a validator in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x00): `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, ValidatorData } from 'ox'\n *\n * const encoded = ValidatorData.encode({\n *   data: Hex.fromString('hello world'),\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n * })\n * // @log: '0x1900d8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * // @log: '0x19 ‖ 0x00 ‖ 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 ‖ \"hello world\"'\n * ```\n *\n * @param value - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(value) {\n  const {\n    data,\n    validator\n  } = value;\n  return Hex.concat(\n  // Validator Data Format: `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`\n  '0x19', '0x00', validator, Hex.from(data));\n}\n/**\n * Gets the payload to use for signing [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#0x00) data with an intended validator.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Secp256k1, ValidatorData } from 'ox'\n *\n * const payload = ValidatorData.getSignPayload({ // [!code focus]\n *   data: Hex.fromString('hello world'), // [!code focus]\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(value) {\n  return Hash.keccak256(encode(value));\n}","map":{"version":3,"names":["Hash","Hex","encode","value","data","validator","concat","from","getSignPayload","keccak256"],"sources":["/home/sumedhshete/visitor-counter/frontend/node_modules/ox/core/ValidatorData.ts"],"sourcesContent":["import type * as Address from './Address.js'\nimport type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Encodes data with a validator in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x00): `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, ValidatorData } from 'ox'\n *\n * const encoded = ValidatorData.encode({\n *   data: Hex.fromString('hello world'),\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n * })\n * // @log: '0x1900d8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * // @log: '0x19 ‖ 0x00 ‖ 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 ‖ \"hello world\"'\n * ```\n *\n * @param value - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(value: encode.Value): Hex.Hex {\n  const { data, validator } = value\n  return Hex.concat(\n    // Validator Data Format: `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`\n    '0x19',\n    '0x00',\n    validator,\n    Hex.from(data),\n  )\n}\n\nexport declare namespace encode {\n  type Value = {\n    data: Hex.Hex | Bytes.Bytes\n    validator: Address.Address\n  }\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#0x00) data with an intended validator.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Secp256k1, ValidatorData } from 'ox'\n *\n * const payload = ValidatorData.getSignPayload({ // [!code focus]\n *   data: Hex.fromString('hello world'), // [!code focus]\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(value: getSignPayload.Value): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type Value = {\n    data: Hex.Hex | Bytes.Bytes\n    validator: Address.Address\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n"],"mappings":"AAGA,OAAO,KAAKA,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAE/B;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,MAAMA,CAACC,KAAmB;EACxC,MAAM;IAAEC,IAAI;IAAEC;EAAS,CAAE,GAAGF,KAAK;EACjC,OAAOF,GAAG,CAACK,MAAM;EACf;EACA,MAAM,EACN,MAAM,EACND,SAAS,EACTJ,GAAG,CAACM,IAAI,CAACH,IAAI,CAAC,CACf;AACH;AAcA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUI,cAAcA,CAACL,KAA2B;EACxD,OAAOH,IAAI,CAACS,SAAS,CAACP,MAAM,CAACC,KAAK,CAAC,CAAC;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}