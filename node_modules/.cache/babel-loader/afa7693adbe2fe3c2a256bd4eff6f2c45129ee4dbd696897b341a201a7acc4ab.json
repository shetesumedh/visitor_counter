{"ast":null,"code":"/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, ensureBytes, memoized, randomBytes } from \"../utils.js\";\nimport { normalizeZ } from \"./curve.js\";\nimport { createHasher } from \"./hash-to-curve.js\";\nimport { getMinHashLength, mapHashToField } from \"./modular.js\";\nimport { _normFnElement, weierstrassPoints } from \"./weierstrass.js\";\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\nfunction aNonEmpty(arr) {\n  if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n}\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(fields, G1, G2, params) {\n  const {\n    Fp2,\n    Fp12\n  } = fields;\n  const {\n    twistType,\n    ateLoopSize,\n    xNegative,\n    postPrecompute\n  } = params;\n  // Applies sparse multiplication as line function\n  let lineFunction;\n  if (twistType === 'multiplicative') {\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (twistType === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell, Rx, Ry, Rz) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n    ell.push([c0, c1, c2]);\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n    ell.push([c0, c1, c2]);\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(ateLoopSize);\n  const calcPairingPrecomputes = memoized(point => {\n    const p = point;\n    const {\n      x,\n      y\n    } = p.toAffine();\n    // prettier-ignore\n    const Qx = x,\n      Qy = y,\n      negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx,\n      Ry = Qy,\n      Rz = Fp2.ONE;\n    const ell = [];\n    for (const bit of ATE_NAF) {\n      const cur = [];\n      ({\n        Rx,\n        Ry,\n        Rz\n      } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({\n        Rx,\n        Ry,\n        Rz\n      } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (postPrecompute) {\n      const last = ell[ell.length - 1];\n      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n  function millerLoopBatch(pairs, withFinalExponent = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (xNegative) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs, withFinalExponent = true) {\n    const res = [];\n    // Cache precomputed toAffine for all points\n    normalizeZ(G1, pairs.map(({\n      g1\n    }) => g1));\n    normalizeZ(G2, pairs.map(({\n      g2\n    }) => g2));\n    for (const {\n      g1,\n      g2\n    } of pairs) {\n      if (g1.is0() || g2.is0()) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q, P, withFinalExponent = true) {\n    return pairingBatch([{\n      g1: Q,\n      g2: P\n    }], withFinalExponent);\n  }\n  return {\n    Fp12,\n    // NOTE: we re-export Fp12 here because pairing results are Fp12!\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes\n  };\n}\nfunction createBlsSig(blsPairing, PubCurve, SigCurve, SignatureCoder, isSigG1) {\n  const {\n    Fp12,\n    pairingBatch\n  } = blsPairing;\n  function normPub(point) {\n    return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);\n  }\n  function normSig(point) {\n    return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);\n  }\n  function amsg(m) {\n    if (!(m instanceof SigCurve.Point)) throw new Error(`expected valid message hashed to ${!isSigG1 ? 'G2' : 'G1'} curve`);\n    return m;\n  }\n  // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n  const pair = !isSigG1 ? (a, b) => ({\n    g1: a,\n    g2: b\n  }) : (a, b) => ({\n    g1: b,\n    g2: a\n  });\n  return {\n    // P = pk x G\n    getPublicKey(secretKey) {\n      // TODO: replace with\n      // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      return PubCurve.Point.BASE.multiply(sec);\n    },\n    // S = pk x H(m)\n    sign(message, secretKey, unusedArg) {\n      if (unusedArg != null) throw new Error('sign() expects 2 arguments');\n      // TODO: replace with\n      // PubCurve.Point.Fn.fromBytes(secretKey)\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      amsg(message).assertValidity();\n      return message.multiply(sec);\n    },\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    // e(S, G) == e(H(m), P)\n    verify(signature, message, publicKey, unusedArg) {\n      if (unusedArg != null) throw new Error('verify() expects 3 arguments');\n      signature = normSig(signature);\n      publicKey = normPub(publicKey);\n      const P = publicKey.negate();\n      const G = PubCurve.Point.BASE;\n      const Hm = amsg(message);\n      const S = signature;\n      // This code was changed in 1.9.x:\n      // Before it was G.negate() in G2, now it's always pubKey.negate\n      // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n      // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);\n      return Fp12.eql(exp, Fp12.ONE);\n    },\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    verifyBatch(signature, messages, publicKeys) {\n      aNonEmpty(messages);\n      if (publicKeys.length !== messages.length) throw new Error('amount of public keys and messages should be equal');\n      const sig = normSig(signature);\n      const nMessages = messages;\n      const nPublicKeys = publicKeys.map(normPub);\n      // NOTE: this works only for exact same object\n      const messagePubKeyMap = new Map();\n      for (let i = 0; i < nPublicKeys.length; i++) {\n        const pub = nPublicKeys[i];\n        const msg = nMessages[i];\n        let keys = messagePubKeyMap.get(msg);\n        if (keys === undefined) {\n          keys = [];\n          messagePubKeyMap.set(msg, keys);\n        }\n        keys.push(pub);\n      }\n      const paired = [];\n      const G = PubCurve.Point.BASE;\n      try {\n        for (const [msg, keys] of messagePubKeyMap) {\n          const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n          paired.push(pair(groupPublicKey, msg));\n        }\n        paired.push(pair(G.negate(), sig));\n        return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n      } catch {\n        return false;\n      }\n    },\n    // Adds a bunch of public key points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregatePublicKeys(publicKeys) {\n      aNonEmpty(publicKeys);\n      publicKeys = publicKeys.map(pub => normPub(pub));\n      const agg = publicKeys.reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n    // Adds a bunch of signature points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregateSignatures(signatures) {\n      aNonEmpty(signatures);\n      signatures = signatures.map(sig => normSig(sig));\n      const agg = signatures.reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n    hash(messageBytes, DST) {\n      abytes(messageBytes);\n      const opts = DST ? {\n        DST\n      } : undefined;\n      return SigCurve.hashToCurve(messageBytes, opts);\n    },\n    Signature: SignatureCoder\n  };\n}\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nexport function bls(CURVE) {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const {\n    Fp,\n    Fr,\n    Fp2,\n    Fp6,\n    Fp12\n  } = CURVE.fields;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints(CURVE.G1);\n  const G1 = Object.assign(G1_, createHasher(G1_.Point, CURVE.G1.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G1.htfDefaults\n  }));\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints(CURVE.G2);\n  const G2 = Object.assign(G2_, createHasher(G2_.Point, CURVE.G2.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G2.htfDefaults\n  }));\n  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n    ...CURVE.params,\n    postPrecompute: CURVE.postPrecompute\n  });\n  const {\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes\n  } = pairingRes;\n  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n  const rand = CURVE.randomBytes || randomBytes;\n  const randomSecretKey = () => {\n    const length = getMinHashLength(Fr.ORDER);\n    return mapHashToField(rand(length), Fr.ORDER);\n  };\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n    calcPairingPrecomputes\n  };\n  const {\n    ShortSignature\n  } = CURVE.G1;\n  const {\n    Signature\n  } = CURVE.G2;\n  function normP1Hash(point, htfOpts) {\n    return point instanceof G1.Point ? point : shortSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function normP2Hash(point, htfOpts) {\n    return point instanceof G2.Point ? point : longSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function getPublicKey(privateKey) {\n    return longSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function getPublicKeyForShortSignatures(privateKey) {\n    return shortSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function sign(message, privateKey, htfOpts) {\n    const Hm = normP2Hash(message, htfOpts);\n    const S = longSignatures.sign(Hm, privateKey);\n    return message instanceof G2.Point ? S : Signature.toBytes(S);\n  }\n  function signShortSignature(message, privateKey, htfOpts) {\n    const Hm = normP1Hash(message, htfOpts);\n    const S = shortSignatures.sign(Hm, privateKey);\n    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n  }\n  function verify(signature, message, publicKey, htfOpts) {\n    const Hm = normP2Hash(message, htfOpts);\n    return longSignatures.verify(signature, Hm, publicKey);\n  }\n  function verifyShortSignature(signature, message, publicKey, htfOpts) {\n    const Hm = normP1Hash(message, htfOpts);\n    return shortSignatures.verify(signature, Hm, publicKey);\n  }\n  function aggregatePublicKeys(publicKeys) {\n    const agg = longSignatures.aggregatePublicKeys(publicKeys);\n    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n  }\n  function aggregateSignatures(signatures) {\n    const agg = longSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n  }\n  function aggregateShortSignatures(signatures) {\n    const agg = shortSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n  }\n  function verifyBatch(signature, messages, publicKeys, htfOpts) {\n    const Hm = messages.map(m => normP2Hash(m, htfOpts));\n    return longSignatures.verifyBatch(signature, Hm, publicKeys);\n  }\n  G1.Point.BASE.precompute(4);\n  return {\n    longSignatures,\n    shortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    verifyBatch,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      twistType: CURVE.params.twistType,\n      // deprecated\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b\n    },\n    utils,\n    // deprecated\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    G1,\n    G2,\n    Signature,\n    ShortSignature\n  };\n}","map":{"version":3,"names":["abytes","ensureBytes","memoized","randomBytes","normalizeZ","createHasher","getMinHashLength","mapHashToField","_normFnElement","weierstrassPoints","_0n","BigInt","_1n","_2n","_3n","NAfDecomposition","a","res","unshift","aNonEmpty","arr","Array","isArray","length","Error","createBlsPairing","fields","G1","G2","params","Fp2","Fp12","twistType","ateLoopSize","xNegative","postPrecompute","lineFunction","c0","c1","c2","f","Px","Py","mul014","mul","mul034","Fp2div2","div","ONE","pointDouble","ell","Rx","Ry","Rz","t0","sqr","t1","t2","mulByB","t3","t4","sub","add","neg","push","pointAdd","Qx","Qy","t5","ATE_NAF","calcPairingPrecomputes","point","p","x","y","toAffine","negQy","bit","cur","last","bind","millerLoopBatch","pairs","withFinalExponent","f12","ellLen","i","conjugate","finalExponentiate","pairingBatch","map","g1","g2","is0","assertValidity","Qa","pairing","Q","P","createBlsSig","blsPairing","PubCurve","SigCurve","SignatureCoder","isSigG1","normPub","Point","fromHex","normSig","amsg","m","pair","b","getPublicKey","secretKey","sec","Fn","BASE","multiply","sign","message","unusedArg","verify","signature","publicKey","negate","G","Hm","S","exp","eql","verifyBatch","messages","publicKeys","sig","nMessages","nPublicKeys","messagePubKeyMap","Map","pub","msg","keys","get","undefined","set","paired","groupPublicKey","reduce","acc","aggregatePublicKeys","agg","sum","ZERO","aggregateSignatures","signatures","s","hash","messageBytes","DST","opts","hashToCurve","Signature","bls","CURVE","Fp","Fr","Fp6","G1_","Object","assign","mapToCurve","htfDefaults","G2_","pairingRes","longSignatures","shortSignatures","ShortSignature","rand","randomSecretKey","ORDER","utils","randomPrivateKey","normP1Hash","htfOpts","normP2Hash","privateKey","toBytes","getPublicKeyForShortSignatures","signShortSignature","verifyShortSignature","aggregateShortSignatures","precompute","r","G1b","G2b"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/ox/node_modules/@noble/curves/src/abstract/bls.ts"],"sourcesContent":["/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  ensureBytes,\n  memoized,\n  randomBytes,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport { normalizeZ } from './curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CHashOpts,\n  type H2COpts,\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type MapToCurve,\n} from './hash-to-curve.ts';\nimport { getMinHashLength, mapHashToField, type IField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6Bls } from './tower.ts';\nimport {\n  _normFnElement,\n  weierstrassPoints,\n  type CurvePointsRes,\n  type CurvePointsType,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type BlsFields = {\n  Fp: IField<Fp>;\n  Fr: IField<bigint>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type BlsPairing = {\n  Fp12: Fp12Bls;\n  calcPairingPrecomputes: (p: WeierstrassPoint<Fp2>) => Precompute;\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: WeierstrassPoint<Fp>, Q: WeierstrassPoint<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: WeierstrassPoint<Fp>; g2: WeierstrassPoint<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n};\n// TODO: replace CurveType with this? It doesn't contain r however and has postPrecompute\nexport type BlsPairingParams = {\n  // NOTE: MSB is always ignored and used as marker for length,\n  // otherwise leading zeros will be lost.\n  // Can be different from 'X' (seed) param!\n  ateLoopSize: bigint;\n  xNegative: boolean;\n  twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\nexport type CurveType = {\n  G1: CurvePointsType<Fp> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: H2COpts;\n  };\n  G2: CurvePointsType<Fp2> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: H2COpts;\n  };\n  fields: BlsFields;\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: BlsPairingParams['ateLoopSize'];\n    xNegative: BlsPairingParams['xNegative'];\n    r: bigint; // TODO: remove\n    twistType: BlsPairingParams['twistType']; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: H2COpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\n/**\n * BLS consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n */\nexport interface BLSCurvePair {\n  longSignatures: BLSSigs<bigint, Fp2>;\n  shortSignatures: BLSSigs<Fp2, bigint>;\n  millerLoopBatch: BlsPairing['millerLoopBatch'];\n  pairing: BlsPairing['pairing'];\n  pairingBatch: BlsPairing['pairingBatch'];\n  G1: { Point: WeierstrassPointCons<bigint> } & H2CHasher<Fp>;\n  G2: { Point: WeierstrassPointCons<Fp2> } & H2CHasher<Fp2>;\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: Fp6Bls;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use randomSecretKey */\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: BlsPairing['calcPairingPrecomputes'];\n  };\n}\n\nexport type CurveFn = BLSCurvePair & {\n  /** @deprecated use `longSignatures.getPublicKey` */\n  getPublicKey: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `shortSignatures.getPublicKey` */\n  getPublicKeyForShortSignatures: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `longSignatures.sign` */\n  sign: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp2>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.sign` */\n  signShortSignature: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.verify` */\n  verify: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    message: Hex | WeierstrassPoint<Fp2>,\n    publicKey: Hex | WeierstrassPoint<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `shortSignatures.verify` */\n  verifyShortSignature: (\n    signature: Hex | WeierstrassPoint<Fp>,\n    message: Hex | WeierstrassPoint<Fp>,\n    publicKey: Hex | WeierstrassPoint<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    messages: (Hex | WeierstrassPoint<Fp2>)[],\n    publicKeys: (Hex | WeierstrassPoint<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `longSignatures.aggregatePublicKeys` */\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.aggregateSignatures` */\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp2>[]): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.aggregateSignatures` */\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  G1: CurvePointsRes<Fp> & H2CHasher<Fp>;\n  G2: CurvePointsRes<Fp2> & H2CHasher<Fp2>;\n  /** @deprecated use `longSignatures.Signature` */\n  Signature: SignatureCoder<Fp2>;\n  /** @deprecated use `shortSignatures.Signature` */\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    twistType: TwistType;\n    /** @deprecated */\n    G1b: bigint;\n    /** @deprecated */\n    G2b: Fp2;\n  };\n};\n\ntype BLSInput = Hex | Uint8Array;\nexport interface BLSSigs<P, S> {\n  getPublicKey(secretKey: PrivKey): WeierstrassPoint<P>;\n  sign(hashedMessage: WeierstrassPoint<S>, secretKey: PrivKey): WeierstrassPoint<S>;\n  verify(\n    signature: WeierstrassPoint<S> | BLSInput,\n    message: WeierstrassPoint<S>,\n    publicKey: WeierstrassPoint<P> | BLSInput\n  ): boolean;\n  verifyBatch: (\n    signature: WeierstrassPoint<S> | BLSInput,\n    messages: WeierstrassPoint<S>[],\n    publicKeys: (WeierstrassPoint<P> | BLSInput)[]\n  ) => boolean;\n  aggregatePublicKeys(publicKeys: (WeierstrassPoint<P> | BLSInput)[]): WeierstrassPoint<P>;\n  aggregateSignatures(signatures: (WeierstrassPoint<S> | BLSInput)[]): WeierstrassPoint<S>;\n  hash(message: Uint8Array, DST?: string | Uint8Array, hashOpts?: H2CHashOpts): WeierstrassPoint<S>;\n  Signature: SignatureCoder<S>;\n}\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nfunction aNonEmpty(arr: any[]) {\n  if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n}\n\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(\n  fields: BlsFields,\n  G1: WeierstrassPointCons<Fp>,\n  G2: WeierstrassPointCons<Fp2>,\n  params: BlsPairingParams\n): BlsPairing {\n  const { Fp2, Fp12 } = fields;\n  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;\n  type G1 = typeof G1.BASE;\n  type G2 = typeof G2.BASE;\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (twistType === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (twistType === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (postPrecompute) {\n      const last = ell[ell.length - 1];\n      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (xNegative) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    normalizeZ(\n      G1,\n      pairs.map(({ g1 }) => g1)\n    );\n    normalizeZ(\n      G2,\n      pairs.map(({ g2 }) => g2)\n    );\n    for (const { g1, g2 } of pairs) {\n      if (g1.is0() || g2.is0()) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n  return {\n    Fp12, // NOTE: we re-export Fp12 here because pairing results are Fp12!\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes,\n  };\n}\n\nfunction createBlsSig<P, S>(\n  blsPairing: BlsPairing,\n  PubCurve: CurvePointsRes<P> & H2CHasher<P>,\n  SigCurve: CurvePointsRes<S> & H2CHasher<S>,\n  SignatureCoder: SignatureCoder<S>,\n  isSigG1: boolean\n): BLSSigs<P, S> {\n  const { Fp12, pairingBatch } = blsPairing;\n  type PubPoint = WeierstrassPoint<P>;\n  type SigPoint = WeierstrassPoint<S>;\n  function normPub(point: PubPoint | BLSInput): PubPoint {\n    return point instanceof PubCurve.Point ? (point as PubPoint) : PubCurve.Point.fromHex(point);\n  }\n  function normSig(point: SigPoint | BLSInput): SigPoint {\n    return point instanceof SigCurve.Point ? (point as SigPoint) : SigCurve.Point.fromHex(point);\n  }\n  function amsg(m: unknown): SigPoint {\n    if (!(m instanceof SigCurve.Point))\n      throw new Error(`expected valid message hashed to ${!isSigG1 ? 'G2' : 'G1'} curve`);\n    return m as SigPoint;\n  }\n\n  type G1 = CurvePointsRes<Fp>['Point']['BASE'];\n  type G2 = CurvePointsRes<Fp2>['Point']['BASE'];\n  type PairingInput = { g1: G1; g2: G2 };\n  // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n  const pair: (a: PubPoint, b: SigPoint) => PairingInput = !isSigG1\n    ? (a: PubPoint, b: SigPoint) => ({ g1: a, g2: b }) as PairingInput\n    : (a: PubPoint, b: SigPoint) => ({ g1: b, g2: a }) as PairingInput;\n  return {\n    // P = pk x G\n    getPublicKey(secretKey: PrivKey): PubPoint {\n      // TODO: replace with\n      // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      return PubCurve.Point.BASE.multiply(sec);\n    },\n    // S = pk x H(m)\n    sign(message: SigPoint, secretKey: PrivKey, unusedArg?: any): SigPoint {\n      if (unusedArg != null) throw new Error('sign() expects 2 arguments');\n      // TODO: replace with\n      // PubCurve.Point.Fn.fromBytes(secretKey)\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      amsg(message).assertValidity();\n      return message.multiply(sec);\n    },\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    // e(S, G) == e(H(m), P)\n    verify(\n      signature: SigPoint | BLSInput,\n      message: SigPoint,\n      publicKey: PubPoint | BLSInput,\n      unusedArg?: any\n    ): boolean {\n      if (unusedArg != null) throw new Error('verify() expects 3 arguments');\n      signature = normSig(signature);\n      publicKey = normPub(publicKey);\n      const P = publicKey.negate();\n      const G = PubCurve.Point.BASE;\n      const Hm = amsg(message);\n      const S = signature;\n      // This code was changed in 1.9.x:\n      // Before it was G.negate() in G2, now it's always pubKey.negate\n      // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n      // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);\n      return Fp12.eql(exp, Fp12.ONE);\n    },\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    verifyBatch(\n      signature: SigPoint | BLSInput,\n      messages: SigPoint[],\n      publicKeys: (PubPoint | BLSInput)[]\n    ): boolean {\n      aNonEmpty(messages);\n      if (publicKeys.length !== messages.length)\n        throw new Error('amount of public keys and messages should be equal');\n      const sig = normSig(signature);\n      const nMessages = messages;\n      const nPublicKeys = publicKeys.map(normPub);\n      // NOTE: this works only for exact same object\n      const messagePubKeyMap = new Map<SigPoint, PubPoint[]>();\n      for (let i = 0; i < nPublicKeys.length; i++) {\n        const pub = nPublicKeys[i];\n        const msg = nMessages[i];\n        let keys = messagePubKeyMap.get(msg);\n        if (keys === undefined) {\n          keys = [];\n          messagePubKeyMap.set(msg, keys);\n        }\n        keys.push(pub);\n      }\n      const paired = [];\n      const G = PubCurve.Point.BASE;\n      try {\n        for (const [msg, keys] of messagePubKeyMap) {\n          const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n          paired.push(pair(groupPublicKey, msg));\n        }\n        paired.push(pair(G.negate(), sig));\n        return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n      } catch {\n        return false;\n      }\n    },\n    // Adds a bunch of public key points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregatePublicKeys(publicKeys: (PubPoint | BLSInput)[]): PubPoint {\n      aNonEmpty(publicKeys);\n      publicKeys = publicKeys.map((pub) => normPub(pub));\n      const agg = (publicKeys as PubPoint[]).reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    // Adds a bunch of signature points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregateSignatures(signatures: (SigPoint | BLSInput)[]): SigPoint {\n      aNonEmpty(signatures);\n      signatures = signatures.map((sig) => normSig(sig));\n      const agg = (signatures as SigPoint[]).reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    hash(messageBytes: Uint8Array, DST?: string | Uint8Array): SigPoint {\n      abytes(messageBytes);\n      const opts = DST ? { DST } : undefined;\n      return SigCurve.hashToCurve(messageBytes, opts) as SigPoint;\n    },\n    Signature: SignatureCoder,\n  };\n}\n\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints(CURVE.G1);\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.Point, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints(CURVE.G2);\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.Point as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.Point.BASE;\n  type G2 = typeof G2.Point.BASE;\n\n  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n    ...CURVE.params,\n    postPrecompute: CURVE.postPrecompute,\n  });\n\n  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;\n  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n\n  const rand = CURVE.randomBytes || randomBytes;\n  const randomSecretKey = (): Uint8Array => {\n    const length = getMinHashLength(Fr.ORDER);\n    return mapHashToField(rand(length), Fr.ORDER);\n  };\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n    calcPairingPrecomputes,\n  };\n\n  // LEGACY code\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.Point\n      ? point\n      : shortSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.Point\n      ? point\n      : longSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return longSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return shortSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const Hm = normP2Hash(message, htfOpts);\n    const S = longSignatures.sign(Hm, privateKey);\n    return message instanceof G2.Point ? S : Signature.toBytes(S);\n  }\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const Hm = normP1Hash(message, htfOpts);\n    const S = shortSignatures.sign(Hm, privateKey);\n    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n  }\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP2Hash(message, htfOpts);\n    return longSignatures.verify(signature, Hm, publicKey);\n  }\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP1Hash(message, htfOpts);\n    return shortSignatures.verify(signature, Hm, publicKey);\n  }\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    const agg = longSignatures.aggregatePublicKeys(publicKeys);\n    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n  }\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    const agg = longSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n  }\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    const agg = shortSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n  }\n  function verifyBatch(\n    signature: G2Hex,\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = messages.map((m) => normP2Hash(m, htfOpts));\n    return longSignatures.verifyBatch(signature, Hm, publicKeys);\n  }\n\n  G1.Point.BASE.precompute(4);\n\n  return {\n    longSignatures,\n    shortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    verifyBatch,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      twistType: CURVE.params.twistType,\n      // deprecated\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n\n    // deprecated\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}