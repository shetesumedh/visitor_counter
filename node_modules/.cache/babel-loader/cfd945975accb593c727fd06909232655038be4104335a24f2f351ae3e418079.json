{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toHex = toHex;\nexports.boolToHex = boolToHex;\nexports.bytesToHex = bytesToHex;\nexports.numberToHex = numberToHex;\nexports.stringToHex = stringToHex;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst hexes = Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction toHex(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);\n  if (typeof value === 'string') {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\nfunction boolToHex(value, opts = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(hex, {\n      size: opts.size\n    });\n  }\n  return hex;\n}\nfunction bytesToHex(value, opts = {}) {\n  let string = '';\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]];\n  }\n  const hex = `0x${string}`;\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return hex;\n}\nfunction numberToHex(value_, opts = {}) {\n  const {\n    signed,\n    size\n  } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : '';\n    throw new encoding_js_1.IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`\n    });\n  }\n  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;\n  if (size) return (0, pad_js_1.pad)(hex, {\n    size\n  });\n  return hex;\n}\nconst encoder = new TextEncoder();\nfunction stringToHex(value_, opts = {}) {\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}","map":{"version":3,"names":["exports","toHex","boolToHex","bytesToHex","numberToHex","stringToHex","encoding_js_1","require","pad_js_1","fromHex_js_1","hexes","Array","from","length","_v","i","toString","padStart","value","opts","hex","Number","size","assertSize","pad","string","dir","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","undefined","min","encoder","TextEncoder","encode"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/encoding/toHex.ts"],"sourcesContent":["import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}