{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromRlp = fromRlp;\nconst base_js_1 = require(\"../../errors/base.js\");\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst cursor_js_1 = require(\"../cursor.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nfunction fromRlp(value, to = 'hex') {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0) throw new encoding_js_1.InvalidHexValueError(value);\n      return (0, toBytes_js_1.hexToBytes)(value);\n    }\n    return value;\n  })();\n  const cursor = (0, cursor_js_1.createCursor)(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY\n  });\n  const result = fromRlpCursor(cursor, to);\n  return result;\n}\nfunction fromRlpCursor(cursor, to = 'hex') {\n  if (cursor.bytes.length === 0) return to === 'hex' ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes;\n  const prefix = cursor.readByte();\n  if (prefix < 0x80) cursor.decrementPosition(1);\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80);\n    const bytes = cursor.readBytes(length);\n    return to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;\n  }\n  const length = readLength(cursor, prefix, 0xc0);\n  return readList(cursor, length, to);\n}\nfunction readLength(cursor, prefix, offset) {\n  if (offset === 0x80 && prefix < 0x80) return 1;\n  if (prefix <= offset + 55) return prefix - offset;\n  if (prefix === offset + 55 + 1) return cursor.readUint8();\n  if (prefix === offset + 55 + 2) return cursor.readUint16();\n  if (prefix === offset + 55 + 3) return cursor.readUint24();\n  if (prefix === offset + 55 + 4) return cursor.readUint32();\n  throw new base_js_1.BaseError('Invalid RLP prefix');\n}\nfunction readList(cursor, length, to) {\n  const position = cursor.position;\n  const value = [];\n  while (cursor.position - position < length) value.push(fromRlpCursor(cursor, to));\n  return value;\n}","map":{"version":3,"names":["exports","fromRlp","base_js_1","require","encoding_js_1","cursor_js_1","toBytes_js_1","toHex_js_1","value","to","bytes","length","InvalidHexValueError","hexToBytes","cursor","createCursor","recursiveReadLimit","Number","POSITIVE_INFINITY","result","fromRlpCursor","bytesToHex","prefix","readByte","decrementPosition","readLength","readBytes","readList","offset","readUint8","readUint16","readUint24","readUint32","BaseError","position","push"],"sources":["/home/sumedhshete/visitor-counter/frontend_sepolia/node_modules/viem/utils/encoding/fromRlp.ts"],"sourcesContent":["import { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nimport type { RecursiveArray } from './toRlp.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? RecursiveArray<ByteArray> : never)\n  | (to extends 'hex' ? RecursiveArray<Hex> : never)\n\nexport type FromRlpErrorType =\n  | CreateCursorErrorType\n  | FromRlpCursorErrorType\n  | HexToBytesErrorType\n  | InvalidHexValueErrorType\n  | ErrorType\n\nexport function fromRlp<to extends To = 'hex'>(\n  value: ByteArray | Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new InvalidHexValueError(value)\n      return hexToBytes(value)\n    }\n    return value\n  })()\n\n  const cursor = createCursor(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = fromRlpCursor(cursor, to)\n\n  return result as FromRlpReturnType<to>\n}\n\ntype FromRlpCursorErrorType =\n  | BytesToHexErrorType\n  | ReadLengthErrorType\n  | ReadListErrorType\n  | ErrorType\n\nfunction fromRlpCursor<to extends To = 'hex'>(\n  cursor: Cursor,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes\n    ) as FromRlpReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (to === 'hex' ? bytesToHex(bytes) : bytes) as FromRlpReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as FromRlpReturnType<to>\n}\n\ntype ReadLengthErrorType = BaseErrorType | ErrorType\n\nfunction readLength(cursor: Cursor, prefix: number, offset: number) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new BaseError('Invalid RLP prefix')\n}\n\ntype ReadListErrorType = ErrorType\n\nfunction readList<to extends To>(cursor: Cursor, length: number, to: to | To) {\n  const position = cursor.position\n  const value: FromRlpReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(fromRlpCursor(cursor, to))\n  return value\n}\n"],"mappings":";;;;;AA8BAA,OAAA,CAAAC,OAAA,GAAAA,OAAA;AA9BA,MAAAC,SAAA,GAAAC,OAAA;AACA,MAAAC,aAAA,GAAAD,OAAA;AAMA,MAAAE,WAAA,GAAAF,OAAA;AAKA,MAAAG,YAAA,GAAAH,OAAA;AACA,MAAAI,UAAA,GAAAJ,OAAA;AAiBA,SAAgBF,OAAOA,CACrBO,KAAsB,EACtBC,EAAA,GAA0B,KAAK;EAE/B,MAAMC,KAAK,GAAG,CAAC,MAAK;IAClB,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;MAC7B,IAAIA,KAAK,CAACG,MAAM,GAAG,CAAC,IAAIH,KAAK,CAACG,MAAM,GAAG,CAAC,KAAK,CAAC,EAC5C,MAAM,IAAIP,aAAA,CAAAQ,oBAAoB,CAACJ,KAAK,CAAC;MACvC,OAAO,IAAAF,YAAA,CAAAO,UAAU,EAACL,KAAK,CAAC;IAC1B;IACA,OAAOA,KAAK;EACd,CAAC,EAAC,CAAE;EAEJ,MAAMM,MAAM,GAAG,IAAAT,WAAA,CAAAU,YAAY,EAACL,KAAK,EAAE;IACjCM,kBAAkB,EAAEC,MAAM,CAACC;GAC5B,CAAC;EACF,MAAMC,MAAM,GAAGC,aAAa,CAACN,MAAM,EAAEL,EAAE,CAAC;EAExC,OAAOU,MAA+B;AACxC;AAQA,SAASC,aAAaA,CACpBN,MAAc,EACdL,EAAA,GAA0B,KAAK;EAE/B,IAAIK,MAAM,CAACJ,KAAK,CAACC,MAAM,KAAK,CAAC,EAC3B,OACEF,EAAE,KAAK,KAAK,GAAG,IAAAF,UAAA,CAAAc,UAAU,EAACP,MAAM,CAACJ,KAAK,CAAC,GAAGI,MAAM,CAACJ,KAAK;EAG1D,MAAMY,MAAM,GAAGR,MAAM,CAACS,QAAQ,EAAE;EAChC,IAAID,MAAM,GAAG,IAAI,EAAER,MAAM,CAACU,iBAAiB,CAAC,CAAC,CAAC;EAG9C,IAAIF,MAAM,GAAG,IAAI,EAAE;IACjB,MAAMX,MAAM,GAAGc,UAAU,CAACX,MAAM,EAAEQ,MAAM,EAAE,IAAI,CAAC;IAC/C,MAAMZ,KAAK,GAAGI,MAAM,CAACY,SAAS,CAACf,MAAM,CAAC;IACtC,OAAQF,EAAE,KAAK,KAAK,GAAG,IAAAF,UAAA,CAAAc,UAAU,EAACX,KAAK,CAAC,GAAGA,KAAK;EAClD;EAGA,MAAMC,MAAM,GAAGc,UAAU,CAACX,MAAM,EAAEQ,MAAM,EAAE,IAAI,CAAC;EAC/C,OAAOK,QAAQ,CAACb,MAAM,EAAEH,MAAM,EAAEF,EAAE,CAAgC;AACpE;AAIA,SAASgB,UAAUA,CAACX,MAAc,EAAEQ,MAAc,EAAEM,MAAc;EAChE,IAAIA,MAAM,KAAK,IAAI,IAAIN,MAAM,GAAG,IAAI,EAAE,OAAO,CAAC;EAC9C,IAAIA,MAAM,IAAIM,MAAM,GAAG,EAAE,EAAE,OAAON,MAAM,GAAGM,MAAM;EACjD,IAAIN,MAAM,KAAKM,MAAM,GAAG,EAAE,GAAG,CAAC,EAAE,OAAOd,MAAM,CAACe,SAAS,EAAE;EACzD,IAAIP,MAAM,KAAKM,MAAM,GAAG,EAAE,GAAG,CAAC,EAAE,OAAOd,MAAM,CAACgB,UAAU,EAAE;EAC1D,IAAIR,MAAM,KAAKM,MAAM,GAAG,EAAE,GAAG,CAAC,EAAE,OAAOd,MAAM,CAACiB,UAAU,EAAE;EAC1D,IAAIT,MAAM,KAAKM,MAAM,GAAG,EAAE,GAAG,CAAC,EAAE,OAAOd,MAAM,CAACkB,UAAU,EAAE;EAC1D,MAAM,IAAI9B,SAAA,CAAA+B,SAAS,CAAC,oBAAoB,CAAC;AAC3C;AAIA,SAASN,QAAQA,CAAgBb,MAAc,EAAEH,MAAc,EAAEF,EAAW;EAC1E,MAAMyB,QAAQ,GAAGpB,MAAM,CAACoB,QAAQ;EAChC,MAAM1B,KAAK,GAA4B,EAAE;EACzC,OAAOM,MAAM,CAACoB,QAAQ,GAAGA,QAAQ,GAAGvB,MAAM,EACxCH,KAAK,CAAC2B,IAAI,CAACf,aAAa,CAACN,MAAM,EAAEL,EAAE,CAAC,CAAC;EACvC,OAAOD,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}